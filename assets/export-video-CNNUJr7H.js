var us=Object.defineProperty;var Vt=r=>{throw TypeError(r)};var ms=(r,e,t)=>e in r?us(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var at=(r,e,t)=>ms(r,typeof e!="symbol"?e+"":e,t),Nt=(r,e,t)=>e.has(r)||Vt("Cannot "+t);var Wt=(r,e,t)=>(Nt(r,e,"read from private field"),t?t.call(r):e.get(r)),Ht=(r,e,t)=>e.has(r)?Vt("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),Lt=(r,e,t,s)=>(Nt(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t);import{e as fs,T as $t,g as hs,h as ps}from"./index-DQ-9F6AZ.js";/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */function g(r){if(!r)throw new Error("Assertion failed.")}const gr=r=>{const e=(r%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${r}.`)},K=r=>r&&r[r.length-1],Oe=r=>r>=0&&r<2**32;class Z{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),t=this.bytes[e]??0,s=7-(this.pos&7),i=(t&1<<s)>>s;return this.pos++,i}readBits(e){if(e===1)return this.readBit();let t=0;for(let s=0;s<e;s++)t<<=1,t|=this.readBit();return t}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,t=this.bytes[e]??0;return this.pos+=8,t}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new Z(this.bytes);return e.pos=this.pos,e}}const E=r=>{let e=0;for(;r.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+r.readBits(e)},He=r=>{const e=E(r);return(e&1)===0?-(e>>1):e+1>>1},te=r=>r instanceof Uint8Array?r:r instanceof ArrayBuffer?new Uint8Array(r):new Uint8Array(r.buffer,r.byteOffset,r.byteLength),Ue=r=>r instanceof DataView?r:r instanceof ArrayBuffer?new DataView(r):new DataView(r.buffer,r.byteOffset,r.byteLength),Ee=new TextEncoder,It=r=>Object.fromEntries(Object.entries(r).map(([e,t])=>[t,e])),qe={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},kr=It(qe),Qe={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18},wr=It(Qe),Ge={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},Tr=It(Ge),gs=r=>!!r&&!!r.primaries&&!!r.transfer&&!!r.matrix&&r.fullRange!==void 0,it=r=>r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer||ArrayBuffer.isView(r);class Me{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const t=new Promise(i=>{e=i}),s=this.currentPromise;return this.currentPromise=t,await s,e}}const Kt=r=>[...r].map(e=>e.toString(16).padStart(2,"0")).join(""),jt=r=>(r=r>>1&1431655765|(r&1431655765)<<1,r=r>>2&858993459|(r&858993459)<<2,r=r>>4&252645135|(r&252645135)<<4,r=r>>8&16711935|(r&16711935)<<8,r=r>>16&65535|(r&65535)<<16,r>>>0),$=(r,e,t)=>{let s=0,i=r.length-1,n=-1;for(;s<=i;){const a=s+i>>1,o=t(r[a]);o===e?(n=a,i=a-1):o<e?s=a+1:i=a-1}return n},D=(r,e,t)=>{let s=0,i=r.length-1,n=-1;for(;s<=i;){const a=s+(i-s+1)/2|0;t(r[a])<=e?(n=a,s=a+1):i=a-1}return n},Fe=(r,e,t)=>{const s=D(r,t(e),t);r.splice(s+1,0,e)},Y=()=>{let r,e;return{promise:new Promise((s,i)=>{r=s,e=i}),resolve:r,reject:e}},ks=(r,e)=>{const t=r.indexOf(e);t!==-1&&r.splice(t,1)},br=(r,e)=>{for(let t=r.length-1;t>=0;t--)if(e(r[t]))return r[t]},yr=(r,e)=>{for(let t=r.length-1;t>=0;t--)if(e(r[t]))return t;return-1},ws=async function*(r){Symbol.iterator in r?yield*r[Symbol.iterator]():yield*r[Symbol.asyncIterator]()},Ts=r=>{if(!(Symbol.iterator in r)&&!(Symbol.asyncIterator in r))throw new TypeError("Argument must be an iterable or async iterable.")},$e=r=>{throw new Error(`Unexpected value: ${r}`)},Sr=(r,e,t)=>{const s=r.getUint8(e),i=r.getUint8(e+1),n=r.getUint8(e+2);return t?s|i<<8|n<<16:s<<16|i<<8|n},bs=(r,e,t)=>Sr(r,e,t)<<8>>8,xr=(r,e,t,s)=>{t=t>>>0,t=t&16777215,s?(r.setUint8(e,t&255),r.setUint8(e+1,t>>>8&255),r.setUint8(e+2,t>>>16&255)):(r.setUint8(e,t>>>16&255),r.setUint8(e+1,t>>>8&255),r.setUint8(e+2,t&255))},ys=(r,e,t,s)=>{t=X(t,-8388608,8388607),t<0&&(t=t+16777216&16777215),xr(r,e,t,s)},qt=(r,e)=>({async next(){const t=await r.next();return t.done?{value:void 0,done:!0}:{value:e(t.value),done:!1}},return(){return r.return()},throw(t){return r.throw(t)},[Symbol.asyncIterator](){return this}}),X=(r,e,t)=>Math.max(e,Math.min(t,r)),fe="und",Et=(r,e)=>{const t=10**e;return Math.round(r*t)/t},Ss=(r,e)=>Math.round(r/e)*e,xs=r=>{let e=0;for(;r;)e++,r>>=1;return e},Cs=/^[a-z]{3}$/,Rt=r=>Cs.test(r),ue=1e6*(1+Number.EPSILON),Ps=(r,e)=>{const t=r<0?-1:1;r=Math.abs(r);let s=0,i=1,n=1,a=0,o=r;for(;;){const d=Math.floor(o),u=d*n+s,l=d*a+i;if(l>e)return{numerator:t*n,denominator:a};if(s=n,i=a,n=u,a=l,o=1/(o-d),!isFinite(o))break}return{numerator:t*n,denominator:a}};class Ft{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const vs=[],Cr=[],_s=[],kt=[];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ye=["avc","hevc","vp9","av1","vp8"],G=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],Pr=["aac","opus","mp3","vorbis","flac"],Se=[...Pr,...G],st=["webvtt"],Qt=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Gt=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],me=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],Xt=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],Yt=".01.01.01.01.00",Zt=".0.110.01.01.01.0",Is=(r,e,t,s)=>{if(r==="avc"){const n=Math.ceil(e/16)*Math.ceil(t/16),a=Qt.find(f=>n<=f.maxMacroblocks&&s<=f.maxBitrate)??K(Qt),o=a?a.level:0,d="64".padStart(2,"0"),u="00",l=o.toString(16).padStart(2,"0");return`avc1.${d}${u}${l}`}else if(r==="hevc"){const i="",a="6",o=e*t,d=Gt.find(l=>o<=l.maxPictureSize&&s<=l.maxBitrate)??K(Gt);return`hev1.${i}1.${a}.${d.tier}${d.level}.B0`}else{if(r==="vp8")return"vp8";if(r==="vp9"){const i="00",n=e*t,a=me.find(d=>n<=d.maxPictureSize&&s<=d.maxBitrate)??K(me);return`vp09.${i}.${a.level.toString().padStart(2,"0")}.08`}else if(r==="av1"){const n=e*t,a=Xt.find(u=>n<=u.maxPictureSize&&s<=u.maxBitrate)??K(Xt);return`av01.0.${a.level.toString().padStart(2,"0")}${a.tier}.08`}}throw new TypeError(`Unhandled codec '${r}'.`)},Es=r=>{const e=r.split("."),i=(1<<7)+1,n=Number(e[1]),a=e[2],o=Number(a.slice(0,-1)),d=(n<<5)+o,u=a.slice(-1)==="H"?1:0,f=Number(e[3])===8?0:1,c=0,m=e[4]?Number(e[4]):0,h=e[5]?Number(e[5][0]):1,p=e[5]?Number(e[5][1]):1,k=e[5]?Number(e[5][2]):0,w=(u<<7)+(f<<6)+(c<<5)+(m<<4)+(h<<3)+(p<<2)+k;return[i,d,w,0]},vr=r=>{const{codec:e,codecDescription:t,colorSpace:s,avcCodecInfo:i,hevcCodecInfo:n,vp9CodecInfo:a,av1CodecInfo:o}=r;if(e==="avc"){if(i){const d=new Uint8Array([i.avcProfileIndication,i.profileCompatibility,i.avcLevelIndication]);return`avc1.${Kt(d)}`}if(!t||t.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc1.${Kt(t.subarray(1,4))}`}else if(e==="hevc"){let d,u,l,f,c,m;if(n)d=n.generalProfileSpace,u=n.generalProfileIdc,l=jt(n.generalProfileCompatibilityFlags),f=n.generalTierFlag,c=n.generalLevelIdc,m=[...n.generalConstraintIndicatorFlags];else{if(!t||t.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const p=Ue(t),k=p.getUint8(1);d=k>>6&3,u=k&31,l=jt(p.getUint32(2)),f=k>>5&1,c=p.getUint8(12),m=[];for(let w=0;w<6;w++)m.push(p.getUint8(6+w))}let h="hev1.";for(h+=["","A","B","C"][d]+u,h+=".",h+=l.toString(16).toUpperCase(),h+=".",h+=f===0?"L":"H",h+=c;m.length>0&&m[m.length-1]===0;)m.pop();return m.length>0&&(h+=".",h+=m.map(p=>p.toString(16).toUpperCase()).join(".")),h}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!a){const w=r.width*r.height;let T=K(me).level;for(const x of me)if(w<=x.maxPictureSize){T=x.level;break}return`vp09.00.${T.toString().padStart(2,"0")}.08`}const d=a.profile.toString().padStart(2,"0"),u=a.level.toString().padStart(2,"0"),l=a.bitDepth.toString().padStart(2,"0"),f=a.chromaSubsampling.toString().padStart(2,"0"),c=a.colourPrimaries.toString().padStart(2,"0"),m=a.transferCharacteristics.toString().padStart(2,"0"),h=a.matrixCoefficients.toString().padStart(2,"0"),p=a.videoFullRangeFlag.toString().padStart(2,"0");let k=`vp09.${d}.${u}.${l}.${f}`;return k+=`.${c}.${m}.${h}.${p}`,k.endsWith(Yt)&&(k=k.slice(0,-Yt.length)),k}else if(e==="av1"){if(!o){const x=r.width*r.height;let S=K(me).level;for(const b of me)if(x<=b.maxPictureSize){S=b.level;break}return`av01.0.${S.toString().padStart(2,"0")}M.08`}const d=o.profile,u=o.level.toString().padStart(2,"0"),l=o.tier?"H":"M",f=o.bitDepth.toString().padStart(2,"0"),c=o.monochrome?"1":"0",m=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),h=s!=null&&s.primaries?qe[s.primaries]:1,p=s!=null&&s.transfer?Qe[s.transfer]:1,k=s!=null&&s.matrix?Ge[s.matrix]:1,w=s!=null&&s.fullRange?1:0;let T=`av01.${d}.${u}${l}.${f}`;return T+=`.${c}.${m.toString().padStart(3,"0")}`,T+=`.${h.toString().padStart(2,"0")}`,T+=`.${p.toString().padStart(2,"0")}`,T+=`.${k.toString().padStart(2,"0")}`,T+=`.${w}`,T.endsWith(Zt)&&(T=T.slice(0,-Zt.length)),T}}throw new TypeError(`Unhandled codec '${e}'.`)},wt=(r,e,t)=>{if(r==="aac")return e>=2&&t<=24e3?"mp4a.40.29":t<=24e3?"mp4a.40.5":"mp4a.40.2";if(r==="mp3")return"mp3";if(r==="opus")return"opus";if(r==="vorbis")return"vorbis";if(r==="flac")return"flac";if(G.includes(r))return r;throw new TypeError(`Unhandled codec '${r}'.`)},_r=r=>{const{codec:e,codecDescription:t,aacCodecInfo:s}=r;if(e==="aac"){if(!s)throw new TypeError("AAC codec info must be provided.");return s.isMpeg2?"mp4a.67":`mp4a.40.${Ir(t).objectType}`}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&G.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},Ir=r=>{if(!r||r.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new Z(r);let t=e.readBits(5);t===31&&(t=32+e.readBits(6));const s=e.readBits(4);let i=null;if(s===15)i=e.readBits(24);else{const o=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350];s<o.length&&(i=o[s])}const n=e.readBits(4);let a=null;return n>=1&&n<=7&&(a={1:1,2:2,3:3,4:4,5:5,6:6,7:8}[n]),{objectType:t,frequencyIndex:s,sampleRate:i,channelConfiguration:n,numberOfChannels:a}},Rs=48e3,Er=/^pcm-([usf])(\d+)+(be)?$/,pe=r=>{if(g(G.includes(r)),r==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(r==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=Er.exec(r);g(e);let t;e[1]==="u"?t="unsigned":e[1]==="s"?t="signed":t="float";const s=Number(e[2])/8,i=e[3]!=="be",n=r==="pcm-u8"?2**7:0;return{dataType:t,sampleSize:s,littleEndian:i,silentValue:n}},Rr=r=>r.startsWith("avc1")||r.startsWith("avc3")?"avc":r.startsWith("hev1")||r.startsWith("hvc1")?"hevc":r==="vp8"?"vp8":r.startsWith("vp09")?"vp9":r.startsWith("av01")?"av1":r.startsWith("mp4a.40")||r==="mp4a.67"?"aac":r==="mp3"||r==="mp4a.69"||r==="mp4a.6B"||r==="mp4a.6b"?"mp3":r==="opus"?"opus":r==="vorbis"?"vorbis":r==="flac"?"flac":r==="ulaw"?"ulaw":r==="alaw"?"alaw":Er.test(r)?r:r==="webvtt"?"webvtt":null,Fs=r=>r==="avc"?{avc:{format:"avc"}}:r==="hevc"?{hevc:{format:"hevc"}}:{},Tt=r=>r==="aac"?{aac:{format:"aac"}}:r==="opus"?{opus:{format:"opus"}}:{};class he{constructor(e){this._factor=e}_toVideoBitrate(e,t,s){const i=t*s,n={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},a=1920*1080,o=3e6,d=Math.pow(i/a,.95),f=o*d*n[e]*this._factor;return Math.ceil(f/1e3)*1e3}_toAudioBitrate(e){if(G.includes(e)||e==="flac")return;const s={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!s)throw new Error(`Unhandled codec: ${e}`);let i=s*this._factor;return e==="aac"?i=[96e3,128e3,16e4,192e3].reduce((a,o)=>Math.abs(o-i)<Math.abs(a-i)?o:a):e==="opus"||e==="vorbis"?i=Math.max(6e3,i):e==="mp3"&&(i=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((a,o)=>Math.abs(o-i)<Math.abs(a-i)?o:a)),Math.round(i/1e3)*1e3}}const Bs=new he(2),As=new he(4),zs=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],Os=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,Us=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,Ms=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,Ds=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,Vs=r=>{if(!r)throw new TypeError("Video chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Video chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!zs.some(e=>r.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(r.decoderConfig.codedWidth)||r.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(r.decoderConfig.codedHeight)||r.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(r.decoderConfig.description!==void 0&&!it(r.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=r.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const t=Object.keys(qe);if(e.primaries!=null&&!t.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${t.join(", ")}.`);const s=Object.keys(Qe);if(e.transfer!=null&&!s.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${s.join(", ")}.`);const i=Object.keys(Ge);if(e.matrix!=null&&!i.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${i.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(r.decoderConfig.codec.startsWith("avc1")||r.decoderConfig.codec.startsWith("avc3")){if(!Os.test(r.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(r.decoderConfig.codec.startsWith("hev1")||r.decoderConfig.codec.startsWith("hvc1")){if(!Us.test(r.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(r.decoderConfig.codec.startsWith("vp8")){if(r.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(r.decoderConfig.codec.startsWith("vp09")){if(!Ms.test(r.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(r.decoderConfig.codec.startsWith("av01")&&!Ds.test(r.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Ns=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],Ws=r=>{if(!r)throw new TypeError("Audio chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Ns.some(e=>r.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(r.decoderConfig.sampleRate)||r.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(r.decoderConfig.numberOfChannels)||r.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(r.decoderConfig.description!==void 0&&!it(r.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.codec.startsWith("mp4a")&&r.decoderConfig.codec!=="mp4a.69"&&r.decoderConfig.codec!=="mp4a.6B"&&r.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(r.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!r.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(r.decoderConfig.codec.startsWith("mp3")||r.decoderConfig.codec.startsWith("mp4a")){if(r.decoderConfig.codec!=="mp3"&&r.decoderConfig.codec!=="mp4a.69"&&r.decoderConfig.codec!=="mp4a.6B"&&r.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(r.decoderConfig.codec.startsWith("opus")){if(r.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(r.decoderConfig.description&&r.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(r.decoderConfig.codec.startsWith("vorbis")){if(r.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!r.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(r.decoderConfig.codec.startsWith("flac")){if(r.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!r.decoderConfig.description||r.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((r.decoderConfig.codec.startsWith("pcm")||r.decoderConfig.codec.startsWith("ulaw")||r.decoderConfig.codec.startsWith("alaw"))&&!G.includes(r.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${G.join(", ")}).`)},Hs=r=>{if(!r)throw new TypeError("Subtitle metadata must be provided.");if(typeof r!="object")throw new TypeError("Subtitle metadata must be an object.");if(!r.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof r.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof r.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")},Ls=async(r,{numberOfChannels:e=2,sampleRate:t=48e3,bitrate:s=128e3}={})=>{if(!Se.includes(r))return!1;if(!Number.isInteger(e)||e<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(t)||t<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(s instanceof he)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer.");const i=s instanceof he?s._toAudioBitrate(r):s;if(kt.length>0){const a={codec:wt(r,e,t),numberOfChannels:e,sampleRate:t,bitrate:i,...Tt(r)};if(kt.some(o=>o.supports(r,a)))return!0}return G.includes(r)?!0:typeof AudioEncoder>"u"?!1:(await AudioEncoder.isConfigSupported({codec:wt(r,e,t),numberOfChannels:e,sampleRate:t,bitrate:i,...Tt(r)})).supported===!0},$s=async(r,e)=>{for(const t of r)if(await Ls(t,e))return t;return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Jt=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,Ks=r=>{const e=Math.floor(r/36e5),t=Math.floor(r%(60*60*1e3)/(60*1e3)),s=Math.floor(r%(60*1e3)/1e3),i=r%1e3;return e.toString().padStart(2,"0")+":"+t.toString().padStart(2,"0")+":"+s.toString().padStart(2,"0")+"."+i.toString().padStart(3,"0")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ke=r=>{const e=[];let t=0;for(;t<r.length;){let s=-1,i=0;for(let n=t;n<r.length-3;n++){if(r[n]===0&&r[n+1]===0&&r[n+2]===1){s=n,i=3;break}if(n<r.length-4&&r[n]===0&&r[n+1]===0&&r[n+2]===0&&r[n+3]===1){s=n,i=4;break}}if(s===-1)break;if(t>0&&s>t){const n=r.subarray(t,s);n.length>0&&e.push(n)}t=s+i}if(t<r.length){const s=r.subarray(t);s.length>0&&e.push(s)}return e},er=(r,e)=>{const t=[];let s=0;const i=new DataView(r.buffer,r.byteOffset,r.byteLength);for(;s+e<=r.length;){let n;e===1?n=i.getUint8(s):e===2?n=i.getUint16(s,!1):e===3?n=(i.getUint16(s,!1)<<8)+i.getUint8(s+2):e===4?n=i.getUint32(s,!1):($e(e),g(!1)),s+=e;const a=r.subarray(s,s+n);t.push(a),s+=n}return t},bt=r=>{const e=[],t=r.length;for(let s=0;s<t;s++)s+2<t&&r[s]===0&&r[s+1]===0&&r[s+2]===3?(e.push(0,0),s+=2):e.push(r[s]);return new Uint8Array(e)},js=r=>{const t=Ke(r);if(t.length===0)return null;let s=0;for(const o of t)s+=4+o.byteLength;const i=new Uint8Array(s),n=new DataView(i.buffer);let a=0;for(const o of t){const d=o.byteLength;n.setUint32(a,d,!1),a+=4,i.set(o,a),a+=o.byteLength}return i},tt=r=>r[0]&31,Fr=r=>{try{const e=Ke(r),t=e.filter(c=>tt(c)===7),s=e.filter(c=>tt(c)===8),i=e.filter(c=>tt(c)===13);if(t.length===0||s.length===0)return null;const n=t[0],a=new Z(bt(n));if(a.skipBits(1),a.skipBits(2),a.readBits(5)!==7)return console.error("Invalid SPS NAL unit type"),null;const d=a.readAlignedByte(),u=a.readAlignedByte(),l=a.readAlignedByte(),f={configurationVersion:1,avcProfileIndication:d,profileCompatibility:u,avcLevelIndication:l,lengthSizeMinusOne:3,sequenceParameterSets:t,pictureParameterSets:s,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(d===100||d===110||d===122||d===144){E(a);const c=E(a);c===3&&a.skipBits(1);const m=E(a),h=E(a);f.chromaFormat=c,f.bitDepthLumaMinus8=m,f.bitDepthChromaMinus8=h,f.sequenceParameterSetExt=i}return f}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},qs=r=>{const e=[];e.push(r.configurationVersion),e.push(r.avcProfileIndication),e.push(r.profileCompatibility),e.push(r.avcLevelIndication),e.push(252|r.lengthSizeMinusOne&3),e.push(224|r.sequenceParameterSets.length&31);for(const t of r.sequenceParameterSets){const s=t.byteLength;e.push(s>>8),e.push(s&255);for(let i=0;i<s;i++)e.push(t[i])}e.push(r.pictureParameterSets.length);for(const t of r.pictureParameterSets){const s=t.byteLength;e.push(s>>8),e.push(s&255);for(let i=0;i<s;i++)e.push(t[i])}if(r.avcProfileIndication===100||r.avcProfileIndication===110||r.avcProfileIndication===122||r.avcProfileIndication===144){g(r.chromaFormat!==null),g(r.bitDepthLumaMinus8!==null),g(r.bitDepthChromaMinus8!==null),g(r.sequenceParameterSetExt!==null),e.push(252|r.chromaFormat&3),e.push(248|r.bitDepthLumaMinus8&7),e.push(248|r.bitDepthChromaMinus8&7),e.push(r.sequenceParameterSetExt.length);for(const t of r.sequenceParameterSetExt){const s=t.byteLength;e.push(s>>8),e.push(s&255);for(let i=0;i<s;i++)e.push(t[i])}}return new Uint8Array(e)},tr=32,rr=33,sr=34,Qs=39,Gs=40,Te=r=>r[0]>>1&63,Br=r=>{try{const e=Ke(r),t=e.filter(_=>Te(_)===tr),s=e.filter(_=>Te(_)===rr),i=e.filter(_=>Te(_)===sr),n=e.filter(_=>Te(_)===Qs||Te(_)===Gs);if(s.length===0||i.length===0)return null;const a=s[0],o=new Z(bt(a));o.skipBits(16),o.readBits(4);const d=o.readBits(3),u=o.readBits(1),{general_profile_space:l,general_tier_flag:f,general_profile_idc:c,general_profile_compatibility_flags:m,general_constraint_indicator_flags:h,general_level_idc:p}=Xs(o,d);E(o);const k=E(o);k===3&&o.skipBits(1),E(o),E(o),o.readBits(1)&&(E(o),E(o),E(o),E(o));const w=E(o),T=E(o);E(o);const S=o.readBits(1)?0:d;for(let _=S;_<=d;_++)E(o),E(o),E(o);E(o),E(o),E(o),E(o),E(o),E(o),o.readBits(1)&&o.readBits(1)&&Ys(o),o.skipBits(1),o.skipBits(1),o.readBits(1)&&(o.skipBits(4),o.skipBits(4),E(o),E(o),o.skipBits(1));const b=E(o);if(Zs(o,b),o.readBits(1)){const _=E(o);for(let F=0;F<_;F++)E(o),o.skipBits(1)}o.skipBits(1),o.skipBits(1);let y=0;o.readBits(1)&&(y=ei(o,d));let C=0;if(i.length>0){const _=i[0],F=new Z(bt(_));F.skipBits(16),E(F),E(F),F.skipBits(1),F.skipBits(1),F.skipBits(3),F.skipBits(1),F.skipBits(1),E(F),E(F),He(F),F.skipBits(1),F.skipBits(1),F.readBits(1)&&E(F),He(F),He(F),F.skipBits(1),F.skipBits(1),F.skipBits(1),F.skipBits(1);const W=F.readBits(1),M=F.readBits(1);!W&&!M?C=0:W&&!M?C=2:!W&&M?C=3:C=0}const I=[...t.length?[{arrayCompleteness:1,nalUnitType:tr,nalUnits:t}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:rr,nalUnits:s}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:sr,nalUnits:i}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:Te(n[0]),nalUnits:n}]:[]];return{configurationVersion:1,generalProfileSpace:l,generalTierFlag:f,generalProfileIdc:c,generalProfileCompatibilityFlags:m,generalConstraintIndicatorFlags:h,generalLevelIdc:p,minSpatialSegmentationIdc:y,parallelismType:C,chromaFormatIdc:k,bitDepthLumaMinus8:w,bitDepthChromaMinus8:T,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:d+1,temporalIdNested:u,lengthSizeMinusOne:3,arrays:I}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Xs=(r,e)=>{const t=r.readBits(2),s=r.readBits(1),i=r.readBits(5);let n=0;for(let l=0;l<32;l++)n=n<<1|r.readBits(1);const a=new Uint8Array(6);for(let l=0;l<6;l++)a[l]=r.readBits(8);const o=r.readBits(8),d=[],u=[];for(let l=0;l<e;l++)d.push(r.readBits(1)),u.push(r.readBits(1));if(e>0)for(let l=e;l<8;l++)r.skipBits(2);for(let l=0;l<e;l++)d[l]&&r.skipBits(88),u[l]&&r.skipBits(8);return{general_profile_space:t,general_tier_flag:s,general_profile_idc:i,general_profile_compatibility_flags:n,general_constraint_indicator_flags:a,general_level_idc:o}},Ys=r=>{for(let e=0;e<4;e++)for(let t=0;t<(e===3?2:6);t++)if(!r.readBits(1))E(r);else{const i=Math.min(64,1<<4+(e<<1));e>1&&He(r);for(let n=0;n<i;n++)He(r)}},Zs=(r,e)=>{const t=[];for(let s=0;s<e;s++)t[s]=Js(r,s,e,t)},Js=(r,e,t,s)=>{let i=0,n=0,a=0;if(e!==0&&(n=r.readBits(1)),n){if(e===t){const d=E(r);a=e-(d+1)}else a=e-1;r.readBits(1),E(r);const o=s[a]??0;for(let d=0;d<=o;d++)r.readBits(1)||r.readBits(1);i=s[a]}else{const o=E(r),d=E(r);for(let u=0;u<o;u++)E(r),r.readBits(1);for(let u=0;u<d;u++)E(r),r.readBits(1);i=o+d}return i},ei=(r,e)=>{if(r.readBits(1)&&r.readBits(8)===255&&(r.readBits(16),r.readBits(16)),r.readBits(1)&&r.readBits(1),r.readBits(1)&&(r.readBits(3),r.readBits(1),r.readBits(1)&&(r.readBits(8),r.readBits(8),r.readBits(8))),r.readBits(1)&&(E(r),E(r)),r.readBits(1),r.readBits(1),r.readBits(1),r.readBits(1)&&(E(r),E(r),E(r),E(r)),r.readBits(1)&&(r.readBits(32),r.readBits(32),r.readBits(1)&&E(r),r.readBits(1)&&ti(r,!0,e)),r.readBits(1)){r.readBits(1),r.readBits(1),r.readBits(1);const t=E(r);return E(r),E(r),E(r),E(r),t}return 0},ti=(r,e,t)=>{let s=!1,i=!1,n=!1;s=r.readBits(1)===1,i=r.readBits(1)===1,(s||i)&&(n=r.readBits(1)===1,n&&(r.readBits(8),r.readBits(5),r.readBits(1),r.readBits(5)),r.readBits(4),r.readBits(4),n&&r.readBits(4),r.readBits(5),r.readBits(5),r.readBits(5));for(let a=0;a<=t;a++){const o=r.readBits(1)===1;let d=!0;o||(d=r.readBits(1)===1);let u=!1;d?E(r):u=r.readBits(1)===1;let l=1;u||(l=E(r)+1),s&&ir(r,l,n),i&&ir(r,l,n)}},ir=(r,e,t)=>{for(let s=0;s<e;s++)E(r),E(r),t&&(E(r),E(r)),r.readBits(1)},ri=r=>{const e=[];e.push(r.configurationVersion),e.push((r.generalProfileSpace&3)<<6|(r.generalTierFlag&1)<<5|r.generalProfileIdc&31),e.push(r.generalProfileCompatibilityFlags>>>24&255),e.push(r.generalProfileCompatibilityFlags>>>16&255),e.push(r.generalProfileCompatibilityFlags>>>8&255),e.push(r.generalProfileCompatibilityFlags&255),e.push(...r.generalConstraintIndicatorFlags),e.push(r.generalLevelIdc&255),e.push(240|r.minSpatialSegmentationIdc>>8&15),e.push(r.minSpatialSegmentationIdc&255),e.push(252|r.parallelismType&3),e.push(252|r.chromaFormatIdc&3),e.push(248|r.bitDepthLumaMinus8&7),e.push(248|r.bitDepthChromaMinus8&7),e.push(r.avgFrameRate>>8&255),e.push(r.avgFrameRate&255),e.push((r.constantFrameRate&3)<<6|(r.numTemporalLayers&7)<<3|(r.temporalIdNested&1)<<2|r.lengthSizeMinusOne&3),e.push(r.arrays.length&255);for(const t of r.arrays){e.push((t.arrayCompleteness&1)<<7|0|t.nalUnitType&63),e.push(t.nalUnits.length>>8&255),e.push(t.nalUnits.length&255);for(const s of t.nalUnits){e.push(s.length>>8&255),e.push(s.length&255);for(let i=0;i<s.length;i++)e.push(s[i])}}return new Uint8Array(e)},Ar=r=>{const e=new Z(r);if(e.readBits(2)!==2)return null;const s=e.readBits(1),n=(e.readBits(1)<<1)+s;if(n===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let u=8;n>=2&&(u=e.readBits(1)?12:10);const l=e.readBits(3);let f=0,c=0;if(l!==7)if(c=e.readBits(1),n===1||n===3){const C=e.readBits(1),I=e.readBits(1);f=!C&&!I?3:C&&!I?2:1,e.skipBits(1)}else f=1;else f=3,c=1;const m=e.readBits(16),h=e.readBits(16),p=m+1,k=h+1,w=p*k;let T=K(me).level;for(const y of me)if(w<=y.maxPictureSize){T=y.level;break}return{profile:n,level:T,bitDepth:u,chromaSubsampling:f,videoFullRangeFlag:c,colourPrimaries:l===2?1:l===1?6:2,transferCharacteristics:l===2?1:l===1?6:2,matrixCoefficients:l===7?0:l===2?1:l===1?6:2}};function*zr(r){const e=new Z(r),t=()=>{let s=0;for(let i=0;i<8;i++){const n=e.readAlignedByte();if(s|=(n&127)<<i*7,!(n&128))break;if(i===7&&n&128)return null}return s>=2**32-1?null:s};for(;e.getBitsLeft()>=8;){e.skipBits(1);const s=e.readBits(4),i=e.readBits(1),n=e.readBits(1);e.skipBits(1),i&&e.skipBits(8);let a;if(n){const o=t();if(o===null)return;a=o}else a=Math.floor(e.getBitsLeft()/8);g(e.pos%8===0),yield{type:s,data:r.subarray(e.pos/8,e.pos/8+a)},e.skipBits(a*8)}}const Or=r=>{for(const{type:e,data:t}of zr(r)){if(e!==1)continue;const s=new Z(t),i=s.readBits(3);s.readBits(1);const n=s.readBits(1);let a=0,o=0,d=0;if(n)a=s.readBits(5);else{if(s.readBits(1)&&(s.skipBits(32),s.skipBits(32),s.readBits(1)))return null;const k=s.readBits(1);k&&(d=s.readBits(5),s.skipBits(32),s.skipBits(5),s.skipBits(5));const w=s.readBits(5);for(let T=0;T<=w;T++){s.skipBits(12);const x=s.readBits(5);if(T===0&&(a=x),x>7){const b=s.readBits(1);T===0&&(o=b)}if(k&&s.readBits(1)){const y=d+1;s.skipBits(y),s.skipBits(y),s.skipBits(1)}s.readBits(1)&&s.skipBits(4)}}const u=s.readBits(1);let l=8;i===2&&u?l=s.readBits(1)?12:10:i<=2&&(l=u?10:8);let f=0;i!==1&&(f=s.readBits(1));let c=1,m=1,h=0;return f||(i===0?(c=1,m=1):i===1?(c=0,m=0):l===12&&(c=s.readBits(1),c&&(m=s.readBits(1))),c&&m&&(h=s.readBits(2))),{profile:i,level:a,tier:o,bitDepth:l,monochrome:f,chromaSubsamplingX:c,chromaSubsamplingY:m,chromaSamplePosition:h}}return null},Ur=r=>{const e=Ue(r),t=e.getUint8(9),s=e.getUint16(10,!0),i=e.getUint32(12,!0),n=e.getInt16(16,!0),a=e.getUint8(18);let o=null;return a&&(o=r.subarray(19,21+t)),{outputChannelCount:t,preSkip:s,inputSampleRate:i,outputGain:n,channelMappingFamily:a,channelMappingTable:o}},si=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],ii=r=>{const e=r[0]>>3;return{durationInSamples:si[e]}},ni=r=>{if(r.length<7)throw new Error("Setup header is too short.");if(r[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...r.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const t=r.length,s=new Uint8Array(t);for(let f=0;f<t;f++)s[f]=r[t-1-f];const i=new Z(s);let n=0;for(;i.getBitsLeft()>97;)if(i.readBits(1)===1){n=i.pos;break}if(n===0)throw new Error("Invalid Setup header: framing bit not found.");let a=0,o=!1,d=0;for(;i.getBitsLeft()>=97;){const f=i.pos,c=i.readBits(8),m=i.readBits(16),h=i.readBits(16);if(c>63||m!==0||h!==0){i.pos=f;break}if(i.skipBits(1),a++,a>64)break;i.clone().readBits(6)+1===a&&(o=!0,d=a)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(d>63)throw new Error(`Unsupported mode count: ${d}.`);const u=d;i.pos=0,i.skipBits(n);const l=Array(u).fill(0);for(let f=u-1;f>=0;f--)i.skipBits(40),l[f]=i.readBits(1);return{modeBlockflags:l}},ai=async(r,e)=>{switch(g(r.codec),r.codec){case"avc":{const t=await r.getDecoderConfig();g(t);let s;if(t.description){const o=(te(t.description)[4]&3)+1;s=er(e.data,o)}else s=Ke(e.data);return s.some(n=>tt(n)===5)?"key":"delta"}case"hevc":{const t=await r.getDecoderConfig();g(t);let s;if(t.description){const o=(te(t.description)[21]&3)+1;s=er(e.data,o)}else s=Ke(e.data);return s.some(n=>{const a=Te(n);return 16<=a&&a<=23})?"key":"delta"}case"vp8":return(e.data[0]&1)===0?"key":"delta";case"vp9":{const t=new Z(e.data);if(t.readBits(2)!==2)return null;const s=t.readBits(1);return(t.readBits(1)<<1)+s===3&&t.skipBits(1),t.readBits(1)?null:t.readBits(1)===0?"key":"delta"}case"av1":{let t=!1;for(const{type:s,data:i}of zr(e.data))if(s===1){const n=new Z(i);n.skipBits(4),t=!!n.readBits(1)}else if(s===3||s===6||s===7){if(t)return"key";const n=new Z(i);return n.readBits(1)?null:n.readBits(2)===0?"key":"delta"}return null}default:$e(r.codec),g(!1)}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class nr{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const n of e.children)n&&this.writeBox(n);const s=this.writer.getPos(),i=e.size??s-t;this.writer.seek(t),this.writeBoxHeader(e,i),this.writer.seek(s)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const t=this.offsets.get(e);g(t!==void 0);const s=this.writer.getPos();this.writer.seek(t),this.writeBox(e),this.writer.seek(s)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(const s of e.children)s&&(t+=this.measureBox(s));return t}}}const O=new Uint8Array(8),re=new DataView(O.buffer),V=r=>[(r%256+256)%256],B=r=>(re.setUint16(0,r,!1),[O[0],O[1]]),Mr=r=>(re.setInt16(0,r,!1),[O[0],O[1]]),Dr=r=>(re.setUint32(0,r,!1),[O[1],O[2],O[3]]),v=r=>(re.setUint32(0,r,!1),[O[0],O[1],O[2],O[3]]),le=r=>(re.setInt32(0,r,!1),[O[0],O[1],O[2],O[3]]),xe=r=>(re.setUint32(0,Math.floor(r/2**32),!1),re.setUint32(4,r,!1),[O[0],O[1],O[2],O[3],O[4],O[5],O[6],O[7]]),Vr=r=>(re.setInt16(0,2**8*r,!1),[O[0],O[1]]),ae=r=>(re.setInt32(0,2**16*r,!1),[O[0],O[1],O[2],O[3]]),ot=r=>(re.setInt32(0,2**30*r,!1),[O[0],O[1],O[2],O[3]]),ct=(r,e)=>{const t=[];let s=r;do{let i=s&127;s>>=7,t.length>0&&(i|=128),t.push(i)}while(s>0||e);return t.reverse()},Q=(r,e=!1)=>{const t=Array(r.length).fill(null).map((s,i)=>r.charCodeAt(i));return e&&t.push(0),t},Bt=r=>{let e=null;for(const t of r)(!e||t.timestamp>e.timestamp)&&(e=t);return e},Nr=r=>{const e=r*(Math.PI/180),t=Math.round(Math.cos(e)),s=Math.round(Math.sin(e));return[t,s,0,-s,t,0,0,0,1]},Wr=Nr(0),Hr=r=>[ae(r[0]),ae(r[1]),ot(r[2]),ae(r[3]),ae(r[4]),ot(r[5]),ae(r[6]),ae(r[7]),ot(r[8])],z=(r,e,t)=>({type:r,contents:e&&new Uint8Array(e.flat(10)),children:t}),U=(r,e,t,s,i)=>z(r,[V(e),Dr(t),s??[]],i),oi=r=>r.isQuickTime?z("ftyp",[Q("qt  "),v(512),Q("qt  ")]):r.fragmented?z("ftyp",[Q("iso5"),v(512),Q("iso5"),Q("iso6"),Q("mp41")]):z("ftyp",[Q("isom"),v(512),Q("isom"),r.holdsAvc?Q("avc1"):[],Q("mp41")]),dt=r=>({type:"mdat",largeSize:r}),Je=(r,e,t=!1)=>z("moov",void 0,[ci(e,r),...r.map(s=>di(s,e)),t?Ki(r):null]),ci=(r,e)=>{const t=L(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{const o=Bt(a.samples);return o.timestamp+o.duration})),St),s=Math.max(0,...e.map(a=>a.track.id))+1,i=!Oe(r)||!Oe(t),n=i?xe:v;return U("mvhd",+i,0,[n(r),n(r),v(St),n(t),ae(1),Vr(1),Array(10).fill(0),Hr(Wr),Array(24).fill(0),v(s)])},di=(r,e)=>z("trak",void 0,[li(r,e),ui(r,e)]),li=(r,e)=>{const t=Bt(r.samples),s=L(t?t.timestamp+t.duration:0,St),i=!Oe(e)||!Oe(s),n=i?xe:v;let a;if(r.type==="video"){const o=r.track.metadata.rotation;a=Nr(o??0)}else a=Wr;return U("tkhd",+i,3,[n(e),n(e),v(r.track.id),v(0),n(s),Array(8).fill(0),B(0),B(r.track.id),Vr(r.type==="audio"?1:0),B(0),Hr(a),ae(r.type==="video"?r.info.width:0),ae(r.type==="video"?r.info.height:0)])},ui=(r,e)=>z("mdia",void 0,[mi(r,e),pi(r),gi(r)]),mi=(r,e)=>{const t=Bt(r.samples),s=L(t?t.timestamp+t.duration:0,r.timescale),i=!Oe(e)||!Oe(s),n=i?xe:v;let a=0;for(const o of r.track.metadata.languageCode??fe)a<<=5,a+=o.charCodeAt(0)-96;return U("mdhd",+i,0,[n(e),n(e),v(r.timescale),n(s),B(a),B(0)])},fi={video:"vide",audio:"soun",subtitle:"text"},hi={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},pi=r=>U("hdlr",0,0,[Q("mhlr"),Q(fi[r.type]),v(0),v(0),v(0),Q(hi[r.type],!0)]),gi=r=>z("minf",void 0,[bi[r.type](),yi(),Ci(r)]),ki=()=>U("vmhd",0,1,[B(0),B(0),B(0),B(0)]),wi=()=>U("smhd",0,0,[B(0),B(0)]),Ti=()=>U("nmhd",0,0),bi={video:ki,audio:wi,subtitle:Ti},yi=()=>z("dinf",void 0,[Si()]),Si=()=>U("dref",0,0,[v(1)],[xi()]),xi=()=>U("url ",0,1),Ci=r=>{const e=r.compositionTimeOffsetTable.length>1||r.compositionTimeOffsetTable.some(t=>t.sampleCompositionTimeOffset!==0);return z("stbl",void 0,[Pi(r),Di(r),e?Li(r):null,e?$i(r):null,Ni(r),Wi(r),Hi(r),Vi(r)])},Pi=r=>{let e;if(r.type==="video")e=vi(nn[r.track.source._codec],r);else if(r.type==="audio"){const t=$r(r.track.source._codec,r.muxer.isQuickTime);g(t),e=Fi(t,r)}else r.type==="subtitle"&&(e=Ui(cn[r.track.source._codec],r));return g(e),U("stsd",0,0,[v(1)],[e])},vi=(r,e)=>z(r,[Array(6).fill(0),B(1),B(0),B(0),Array(12).fill(0),B(e.info.width),B(e.info.height),v(4718592),v(4718592),v(0),B(1),Array(32).fill(0),B(24),Mr(65535)],[an[e.track.source._codec](e),gs(e.info.decoderConfig.colorSpace)?_i(e):null]),_i=r=>z("colr",[Q("nclx"),B(qe[r.info.decoderConfig.colorSpace.primaries]),B(Qe[r.info.decoderConfig.colorSpace.transfer]),B(Ge[r.info.decoderConfig.colorSpace.matrix]),V((r.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Ii=r=>r.info.decoderConfig&&z("avcC",[...te(r.info.decoderConfig.description)]),Ei=r=>r.info.decoderConfig&&z("hvcC",[...te(r.info.decoderConfig.description)]),ar=r=>{var c,m,h,p;if(!r.info.decoderConfig)return null;const e=r.info.decoderConfig,t=e.codec.split("."),s=Number(t[1]),i=Number(t[2]),n=Number(t[3]),a=t[4]?Number(t[4]):1,o=t[8]?Number(t[8]):Number(((c=e.colorSpace)==null?void 0:c.fullRange)??0),d=(n<<4)+(a<<1)+o,u=t[5]?Number(t[5]):(m=e.colorSpace)!=null&&m.primaries?qe[e.colorSpace.primaries]:2,l=t[6]?Number(t[6]):(h=e.colorSpace)!=null&&h.transfer?Qe[e.colorSpace.transfer]:2,f=t[7]?Number(t[7]):(p=e.colorSpace)!=null&&p.matrix?Ge[e.colorSpace.matrix]:2;return U("vpcC",1,0,[V(s),V(i),V(d),V(u),V(l),V(f),B(0)])},Ri=r=>z("av1C",Es(r.info.decoderConfig.codec)),Fi=(r,e)=>{var n;let t=0,s,i=16;if(G.includes(e.track.source._codec)){const a=e.track.source._codec,{sampleSize:o}=pe(a);i=8*o,i>16&&(t=1)}return t===0?s=[Array(6).fill(0),B(1),B(t),B(0),v(0),B(e.info.numberOfChannels),B(i),B(0),B(0),B(e.info.sampleRate<2**16?e.info.sampleRate:0),B(0)]:s=[Array(6).fill(0),B(1),B(t),B(0),v(0),B(e.info.numberOfChannels),B(Math.min(i,16)),B(0),B(0),B(e.info.sampleRate<2**16?e.info.sampleRate:0),B(0),v(1),v(i/8),v(e.info.numberOfChannels*i/8),v(2)],z(r,s,[((n=on(e.track.source._codec,e.muxer.isQuickTime))==null?void 0:n(e))??null])},lt=r=>{let e;switch(r.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${r.track.source._codec}`)}let t=[...V(e),...V(21),...Dr(0),...v(0),...v(0)];if(r.info.decoderConfig.description){const s=te(r.info.decoderConfig.description);t=[...t,...V(5),...ct(s.byteLength),...s]}return t=[...B(1),...V(0),...V(4),...ct(t.length),...t,...V(6),...V(1),...V(2)],t=[...V(3),...ct(t.length),...t],U("esds",0,0,t)},de=r=>z("wave",void 0,[Bi(r),Ai(r),z("\0\0\0\0")]),Bi=r=>z("frma",[Q($r(r.track.source._codec,r.muxer.isQuickTime))]),Ai=r=>{const{littleEndian:e}=pe(r.track.source._codec);return z("enda",[B(+e)])},zi=r=>{var d;let e=r.info.numberOfChannels,t=3840,s=r.info.sampleRate,i=0,n=0,a=new Uint8Array(0);const o=(d=r.info.decoderConfig)==null?void 0:d.description;if(o){g(o.byteLength>=18);const u=te(o),l=Ur(u);e=l.outputChannelCount,t=l.preSkip,s=l.inputSampleRate,i=l.outputGain,n=l.channelMappingFamily,l.channelMappingTable&&(a=l.channelMappingTable)}return z("dOps",[V(0),V(e),B(t),v(s),Mr(i),V(n),...a])},Oi=r=>{var s;const e=(s=r.info.decoderConfig)==null?void 0:s.description;g(e);const t=te(e);return U("dfLa",0,0,[...t.subarray(4)])},J=r=>{const{littleEndian:e,sampleSize:t}=pe(r.track.source._codec),s=+e;return U("pcmC",0,0,[V(s),V(8*t)])},Ui=(r,e)=>z(r,[Array(6).fill(0),B(1)],[dn[e.track.source._codec](e)]),Mi=r=>z("vttC",[...Ee.encode(r.info.config.description)]),Di=r=>U("stts",0,0,[v(r.timeToSampleTable.length),r.timeToSampleTable.map(e=>[v(e.sampleCount),v(e.sampleDelta)])]),Vi=r=>{if(r.samples.every(t=>t.type==="key"))return null;const e=[...r.samples.entries()].filter(([,t])=>t.type==="key");return U("stss",0,0,[v(e.length),e.map(([t])=>v(t+1))])},Ni=r=>U("stsc",0,0,[v(r.compactlyCodedChunkTable.length),r.compactlyCodedChunkTable.map(e=>[v(e.firstChunk),v(e.samplesPerChunk),v(1)])]),Wi=r=>{if(r.type==="audio"&&r.info.requiresPcmTransformation){const{sampleSize:e}=pe(r.track.source._codec);return U("stsz",0,0,[v(e*r.info.numberOfChannels),v(r.samples.reduce((t,s)=>t+L(s.duration,r.timescale),0))])}return U("stsz",0,0,[v(0),v(r.samples.length),r.samples.map(e=>v(e.size))])},Hi=r=>r.finalizedChunks.length>0&&K(r.finalizedChunks).offset>=2**32?U("co64",0,0,[v(r.finalizedChunks.length),r.finalizedChunks.map(e=>xe(e.offset))]):U("stco",0,0,[v(r.finalizedChunks.length),r.finalizedChunks.map(e=>v(e.offset))]),Li=r=>U("ctts",1,0,[v(r.compositionTimeOffsetTable.length),r.compositionTimeOffsetTable.map(e=>[v(e.sampleCount),le(e.sampleCompositionTimeOffset)])]),$i=r=>{let e=1/0,t=-1/0,s=1/0,i=-1/0;g(r.compositionTimeOffsetTable.length>0),g(r.samples.length>0);for(let a=0;a<r.compositionTimeOffsetTable.length;a++){const o=r.compositionTimeOffsetTable[a];e=Math.min(e,o.sampleCompositionTimeOffset),t=Math.max(t,o.sampleCompositionTimeOffset)}for(let a=0;a<r.samples.length;a++){const o=r.samples[a];s=Math.min(s,L(o.timestamp,r.timescale)),i=Math.max(i,L(o.timestamp+o.duration,r.timescale))}const n=Math.max(-e,0);return i>=2**31?null:U("cslg",0,0,[le(n),le(e),le(t),le(s),le(i)])},Ki=r=>z("mvex",void 0,r.map(ji)),ji=r=>U("trex",0,0,[v(r.track.id),v(1),v(0),v(0),v(0)]),or=(r,e)=>z("moof",void 0,[qi(r),...e.map(Qi)]),qi=r=>U("mfhd",0,0,[v(r)]),Lr=r=>{let e=0,t=0;const s=0,i=0,n=r.type==="delta";return t|=+n,n?e|=1:e|=2,e<<24|t<<16|s<<8|i},Qi=r=>z("traf",void 0,[Gi(r),Xi(r),Yi(r)]),Gi=r=>{g(r.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const t=r.currentChunk.samples[1]??r.currentChunk.samples[0],s={duration:t.timescaleUnitsToNextSample,size:t.size,flags:Lr(t)};return U("tfhd",0,e,[v(r.track.id),v(s.duration),v(s.size),v(s.flags)])},Xi=r=>(g(r.currentChunk),U("tfdt",1,0,[xe(L(r.currentChunk.startTimestamp,r.timescale))])),Yi=r=>{g(r.currentChunk);const e=r.currentChunk.samples.map(p=>p.timescaleUnitsToNextSample),t=r.currentChunk.samples.map(p=>p.size),s=r.currentChunk.samples.map(Lr),i=r.currentChunk.samples.map(p=>L(p.timestamp-p.decodeTimestamp,r.timescale)),n=new Set(e),a=new Set(t),o=new Set(s),d=new Set(i),u=o.size===2&&s[0]!==s[1],l=n.size>1,f=a.size>1,c=!u&&o.size>1,m=d.size>1||[...d].some(p=>p!==0);let h=0;return h|=1,h|=4*+u,h|=256*+l,h|=512*+f,h|=1024*+c,h|=2048*+m,U("trun",1,h,[v(r.currentChunk.samples.length),v(r.currentChunk.offset-r.currentChunk.moofOffset||0),u?v(s[0]):[],r.currentChunk.samples.map((p,k)=>[l?v(e[k]):[],f?v(t[k]):[],c?v(s[k]):[],m?le(i[k]):[]])])},Zi=r=>z("mfra",void 0,[...r.map(Ji),en()]),Ji=(r,e)=>U("tfra",1,0,[v(r.track.id),v(63),v(r.finalizedChunks.length),r.finalizedChunks.map(s=>[xe(L(s.samples[0].timestamp,r.timescale)),xe(s.moofOffset),v(e+1),v(1),v(1)])]),en=()=>U("mfro",0,0,[v(0)]),tn=()=>z("vtte"),rn=(r,e,t,s,i)=>z("vttc",void 0,[i!==null?z("vsid",[le(i)]):null,t!==null?z("iden",[...Ee.encode(t)]):null,e!==null?z("ctim",[...Ee.encode(Ks(e))]):null,s!==null?z("sttg",[...Ee.encode(s)]):null,z("payl",[...Ee.encode(r)])]),sn=r=>z("vtta",[...Ee.encode(r)]),nn={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},an={avc:Ii,hevc:Ei,vp8:ar,vp9:ar,av1:Ri},$r=(r,e)=>{switch(r){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(r){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(r){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},on=(r,e)=>{switch(r){case"aac":return lt;case"mp3":return lt;case"opus":return zi;case"vorbis":return lt;case"flac":return Oi}if(e)switch(r){case"pcm-s24":return de;case"pcm-s24be":return de;case"pcm-s32":return de;case"pcm-s32be":return de;case"pcm-f32":return de;case"pcm-f32be":return de;case"pcm-f64":return de;case"pcm-f64be":return de}else switch(r){case"pcm-s16":return J;case"pcm-s16be":return J;case"pcm-s24":return J;case"pcm-s24be":return J;case"pcm-s32":return J;case"pcm-s32be":return J;case"pcm-f32":return J;case"pcm-f32be":return J;case"pcm-f64":return J;case"pcm-f64be":return J}return null},cn={webvtt:"wvtt"},dn={webvtt:Mi};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ln{constructor(e){this.mutex=new Me,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,t,s){t+=e.source._timestampOffset;let i=this.trackTimestampInfo.get(e);if(!i){if(!s)throw new Error("First frame must be a key frame.");i={maxTimestamp:t,maxTimestampBeforeLastKeyFrame:t},this.trackTimestampInfo.set(e,i)}if(t<0)throw new Error(`Timestamps must be non-negative (got ${t}s).`);if(s&&(i.maxTimestampBeforeLastKeyFrame=i.maxTimestamp),t<i.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a key frame and ends right before the next key frame). Got ${t}s, but highest timestamp is ${i.maxTimestampBeforeLastKeyFrame}s.`);return i.maxTimestamp=Math.max(i.maxTimestamp,t),t}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Kr{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let t=this.getPos();if(t<this.trackedStart){if(t+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-t),t=0}const s=t+e.byteLength-this.trackedStart;let i=this.trackedWrites.byteLength;for(;i<s;)i*=2;if(i!==this.trackedWrites.byteLength){const n=new Uint8Array(i);n.set(this.trackedWrites,0),this.trackedWrites=n}this.trackedWrites.set(e,t-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,t+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const t={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,t}}const ut=2**16,mt=2**32;class jr extends Kr{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(ut,{maxByteLength:mt})}catch{this.buffer=new ArrayBuffer(ut),this.supportsResize=!1}else this.buffer=new ArrayBuffer(ut);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t!==this.buffer.byteLength){if(t>mt)throw new Error(`ArrayBuffer exceeded maximum size of ${mt} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(t);else{const s=new ArrayBuffer(t),i=new Uint8Array(s);i.set(this.bytes,0),this.buffer=s,this.bytes=i}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,t){return this.bytes.slice(e,t)}}const un=2**24,mn=2;class fn extends Kr{constructor(e){super(),this.pos=0,this.sections=[],this.lastWriteEnd=0,this.lastFlushEnd=0,this.writer=null,this.chunks=[],this.target=e,this.chunked=e._options.chunked??!1,this.chunkSize=e._options.chunkSize??un}start(){this.writer=this.target._writable.getWriter()}write(e){if(this.pos>this.lastWriteEnd){const t=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(t))}this.maybeTrackWrites(e),this.sections.push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength,this.lastWriteEnd=Math.max(this.lastWriteEnd,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(this.pos>this.lastWriteEnd){const s=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(s))}if(g(this.writer),this.sections.length===0)return;const e=[],t=[...this.sections].sort((s,i)=>s.start-i.start);e.push({start:t[0].start,size:t[0].data.byteLength});for(let s=1;s<t.length;s++){const i=e[e.length-1],n=t[s];n.start<=i.start+i.size?i.size=Math.max(i.size,n.start+n.data.byteLength-i.start):e.push({start:n.start,size:n.data.byteLength})}for(const s of e){s.data=new Uint8Array(s.size);for(const i of this.sections)s.start<=i.start&&i.start<s.start+s.size&&s.data.set(i.data,i.start-s.start);if(this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.chunked)this.writeDataIntoChunks(s.data,s.start),this.tryToFlushChunks();else{if(this.ensureMonotonicity&&s.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:s.data,position:s.start}),this.lastFlushEnd=s.start+s.data.byteLength}}this.sections.length=0}writeDataIntoChunks(e,t){let s=this.chunks.findIndex(d=>d.start<=t&&t<d.start+this.chunkSize);s===-1&&(s=this.createChunk(t));const i=this.chunks[s],n=t-i.start,a=e.subarray(0,Math.min(this.chunkSize-n,e.byteLength));i.data.set(a,n);const o={start:n,end:n+a.byteLength};if(this.insertSectionIntoChunk(i,o),i.written[0].start===0&&i.written[0].end===this.chunkSize&&(i.shouldFlush=!0),this.chunks.length>mn){for(let d=0;d<this.chunks.length-1;d++)this.chunks[d].shouldFlush=!0;this.tryToFlushChunks()}a.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(a.byteLength),t+a.byteLength)}insertSectionIntoChunk(e,t){let s=0,i=e.written.length-1,n=-1;for(;s<=i;){const a=Math.floor(s+(i-s+1)/2);e.written[a].start<=t.start?(s=a+1,n=a):i=a-1}for(e.written.splice(n+1,0,t),(n===-1||e.written[n].end<t.start)&&n++;n<e.written.length-1&&e.written[n].end>=e.written[n+1].start;)e.written[n].end=Math.max(e.written[n].end,e.written[n+1].end),e.written.splice(n+1,1)}createChunk(e){const s={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(s),this.chunks.sort((i,n)=>i.start-n.start),this.chunks.indexOf(s)}tryToFlushChunks(e=!1){g(this.writer);for(let t=0;t<this.chunks.length;t++){const s=this.chunks[t];if(!(!s.shouldFlush&&!e)){for(const i of s.written){const n=s.start+i.start;if(this.ensureMonotonicity&&n!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:s.data.subarray(i.start,i.end),position:n}),this.lastFlushEnd=s.start+i.end}this.chunks.splice(t--,1)}}}finalize(){return this.chunked&&this.tryToFlushChunks(!0),g(this.writer),this.writer.close()}async close(){var e;return(e=this.writer)==null?void 0:e.close()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class At{constructor(){this._output=null}}class hn extends At{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new jr(this)}}class pn extends At{constructor(e,t={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(t!=null&&typeof t!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(t.chunked!==void 0&&typeof t.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(t.chunkSize!==void 0&&(!Number.isInteger(t.chunkSize)||t.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an integer and not smaller than 1024.");this._writable=e,this._options=t}_createWriter(){return new fn(this)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const qr=r=>{let t=(r.hasVideo?"video/":r.hasAudio?"audio/":"application/")+(r.isQuickTime?"quicktime":"mp4");if(r.codecStrings.length>0){const s=[...new Set(r.codecStrings)];t+=`; codecs="${s.join(", ")}"`}return t};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const rt=8,Be=16;class yt{constructor(e){this.reader=e,this.pos=0}readBytes(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);return this.pos+=e,new Uint8Array(t.buffer,s,e)}readU8(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1);return this.pos++,e.getUint8(t)}readU16(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getUint16(t,!1)}readI16(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getInt16(t,!1)}readU24(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+3);this.pos+=3;const s=e.getUint16(t,!1),i=e.getUint8(t+2);return s*256+i}readU32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,!1)}readI32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!1)}readU64(){const e=this.readU32(),t=this.readU32();return e*4294967296+t}readI64(){const e=this.readI32(),t=this.readU32();return e*4294967296+t}readF64(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+8);return this.pos+=8,e.getFloat64(t,!1)}readFixed_16_16(){return this.readI32()/65536}readFixed_2_30(){return this.readI32()/1073741824}readAscii(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i="";for(let n=0;n<e;n++)i+=String.fromCharCode(t.getUint8(s+n));return i}readIsomVariableInteger(){let e=0;for(let t=0;t<4;t++){e<<=7;const s=this.readU8();if(e|=s&127,(s&128)===0)break}return e}readBoxHeader(){let e=this.readU32();const t=this.readAscii(4);let s=8;return e===1&&(e=this.readU64(),s=16),{name:t,totalSize:e,headerSize:s,contentSize:e-s}}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const St=1e3,gn=2082844800,L=(r,e,t=!0)=>{const s=r*e;return t?Math.round(s):s};class kn extends ln{constructor(e,t){super(e),this.auxTarget=new hn,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new nr(this.auxWriter),this.mdat=null,this.trackDatas=[],this.allTracksKnown=Y(),this.creationTime=Math.floor(Date.now()/1e3)+gn,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=t,this.writer=e._writer,this.boxWriter=new nr(this.writer),this.isQuickTime=t instanceof rs;const s=this.writer instanceof jr?"in-memory":!1;this.fastStart=t._options.fastStart??s,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=t._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),t=this.output._tracks.some(s=>s.type==="video"&&s.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(oi({isQuickTime:this.isQuickTime,holdsAvc:t,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:s,start:i}=this.writer.stopTrackingWrites();this.format._options.onFtyp(s,i)}this.fastStart==="in-memory"?this.mdat=dt(!1):this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=dt(!0),this.boxWriter.writeBox(this.mdat)),await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(t=>t.type==="video"||t.type==="audio"?t.info.decoderConfig.codec:{webvtt:"wvtt"}[t.track.source._codec]);return qr({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(t=>t.type==="video"),hasAudio:this.trackDatas.some(t=>t.type==="audio"),codecStrings:e})}getVideoTrackData(e,t,s){const i=this.trackDatas.find(u=>u.track===e);if(i)return i;Vs(s),g(s),g(s.decoderConfig);const n={...s.decoderConfig};g(n.codedWidth!==void 0),g(n.codedHeight!==void 0);let a=!1;if(e.source._codec==="avc"&&!n.description){const u=Fr(t.data);if(!u)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");n.description=qs(u),a=!0}else if(e.source._codec==="hevc"&&!n.description){const u=Br(t.data);if(!u)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");n.description=ri(u),a=!0}const o=Ps(1/(e.metadata.frameRate??57600),1e6).denominator,d={muxer:this,track:e,type:"video",info:{width:n.codedWidth,height:n.codedHeight,decoderConfig:n,requiresAnnexBTransformation:a},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(d),this.trackDatas.sort((u,l)=>u.track.id-l.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),d}getAudioTrackData(e,t){const s=this.trackDatas.find(n=>n.track===e);if(s)return s;Ws(t),g(t),g(t.decoderConfig);const i={muxer:this,track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig,requiresPcmTransformation:!this.isFragmented&&G.includes(e.source._codec)},timescale:t.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}getSubtitleTrackData(e,t){const s=this.trackDatas.find(n=>n.track===e);if(s)return s;Hs(t),g(t),g(t.config);const i={muxer:this,track:e,type:"subtitle",info:{config:t.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(i),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),i}async addEncodedVideoPacket(e,t,s){const i=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,t,s);let a=t.data;if(n.info.requiresAnnexBTransformation){const u=js(a);if(!u)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");a=u}const o=this.validateAndNormalizeTimestamp(n.track,t.timestamp,t.type==="key"),d=this.createSampleForTrack(n,a,o,t.duration,t.type);await this.registerSample(n,d)}finally{i()}}async addEncodedAudioPacket(e,t,s){const i=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,s),a=this.validateAndNormalizeTimestamp(n.track,t.timestamp,t.type==="key"),o=this.createSampleForTrack(n,t.data,a,t.duration,t.type);n.info.requiresPcmTransformation&&await this.maybePadWithSilence(n,a),await this.registerSample(n,o)}finally{i()}}async maybePadWithSilence(e,t){const s=K(e.samples),i=s?s.timestamp+s.duration:0,n=t-i,a=L(n,e.timescale);if(a>0){const{sampleSize:o,silentValue:d}=pe(e.info.decoderConfig.codec),u=a*e.info.numberOfChannels,l=new Uint8Array(o*u).fill(d),f=this.createSampleForTrack(e,new Uint8Array(l.buffer),i,n,"key");await this.registerSample(e,f)}}async addSubtitleCue(e,t,s){const i=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,s);this.validateAndNormalizeTimestamp(n.track,t.timestamp,!0),e.source._codec==="webvtt"&&(n.cueQueue.push(t),await this.processWebVTTCues(n,t.timestamp))}finally{i()}}async processWebVTTCues(e,t){for(;e.cueQueue.length>0;){const s=new Set([]);for(const u of e.cueQueue)g(u.timestamp<=t),g(e.lastCueEndTimestamp<=u.timestamp+u.duration),s.add(Math.max(u.timestamp,e.lastCueEndTimestamp)),s.add(u.timestamp+u.duration);const i=[...s].sort((u,l)=>u-l),n=i[0],a=i[1]??n;if(t<a)break;if(e.lastCueEndTimestamp<n){this.auxWriter.seek(0);const u=tn();this.auxBoxWriter.writeBox(u);const l=this.auxWriter.getSlice(0,this.auxWriter.getPos()),f=this.createSampleForTrack(e,l,e.lastCueEndTimestamp,n-e.lastCueEndTimestamp,"key");await this.registerSample(e,f),e.lastCueEndTimestamp=n}this.auxWriter.seek(0);for(let u=0;u<e.cueQueue.length;u++){const l=e.cueQueue[u];if(l.timestamp>=a)break;Jt.lastIndex=0;const f=Jt.test(l.text),c=l.timestamp+l.duration;let m=e.cueToSourceId.get(l);if(m===void 0&&a<c&&(m=e.nextSourceId++,e.cueToSourceId.set(l,m)),l.notes){const p=sn(l.notes);this.auxBoxWriter.writeBox(p)}const h=rn(l.text,f?n:null,l.identifier??null,l.settings??null,m??null);this.auxBoxWriter.writeBox(h),c===a&&e.cueQueue.splice(u--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,o,n,a-n,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=a}}createSampleForTrack(e,t,s,i,n){return{timestamp:s,decodeTimestamp:s,duration:i,data:t,size:t.byteLength,type:n,timescaleUnitsToNextSample:L(i,e.timescale)}}processTimestamps(e,t){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let i=0;for(let n=0;n<e.timestampProcessingQueue.length;n++){const a=e.timestampProcessingQueue[n],o=L(a.duration,e.timescale);i+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:i,sampleDelta:1});else{const n=K(e.timeToSampleTable);n.sampleCount+=i}e.timestampProcessingQueue.length=0;return}const s=e.timestampProcessingQueue.map(i=>i.timestamp).sort((i,n)=>i-n);for(let i=0;i<e.timestampProcessingQueue.length;i++){const n=e.timestampProcessingQueue[i];n.decodeTimestamp=s[i],!this.isFragmented&&e.lastTimescaleUnits===null&&(n.decodeTimestamp=0);const a=L(n.timestamp-n.decodeTimestamp,e.timescale),o=L(n.duration,e.timescale);if(e.lastTimescaleUnits!==null){g(e.lastSample);const d=L(n.decodeTimestamp,e.timescale,!1),u=Math.round(d-e.lastTimescaleUnits);if(g(u>=0),e.lastTimescaleUnits+=u,e.lastSample.timescaleUnitsToNextSample=u,!this.isFragmented){let l=K(e.timeToSampleTable);if(g(l),l.sampleCount===1){l.sampleDelta=u;const c=e.timeToSampleTable[e.timeToSampleTable.length-2];c&&c.sampleDelta===u&&(c.sampleCount++,e.timeToSampleTable.pop(),l=c)}else l.sampleDelta!==u&&(l.sampleCount--,e.timeToSampleTable.push(l={sampleCount:1,sampleDelta:u}));l.sampleDelta===o?l.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const f=K(e.compositionTimeOffsetTable);g(f),f.sampleCompositionTimeOffset===a?f.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=L(n.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=n}if(e.timestampProcessingQueue.length=0,g(e.lastSample),g(e.lastTimescaleUnits!==null),t!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){g(t.type==="key");const i=L(t.timestamp,e.timescale,!1),n=Math.round(i-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=n}}async registerSample(e,t){t.type==="key"&&this.processTimestamps(e,t),e.timestampProcessingQueue.push(t),this.isFragmented?(e.sampleQueue.push(t),await this.interleaveSamples()):await this.addSampleToTrack(e,t)}async addSampleToTrack(e,t){this.isFragmented||e.samples.push(t);let s=!1;if(!e.currentChunk)s=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,t.timestamp);const i=t.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const n=this.trackDatas.every(a=>{if(e===a)return t.type==="key";const o=a.sampleQueue[0];return o?o.type==="key":a.track.source._closed});i>=this.minimumFragmentDuration&&n&&t.timestamp>this.maxWrittenTimestamp&&(s=!0,await this.finalizeFragment())}else s=i>=.5}s&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:t.timestamp,samples:[],offset:null,moofOffset:null}),g(e.currentChunk),e.currentChunk.samples.push(t),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,t.timestamp))}async finalizeCurrentChunk(e){if(g(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let t=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(t=e.currentChunk.samples.reduce((s,i)=>s+L(i.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||K(e.compactlyCodedChunkTable).samplesPerChunk!==t)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:t}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const s of e.currentChunk.samples)g(s.data),this.writer.write(s.data),s.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(g(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let t=null,s=1/0;for(const n of this.trackDatas){if(!e&&n.sampleQueue.length===0&&!n.track.source._closed)break e;n.sampleQueue.length>0&&n.sampleQueue[0].timestamp<s&&(t=n,s=n.sampleQueue[0].timestamp)}if(!t)break;const i=t.sampleQueue.shift();await this.addSampleToTrack(t,i)}}async finalizeFragment(e=!0){g(this.isFragmented);const t=this.nextFragmentNumber++;if(t===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const m=Je(this.trackDatas,this.creationTime,!0);if(this.boxWriter.writeBox(m),this.format._options.onMoov){const{data:h,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoov(h,p)}}const s=this.trackDatas.filter(m=>m.currentChunk),i=or(t,s),n=this.writer.getPos(),a=n+this.boxWriter.measureBox(i);let o=a+rt,d=1/0;for(const m of s){m.currentChunk.offset=o,m.currentChunk.moofOffset=n;for(const h of m.currentChunk.samples)o+=h.size;d=Math.min(d,m.currentChunk.startTimestamp)}const u=o-a,l=u>=2**32;if(l)for(const m of s)m.currentChunk.offset+=Be-rt;this.format._options.onMoof&&this.writer.startTrackingWrites();const f=or(t,s);if(this.boxWriter.writeBox(f),this.format._options.onMoof){const{data:m,start:h}=this.writer.stopTrackingWrites();this.format._options.onMoof(m,h,d)}g(this.writer.getPos()===a),this.format._options.onMdat&&this.writer.startTrackingWrites();const c=dt(l);c.size=u,this.boxWriter.writeBox(c),this.writer.seek(a+(l?Be:rt));for(const m of s)for(const h of m.currentChunk.samples)this.writer.write(h.data),h.data=null;if(this.format._options.onMdat){const{data:m,start:h}=this.writer.stopTrackingWrites();this.format._options.onMdat(m,h)}for(const m of s)m.finalizedChunks.push(m.currentChunk),this.finalizedChunks.push(m.currentChunk),m.currentChunk=null;e&&await this.writer.flush()}async onTrackClose(e){const t=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const s=this.trackDatas.find(i=>i.track===e);s&&await this.processWebVTTCues(s,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),t()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const t of this.trackDatas)t.type==="subtitle"&&t.track.source._codec==="webvtt"&&await this.processWebVTTCues(t,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const t of this.trackDatas)this.processTimestamps(t);await this.finalizeFragment(!1)}else for(const t of this.trackDatas)this.processTimestamps(t),await this.finalizeCurrentChunk(t);if(this.fastStart==="in-memory"){g(this.mdat);let t;for(let i=0;i<2;i++){const n=Je(this.trackDatas,this.creationTime),a=this.boxWriter.measureBox(n);t=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+a+t;for(const d of this.finalizedChunks){d.offset=o;for(const{data:u}of d.samples)g(u),o+=u.byteLength,t+=u.byteLength}if(o<2**32)break;t>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const s=Je(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(s),this.format._options.onMoov){const{data:i,start:n}=this.writer.stopTrackingWrites();this.format._options.onMoov(i,n)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=t,this.boxWriter.writeBox(this.mdat);for(const i of this.finalizedChunks)for(const n of i.samples)g(n.data),this.writer.write(n.data),n.data=null;if(this.format._options.onMdat){const{data:i,start:n}=this.writer.stopTrackingWrites();this.format._options.onMdat(i,n)}}else if(this.isFragmented){const t=this.writer.getPos(),s=Zi(this.trackDatas);this.boxWriter.writeBox(s);const i=this.writer.getPos()-t;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{g(this.mdat);const t=this.boxWriter.offsets.get(this.mdat);g(t!==void 0);const s=this.writer.getPos()-t;if(this.mdat.size=s,this.mdat.largeSize=s>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(n,a)}this.format._options.onMoov&&this.writer.startTrackingWrites();const i=Je(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(i),this.format._options.onMoov){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(n,a)}}e()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var P;(function(r){r[r.EBML=440786851]="EBML",r[r.EBMLVersion=17030]="EBMLVersion",r[r.EBMLReadVersion=17143]="EBMLReadVersion",r[r.EBMLMaxIDLength=17138]="EBMLMaxIDLength",r[r.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",r[r.DocType=17026]="DocType",r[r.DocTypeVersion=17031]="DocTypeVersion",r[r.DocTypeReadVersion=17029]="DocTypeReadVersion",r[r.SeekHead=290298740]="SeekHead",r[r.Seek=19899]="Seek",r[r.SeekID=21419]="SeekID",r[r.SeekPosition=21420]="SeekPosition",r[r.Duration=17545]="Duration",r[r.Info=357149030]="Info",r[r.TimestampScale=2807729]="TimestampScale",r[r.MuxingApp=19840]="MuxingApp",r[r.WritingApp=22337]="WritingApp",r[r.Tracks=374648427]="Tracks",r[r.TrackEntry=174]="TrackEntry",r[r.TrackNumber=215]="TrackNumber",r[r.TrackUID=29637]="TrackUID",r[r.TrackType=131]="TrackType",r[r.FlagEnabled=185]="FlagEnabled",r[r.FlagDefault=136]="FlagDefault",r[r.FlagForced=21930]="FlagForced",r[r.FlagLacing=156]="FlagLacing",r[r.Language=2274716]="Language",r[r.CodecID=134]="CodecID",r[r.CodecPrivate=25506]="CodecPrivate",r[r.CodecDelay=22186]="CodecDelay",r[r.SeekPreRoll=22203]="SeekPreRoll",r[r.DefaultDuration=2352003]="DefaultDuration",r[r.Video=224]="Video",r[r.PixelWidth=176]="PixelWidth",r[r.PixelHeight=186]="PixelHeight",r[r.Audio=225]="Audio",r[r.SamplingFrequency=181]="SamplingFrequency",r[r.Channels=159]="Channels",r[r.BitDepth=25188]="BitDepth",r[r.Segment=408125543]="Segment",r[r.SimpleBlock=163]="SimpleBlock",r[r.BlockGroup=160]="BlockGroup",r[r.Block=161]="Block",r[r.BlockAdditions=30113]="BlockAdditions",r[r.BlockMore=166]="BlockMore",r[r.BlockAdditional=165]="BlockAdditional",r[r.BlockAddID=238]="BlockAddID",r[r.BlockDuration=155]="BlockDuration",r[r.ReferenceBlock=251]="ReferenceBlock",r[r.Cluster=524531317]="Cluster",r[r.Timestamp=231]="Timestamp",r[r.Cues=475249515]="Cues",r[r.CuePoint=187]="CuePoint",r[r.CueTime=179]="CueTime",r[r.CueTrackPositions=183]="CueTrackPositions",r[r.CueTrack=247]="CueTrack",r[r.CueClusterPosition=241]="CueClusterPosition",r[r.Colour=21936]="Colour",r[r.MatrixCoefficients=21937]="MatrixCoefficients",r[r.TransferCharacteristics=21946]="TransferCharacteristics",r[r.Primaries=21947]="Primaries",r[r.Range=21945]="Range",r[r.Projection=30320]="Projection",r[r.ProjectionType=30321]="ProjectionType",r[r.ProjectionPoseRoll=30325]="ProjectionPoseRoll",r[r.Attachments=423732329]="Attachments",r[r.Chapters=272869232]="Chapters",r[r.Tags=307544935]="Tags"})(P||(P={}));const wn=[P.EBML,P.Segment],Tn=[P.EBMLMaxIDLength,P.EBMLMaxSizeLength,P.SeekHead,P.Info,P.Cluster,P.Tracks,P.Cues,P.Attachments,P.Chapters,P.Tags],xt=[...wn,...Tn],Qr=8,Ct=2,Ae=4+Qr;class Pt{constructor(e){this.reader=e,this.pos=0}readBytes(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);return this.pos+=e,new Uint8Array(t.buffer,s,e)}readU8(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1);return this.pos++,e.getUint8(t)}readS16(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getInt16(t,!1)}readVarIntSize(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1),s=e.getUint8(t);let i=1,n=128;for(;(s&n)===0&&i<8;)i++,n>>=1;return i}readVarInt(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1),s=e.getUint8(t);let i=1,n=128;for(;(s&n)===0&&i<Qr;)i++,n>>=1;const{view:a,offset:o}=this.reader.getViewAndOffset(this.pos,this.pos+i);let d=s&n-1;for(let u=1;u<i;u++)d*=256,d+=a.getUint8(o+u);return this.pos+=i,d}readUnsignedInt(e){if(e<1||e>8)throw new Error("Bad unsigned int size "+e);const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);let i=0;for(let n=0;n<e;n++)i*=256,i+=t.getUint8(s+n);return this.pos+=e,i}readSignedInt(e){let t=this.readUnsignedInt(e);return t&1<<e*8-1&&(t-=2**(e*8)),t}readFloat(e){if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e),i=e===4?t.getFloat32(s,!1):t.getFloat64(s,!1);return this.pos+=e,i}readAsciiString(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i=0;for(;i<e&&t.getUint8(s+i)!==0;)i+=1;return String.fromCharCode(...new Uint8Array(t.buffer,s,i))}readElementId(){const e=this.readVarIntSize();return this.readUnsignedInt(e)}readElementSize(){let e=this.readU8();return e===255?e=null:(this.pos--,e=this.readVarInt(),e===72057594037927940&&(e=null)),e}readElementHeader(){const e=this.readElementId(),t=this.readElementSize();return{id:e,size:t}}async searchForNextElementId(e,t){const i=new Set(e);for(;this.pos<t-Ae;){this.reader.rangeIsLoaded(this.pos,this.pos+Ae)||await this.reader.loadRange(this.pos,Math.min(this.pos+1048576,t));const n=this.pos,a=this.readElementHeader();if(i.has(a.id))return n;_e(a.size),this.pos+=a.size}return null}}const ee={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC"},cr=(r,e)=>{if(e>=r.length)throw new Error("Offset out of bounds.");const t=r[e];let s=1,i=128;for(;(t&i)===0&&s<8;)s++,i>>=1;if(e+s>r.length)throw new Error("VarInt extends beyond data bounds.");let n=t&i-1;for(let a=1;a<s;a++)n*=256,n+=r[e+a];return{value:n,width:s}};function _e(r){if(r===null)throw new Error("Undefined element size is used in a place where it is not supported.")}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const bn=r=>{let t=(r.hasVideo?"video/":r.hasAudio?"audio/":"application/")+(r.isWebM?"webm":"x-matroska");if(r.codecStrings.length>0){const s=[...new Set(r.codecStrings.filter(Boolean))];t+=`; codecs="${s.join(", ")}"`}return t};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const vt=4,yn={1:[-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1],2:[-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1],3:[-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1]},Sn={1:[-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],2:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1],3:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1]},xn={0:[11025,12e3,8e3,-1],2:[22050,24e3,16e3,-1],3:[44100,48e3,32e3,-1]},Cn=1483304551,Pn=1231971951,vn=(r,e,t,s)=>Math.floor(r===3?(12*e/t+s)*4:144*e/t+s),_n=(r,e)=>r===3?e===3?21:36:e===3?13:21,In=(r,e)=>{var y,C,I;const t=e.pos,s=r>>>24,i=r>>>16&255,n=r>>>8&255,a=r&255;if(s!==255&&i!==255&&n!==255&&a!==255)return e.pos+=4,null;if(e.pos+=1,s!==255||(i&224)!==224)return null;const o=i>>3&3,d=i>>1&3,u=n>>4&15,l=n>>2&3,f=n>>1&1,c=a>>6&3,m=a>>4&3,h=a>>3&1,p=a>>2&1,k=a&3,w=o===3?(y=yn[d])==null?void 0:y[u]:(C=Sn[d])==null?void 0:C[u];if(!w||w===-1)return null;const T=w*1e3,x=(I=xn[o])==null?void 0:I[l];if(!x||x===-1)return null;const S=vn(d,T,x,f);if(e.fileSize!==null&&e.fileSize-t<S)return null;let b;return o===3?b=d===3?384:1152:d===3?b=384:d===2?b=1152:b=576,{startPos:t,totalSize:S,mpegVersionId:o,layer:d,bitrate:T,frequencyIndex:l,sampleRate:x,channel:c,modeExtension:m,copyright:h,original:p,emphasis:k,audioSamplesInFrame:b}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const dr=1399285583,En=79764919,Gr=new Uint32Array(256);for(let r=0;r<256;r++){let e=r<<24;for(let t=0;t<8;t++)e=e&2147483648?e<<1^En:e<<1;Gr[r]=e>>>0&4294967295}const Rn=r=>{const e=Ue(r),t=e.getUint32(22,!0);e.setUint32(22,0,!0);let s=0;for(let i=0;i<r.length;i++){const n=r[i];s=(s<<8^Gr[s>>>24^n])>>>0}return e.setUint32(22,t,!0),s},Fn=(r,e,t)=>{let s=0,i=null;if(r.length>0)if(e.codec==="vorbis"){g(e.vorbisInfo);const n=e.vorbisInfo.modeBlockflags.length,o=(1<<xs(n-1))-1<<1,d=(r[0]&o)>>1;if(d>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let u=t;const l=e.vorbisInfo.modeBlockflags[d];if(i=e.vorbisInfo.blocksizes[l],l===1){const f=(o|1)+1,c=r[0]&f?1:0;u=e.vorbisInfo.blocksizes[c]}s=u!==null?u+i>>2:0}else e.codec==="opus"&&(s=ii(r).durationInSamples);return{durationInSamples:s,vorbisBlockSize:i}},Bn=r=>{let e="audio/ogg";if(r.codecStrings){const t=[...new Set(r.codecStrings)];e+=`; codecs="${t.join(", ")}"`}return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Le=27,ze=282,An=ze+255*255;class Xr{constructor(e){this.reader=e,this.pos=0}readBytes(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);return this.pos+=e,new Uint8Array(t.buffer,s,e)}readU8(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1);return this.pos+=1,e.getUint8(t)}readU32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,!0)}readI32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!0)}readI64(){const e=this.readU32();return this.readI32()*4294967296+e}readAscii(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i="";for(let n=0;n<e;n++)i+=String.fromCharCode(t.getUint8(s+n));return i}readPageHeader(){const e=this.pos;if(this.readU32()!==dr)return null;this.pos+=1;const s=this.readU8(),i=this.readI64(),n=this.readU32(),a=this.readU32(),o=this.readU32(),d=this.readU8(),u=new Uint8Array(d);for(let m=0;m<d;m++)u[m]=this.readU8();const l=27+d,f=u.reduce((m,h)=>m+h,0),c=l+f;return{headerStartPos:e,totalSize:c,dataStartPos:e+l,dataSize:f,headerType:s,granulePosition:i,serialNumber:n,sequenceNumber:a,checksum:o,lacingValues:u}}findNextPageHeader(e){for(;this.pos<e-3;){const t=this.readU32(),s=t&255,i=t>>>8&255,n=t>>>16&255,a=t>>>24&255,o=79;if(!(s!==o&&i!==o&&n!==o&&a!==o)){if(this.pos-=4,t===dr)return!0;this.pos+=1}}return!1}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Xe{constructor(e){this.input=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ce=new Uint8Array(0);class N{constructor(e,t,s,i,n=-1,a){if(this.data=e,this.type=t,this.timestamp=s,this.duration=i,this.sequenceNumber=n,e===ce&&a===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(a===void 0&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(t!=="key"&&t!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(s))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(n))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");this.byteLength=a}get isMetadataOnly(){return this.data===ce}get microsecondTimestamp(){return Math.trunc(ue*this.timestamp)}get microsecondDuration(){return Math.trunc(ue*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const t=new Uint8Array(e.byteLength);return e.copyTo(t),new N(t,e.type,e.timestamp/1e6,(e.duration??0)/1e6)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if((e==null?void 0:e.timestamp)!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if((e==null?void 0:e.duration)!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new N(this.data,this.type,(e==null?void 0:e.timestamp)??this.timestamp,(e==null?void 0:e.duration)??this.duration,this.sequenceNumber,this.byteLength)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const zn=r=>{let s=r,i=4096,n=0,a=12,o=0;for(s<0&&(s=-s,n=128),s+=33,s>8191&&(s=8191);(s&i)!==i&&a>=5;)i>>=1,a--;return o=s>>a-4&15,~(n|a-5<<4|o)&255},On=r=>{let t=0,s=0,i=~r;i&128&&(i&=-129,t=-1),s=((i&240)>>4)+5;const n=(1<<s|(i&15)<<s-4|1<<s-5)-33;return t===0?n:-n},Un=r=>{let t=2048,s=0,i=11,n=0,a=r;for(a<0&&(a=-a,s=128),a>4095&&(a=4095);(a&t)!==t&&i>=5;)t>>=1,i--;return n=a>>(i===4?1:i-4)&15,(s|i-4<<4|n)^85},Mn=r=>{let e=0,t=0,s=r^85;s&128&&(s&=-129,e=-1),t=((s&240)>>4)+4;let i=0;return t!==4?i=1<<t|(s&15)<<t-4|1<<t-5:i=s<<1|1,e===0?i:-i};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Re{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(ue*this.timestamp)}get microsecondDuration(){return Math.trunc(ue*this.duration)}constructor(e,t){if(this._closed=!1,e instanceof ArrayBuffer||ArrayBuffer.isView(e)){if(!t||typeof t!="object")throw new TypeError("init must be an object.");if(!("format"in t)||typeof t.format!="string")throw new TypeError("init.format must be a string.");if(!Number.isInteger(t.codedWidth)||t.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(t.codedHeight)||t.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(t.timestamp))throw new TypeError("init.timestamp must be a number.");if(t.duration!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=te(e).slice(),this.format=t.format,this.codedWidth=t.codedWidth,this.codedHeight=t.codedHeight,this.rotation=t.rotation??0,this.timestamp=t.timestamp,this.duration=t.duration??0,this.colorSpace=new VideoColorSpace(t.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if((t==null?void 0:t.rotation)!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if((t==null?void 0:t.timestamp)!==void 0&&!Number.isFinite(t==null?void 0:t.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if((t==null?void 0:t.duration)!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this.format=e.format,this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight,this.rotation=(t==null?void 0:t.rotation)??0,this.timestamp=(t==null?void 0:t.timestamp)??e.timestamp/1e6,this.duration=(t==null?void 0:t.duration)??(e.duration??0)/1e6,this.colorSpace=e.colorSpace}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!t||typeof t!="object")throw new TypeError("init must be an object.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(t.timestamp))throw new TypeError("init.timestamp must be a number.");if(t.duration!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new Re(new VideoFrame(e,{timestamp:Math.trunc(t.timestamp*ue),duration:Math.trunc((t.duration??0)*ue)}),t);let s=0,i=0;if("naturalWidth"in e?(s=e.naturalWidth,i=e.naturalHeight):"videoWidth"in e?(s=e.videoWidth,i=e.videoHeight):"width"in e&&(s=Number(e.width),i=Number(e.height)),!s||!i)throw new TypeError("Could not determine dimensions.");const n=new OffscreenCanvas(s,i),a=n.getContext("2d",{alpha:!1,willReadFrequently:!0});g(a),a.drawImage(e,0,0),this._data=n,this.format="RGBX",this.codedWidth=s,this.codedHeight=i,this.rotation=t.rotation??0,this.timestamp=t.timestamp,this.duration=t.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.")}clone(){if(this._closed)throw new Error("VideoSample is closed.");return g(this._data!==null),Ve(this._data)?new Re(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new Re(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new Re(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(Ve(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return g(this._data!==null),Ve(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e){if(!it(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(g(this._data!==null),Ve(this._data))await this._data.copyTo(e);else if(this._data instanceof Uint8Array)te(e).set(this._data);else{const s=this._data.getContext("2d",{alpha:!1});g(s);const i=s.getImageData(0,0,this.codedWidth,this.codedHeight);te(e).set(i.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return g(this._data!==null),Ve(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}draw(e,t,s,i,n,a,o,d,u){let l=0,f=0,c=this.displayWidth,m=this.displayHeight,h=0,p=0,k=this.displayWidth,w=this.displayHeight;if(a!==void 0?(l=t,f=s,c=i,m=n,h=a,p=o,d!==void 0?(k=d,w=u):(k=c,w=m)):(h=t,p=s,i!==void 0&&(k=i,w=n)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(l))throw new TypeError("sx must be a number.");if(!Number.isFinite(f))throw new TypeError("sy must be a number.");if(!Number.isFinite(c)||c<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(m)||m<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(h))throw new TypeError("dx must be a number.");if(!Number.isFinite(p))throw new TypeError("dy must be a number.");if(!Number.isFinite(k)||k<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(w)||w<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");this.rotation===90?[l,f,c,m]=[f,this.codedHeight-l-c,m,c]:this.rotation===180?[l,f]=[this.codedWidth-l-c,this.codedHeight-f-m]:this.rotation===270&&([l,f,c,m]=[this.codedWidth-f-m,l,m,c]);const T=this.toCanvasImageSource();e.save();const x=h+k/2,S=p+w/2;e.translate(x,S),e.rotate(this.rotation*Math.PI/180);const b=this.rotation%180===0?1:k/w;e.scale(1/b,b),e.drawImage(T,l,f,c,m,-k/2,-w/2,k,w),e.restore()}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(g(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}}const Ve=r=>typeof VideoFrame<"u"&&r instanceof VideoFrame,ft=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class oe{get microsecondTimestamp(){return Math.trunc(ue*this.timestamp)}get microsecondDuration(){return Math.trunc(ue*this.duration)}constructor(e){if(this._closed=!1,We(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!ft.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e==null?void 0:e.timestamp))throw new TypeError("init.timestamp must be a number.");const t=e.data.byteLength/(Ne(e.format)*e.numberOfChannels);if(!Number.isInteger(t))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=t,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=t/e.sampleRate;let s;if(e.data instanceof ArrayBuffer)s=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))s=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const i=this.numberOfFrames*this.numberOfChannels*Ne(this.format);if(s.byteLength<i)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=s}}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!ft.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const t=e.format??this.format,s=e.frameOffset??0;if(s>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const i=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-s;if(i>this.numberOfFrames-s)throw new RangeError("frameCount out of range");const n=Ne(t),a=et(t);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(a?i:i*this.numberOfChannels)*n}copyTo(e,t){if(!it(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(t.planeIndex)||t.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(t.format!==void 0&&!ft.has(t.format))throw new TypeError("Invalid format.");if(t.frameOffset!==void 0&&(!Number.isInteger(t.frameOffset)||t.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(t.frameCount!==void 0&&(!Number.isInteger(t.frameCount)||t.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:s,format:i,frameCount:n,frameOffset:a}=t,o=i??this.format;if(!o)throw new Error("Destination format not determined");const d=this.numberOfFrames,u=this.numberOfChannels,l=a??0;if(l>=d)throw new RangeError("frameOffset out of range");const f=n!==void 0?n:d-l;if(f>d-l)throw new RangeError("frameCount out of range");const c=Ne(o),m=et(o);if(m&&s>=u)throw new RangeError("planeIndex out of range");if(!m&&s!==0)throw new RangeError("planeIndex out of range");const p=(m?f:f*u)*c;if(e.byteLength<p)throw new RangeError("Destination buffer is too small");const k=Ue(e),w=Vn(o);if(We(this._data))if(m)if(o==="f32-planar")this._data.copyTo(e,{planeIndex:s,frameOffset:l,frameCount:f,format:"f32-planar"});else{const T=new ArrayBuffer(f*4),x=new Float32Array(T);this._data.copyTo(x,{planeIndex:s,frameOffset:l,frameCount:f,format:"f32-planar"});const S=new DataView(T);for(let b=0;b<f;b++){const y=b*c,C=S.getFloat32(b*4,!0);w(k,y,C)}}else{const T=u,x=new Float32Array(f);for(let S=0;S<T;S++){this._data.copyTo(x,{planeIndex:S,frameOffset:l,frameCount:f,format:"f32-planar"});for(let b=0;b<f;b++){const C=(b*T+S)*c;w(k,C,x[b])}}}else{const T=this._data,x=new DataView(T.buffer,T.byteOffset,T.byteLength),S=this.format,b=Dn(S),y=Ne(S),C=et(S);for(let I=0;I<f;I++)if(m){const R=I*c;let _;C?_=(s*d+(I+l))*y:_=((I+l)*u+s)*y;const F=b(x,_);w(k,R,F)}else for(let R=0;R<u;R++){const F=(I*u+R)*c;let W;C?W=(R*d+(I+l))*y:W=((I+l)*u+R)*y;const M=b(x,W);w(k,F,M)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(We(this._data)){const e=new oe(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new oe({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(We(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(We(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(et(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),t=new ArrayBuffer(e*this.numberOfChannels);for(let s=0;s<this.numberOfChannels;s++)this.copyTo(new Uint8Array(t,s*e,e),{planeIndex:s,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:t})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),t=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let s=0;s<this.numberOfChannels;s++)this.copyTo(t,{planeIndex:s,format:"f32-planar"}),e.copyToChannel(t,s);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}static fromAudioBuffer(e,t){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const s=64*1024*1024,i=e.numberOfChannels,n=e.sampleRate,a=e.length,o=Math.floor(s/i);let d=0,u=a;const l=[];for(;u>0;){const f=Math.min(o,u),c=new Float32Array(i*f);for(let h=0;h<i;h++)e.copyFromChannel(c.subarray(h*f,h*f+f),h,d);const m=new oe({format:"f32-planar",sampleRate:n,numberOfFrames:f,numberOfChannels:i,timestamp:t+d/n,data:c});l.push(m),d+=f,u-=f}return l}}const Ne=r=>{switch(r){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},et=r=>{switch(r){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},Dn=r=>{switch(r){case"u8":case"u8-planar":return(e,t)=>(e.getUint8(t)-128)/128;case"s16":case"s16-planar":return(e,t)=>e.getInt16(t,!0)/32768;case"s32":case"s32-planar":return(e,t)=>e.getInt32(t,!0)/2147483648;case"f32":case"f32-planar":return(e,t)=>e.getFloat32(t,!0)}},Vn=r=>{switch(r){case"u8":case"u8-planar":return(e,t,s)=>e.setUint8(t,X((s+1)*127.5,0,255));case"s16":case"s16-planar":return(e,t,s)=>e.setInt16(t,X(Math.round(s*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,t,s)=>e.setInt32(t,X(Math.round(s*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,t,s)=>e.setFloat32(t,s,!0)}},We=r=>typeof AudioData<"u"&&r instanceof AudioData;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Pe=r=>{if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.metadataOnly!==void 0&&typeof r.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(r.verifyKeyPackets!==void 0&&typeof r.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(r.verifyKeyPackets&&r.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},be=r=>{if(typeof r!="number"||Number.isNaN(r))throw new TypeError("timestamp must be a number.")},ht=(r,e,t)=>t.verifyKeyPackets?e.then(async s=>{if(!s||s.type==="delta")return s;const i=await r.determinePacketType(s);return i&&(s.type=i),s}):e;class Yr{constructor(e){if(!(e instanceof zt))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){return Pe(e),ht(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,t={}){return be(e),Pe(t),ht(this._track,this._track._backing.getPacket(e,t),t)}getNextPacket(e,t={}){if(!(e instanceof N))throw new TypeError("packet must be an EncodedPacket.");return Pe(t),ht(this._track,this._track._backing.getNextPacket(e,t),t)}async getKeyPacket(e,t={}){if(be(e),Pe(t),!t.verifyKeyPackets)return this._track._backing.getKeyPacket(e,t);const s=await this._track._backing.getKeyPacket(e,t);return!s||s.type==="delta"?s:await this._track.determinePacketType(s)==="delta"?this.getKeyPacket(s.timestamp-1/this._track.timeResolution,t):s}async getNextKeyPacket(e,t={}){if(!(e instanceof N))throw new TypeError("packet must be an EncodedPacket.");if(Pe(t),!t.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,t);const s=await this._track._backing.getNextKeyPacket(e,t);return!s||s.type==="delta"?s:await this._track.determinePacketType(s)==="delta"?this.getNextKeyPacket(s,t):s}packets(e,t,s={}){if(e!==void 0&&!(e instanceof N))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!(s!=null&&s.metadataOnly))throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(t!==void 0&&!(t instanceof N))throw new TypeError("endPacket must be an EncodedPacket.");Pe(s);const i=[];let{promise:n,resolve:a}=Y(),{promise:o,resolve:d}=Y(),u=!1,l=!1,f=null;const c=[],m=()=>Math.max(2,c.length);return(async()=>{let h=e??await this.getFirstPacket(s);for(;h&&!l&&!(t&&h.sequenceNumber>=(t==null?void 0:t.sequenceNumber));){if(i.length>m()){({promise:o,resolve:d}=Y()),await o;continue}i.push(h),a(),{promise:n,resolve:a}=Y(),h=await this.getNextPacket(h,s)}u=!0,a()})().catch(h=>{f||(f=h,a())}),{async next(){for(;;){if(l)return{value:void 0,done:!0};if(f)throw f;if(i.length>0){const h=i.shift(),p=performance.now();for(c.push(p);c.length>0&&p-c[0]>=1e3;)c.shift();return d(),{value:h,done:!1}}else{if(u)return{value:void 0,done:!0};await n}}},async return(){return l=!0,d(),a(),{value:void 0,done:!0}},async throw(h){throw h},[Symbol.asyncIterator](){return this}}}}class Zr{constructor(e,t){this.onSample=e,this.onError=t}}class Nn{mediaSamplesInRange(e=0,t=1/0){be(e),be(t);const s=[];let i=!1,n=null,{promise:a,resolve:o}=Y(),{promise:d,resolve:u}=Y(),l=!1,f=!1,c=!1,m=null;return(async()=>{const h=new Error,p=await this._createDecoder(b=>{if(u(),b.timestamp>=t&&(f=!0),f){b.close();return}n&&(b.timestamp>e?(s.push(n),i=!0):n.close()),b.timestamp>=e&&(s.push(b),i=!0),n=i?null:b,s.length>0&&(o(),{promise:a,resolve:o}=Y())},b=>{m||(b.stack=h.stack,m=b,o())}),k=this._createPacketSink(),w=await k.getKeyPacket(e,{verifyKeyPackets:!0})??await k.getFirstPacket();if(!w)return;let T=w,x;if(t<1/0){const b=await k.getPacket(t),y=b?b.type==="key"&&b.timestamp===t?b:await k.getNextKeyPacket(b,{verifyKeyPackets:!0}):null;y&&(x=y)}const S=k.packets(w,x);for(await S.next();T&&!f;){const b=lr(s.length);if(s.length+p.getDecodeQueueSize()>b){({promise:d,resolve:u}=Y()),await d;continue}p.decode(T);const y=await S.next();if(y.done)break;T=y.value}await S.return(),c||await p.flush(),p.close(),!i&&n&&s.push(n),l=!0,o()})().catch(h=>{m||(m=h,o())}),{async next(){for(;;){if(c)return{value:void 0,done:!0};if(m)throw m;if(s.length>0){const h=s.shift();return u(),{value:h,done:!1}}else if(!l)await a;else return{value:void 0,done:!0}}},async return(){c=!0,f=!0,u(),o(),n==null||n.close();for(const h of s)h.close();return{value:void 0,done:!0}},async throw(h){throw h},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(e){Ts(e);const t=ws(e),s=[],i=[];let{promise:n,resolve:a}=Y(),{promise:o,resolve:d}=Y(),u=!1,l=!1,f=null;const c=m=>{i.push(m),a(),{promise:n,resolve:a}=Y()};return(async()=>{const m=new Error,h=await this._createDecoder(b=>{if(d(),l){b.close();return}let y=0;for(;s.length>0&&b.timestamp-s[0]>-1e-10;)y++,s.shift();if(y>0)for(let C=0;C<y;C++)c(C<y-1?b.clone():b);else b.close()},b=>{f||(b.stack=m.stack,f=b,a())}),p=this._createPacketSink();let k=null,w=null,T=-1;const x=async()=>{g(w);let b=w;for(h.decode(b);b.sequenceNumber<T;){const y=lr(i.length);for(;i.length+h.getDecodeQueueSize()>y&&!l;)({promise:o,resolve:d}=Y()),await o;if(l)break;const C=await p.getNextPacket(b);g(C),b=C,h.decode(C)}T=-1},S=async()=>{await h.flush();for(let b=0;b<s.length;b++)c(null);s.length=0};for await(const b of t){if(be(b),l)break;const y=await p.getPacket(b),C=y&&await p.getKeyPacket(b,{verifyKeyPackets:!0});if(!C){T!==-1&&(await x(),await S()),c(null),k=null;continue}k&&(C.sequenceNumber!==w.sequenceNumber||y.timestamp<k.timestamp)&&(await x(),await S()),s.push(y.timestamp),T=Math.max(y.sequenceNumber,T),k=y,w=C}l||(T!==-1&&await x(),await S()),h.close(),u=!0,a()})().catch(m=>{f||(f=m,a())}),{async next(){for(;;){if(l)return{value:void 0,done:!0};if(f)throw f;if(i.length>0){const m=i.shift();return g(m!==void 0),d(),{value:m,done:!1}}else if(!u)await n;else return{value:void 0,done:!0}}},async return(){l=!0,d(),a();for(const m of i)m==null||m.close();return{value:void 0,done:!0}},async throw(m){throw m},[Symbol.asyncIterator](){return this}}}}const lr=r=>r===0?40:8;class Wn extends Zr{constructor(e,t,s,i){super(e,t),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new Ft,this.customDecoderQueueSize=0;const n=o=>{if(o.numberOfFrames===0){o.close();return}const d=i.sampleRate;o.setTimestamp(Math.round(o.timestamp*d)/d),e(o)},a=Cr.find(o=>o.supports(s,i));a?(this.customDecoder=new a,this.customDecoder.codec=s,this.customDecoder.config=i,this.customDecoder.onSample=o=>{if(!(o instanceof oe))throw new TypeError("The argument passed to onSample must be an AudioSample.");n(o)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init())):(this.decoder=new AudioDecoder({output:o=>n(new oe(o)),error:t}),this.decoder.configure(i))}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(g(this.decoder),this.decoder.decodeQueueSize)}decode(e){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(g(this.decoder),this.decoder.decode(e.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(g(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(g(this.decoder),this.decoder.close())}}class Hn extends Zr{constructor(e,t,s){super(e,t),this.decoderConfig=s,this.currentTimestamp=null,g(G.includes(s.codec)),this.codec=s.codec;const{dataType:i,sampleSize:n,littleEndian:a}=pe(this.codec);switch(this.inputSampleSize=n,n){case 1:i==="unsigned"?this.readInputValue=(o,d)=>o.getUint8(d)-2**7:i==="signed"?this.readInputValue=(o,d)=>o.getInt8(d):i==="ulaw"?this.readInputValue=(o,d)=>On(o.getUint8(d)):i==="alaw"?this.readInputValue=(o,d)=>Mn(o.getUint8(d)):g(!1);break;case 2:i==="unsigned"?this.readInputValue=(o,d)=>o.getUint16(d,a)-2**15:i==="signed"?this.readInputValue=(o,d)=>o.getInt16(d,a):g(!1);break;case 3:i==="unsigned"?this.readInputValue=(o,d)=>Sr(o,d,a)-2**23:i==="signed"?this.readInputValue=(o,d)=>bs(o,d,a):g(!1);break;case 4:i==="unsigned"?this.readInputValue=(o,d)=>o.getUint32(d,a)-2**31:i==="signed"?this.readInputValue=(o,d)=>o.getInt32(d,a):i==="float"?this.readInputValue=(o,d)=>o.getFloat32(d,a):g(!1);break;case 8:i==="float"?this.readInputValue=(o,d)=>o.getFloat64(d,a):g(!1);break;default:$e(n),g(!1)}switch(n){case 1:i==="ulaw"||i==="alaw"?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,d,u)=>o.setInt16(d,u,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(o,d,u)=>o.setUint8(d,u+2**7));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,d,u)=>o.setInt16(d,u,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(o,d,u)=>o.setInt32(d,u<<8,!0);break;case 4:this.outputSampleSize=4,i==="float"?(this.outputFormat="f32",this.writeOutputValue=(o,d,u)=>o.setFloat32(d,u,!0)):(this.outputFormat="s32",this.writeOutputValue=(o,d,u)=>o.setInt32(d,u,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(o,d,u)=>o.setFloat32(d,u,!0);break;default:$e(n),g(!1)}}getDecodeQueueSize(){return 0}decode(e){const t=Ue(e.data),s=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,i=s*this.decoderConfig.numberOfChannels*this.outputSampleSize,n=new ArrayBuffer(i),a=new DataView(n);for(let l=0;l<s*this.decoderConfig.numberOfChannels;l++){const f=l*this.inputSampleSize,c=l*this.outputSampleSize,m=this.readInputValue(t,f);this.writeOutputValue(a,c,m)}const o=s/this.decoderConfig.sampleRate;(this.currentTimestamp===null||Math.abs(e.timestamp-this.currentTimestamp)>=o)&&(this.currentTimestamp=e.timestamp);const d=this.currentTimestamp;this.currentTimestamp+=o;const u=new oe({format:this.outputFormat,data:n,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:s,timestamp:d});this.onSample(u)}async flush(){}close(){}}class Ln extends Nn{constructor(e){if(!(e instanceof ge))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._audioTrack=e}async _createDecoder(e,t){if(!await this._audioTrack.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const s=this._audioTrack.codec,i=await this._audioTrack.getDecoderConfig();return g(s&&i),G.includes(i.codec)?new Hn(e,t,i):new Wn(e,t,s,i)}_createPacketSink(){return new Yr(this._audioTrack)}async getSample(e){be(e);for await(const t of this.mediaSamplesAtTimestamps([e]))return t;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,t=1/0){return this.mediaSamplesInRange(e,t)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class $n{constructor(e){if(!(e instanceof ge))throw new TypeError("audioTrack must be an InputAudioTrack.");this._audioSampleSink=new Ln(e)}_audioSampleToWrappedArrayBuffer(e){return{buffer:e.toAudioBuffer(),timestamp:e.timestamp,duration:e.duration}}async getBuffer(e){be(e);const t=await this._audioSampleSink.getSample(e);return t&&this._audioSampleToWrappedArrayBuffer(t)}buffers(e=0,t=1/0){return qt(this._audioSampleSink.samples(e,t),s=>this._audioSampleToWrappedArrayBuffer(s))}buffersAtTimestamps(e){return qt(this._audioSampleSink.samplesAtTimestamps(e),t=>t&&this._audioSampleToWrappedArrayBuffer(t))}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class zt{constructor(e){this._backing=e}isVideoTrack(){return this instanceof Ot}isAudioTrack(){return this instanceof ge}get id(){return this._backing.getId()}get languageCode(){return this._backing.getLanguageCode()}get timeResolution(){return this._backing.getTimeResolution()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const t=new Yr(this);let s=1/0,i=-1/0,n=0,a=0;for await(const o of t.packets(void 0,void 0,{metadataOnly:!0})){if(n>=e&&o.timestamp>=i)break;s=Math.min(s,o.timestamp),i=Math.max(i,o.timestamp+o.duration),n++,a+=o.byteLength}return{packetCount:n,averagePacketRate:n?Number((n/(i-s)).toPrecision(16)):0,averageBitrate:n?Number((8*a/(i-s)).toPrecision(16)):0}}}class Ot extends zt{constructor(e){super(e),this._backing=e}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const t=this._backing.getCodec();return g(t!==null),vs.some(i=>i.supports(t,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof N))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");return this.codec===null?null:ai(this,e)}}class ge extends zt{constructor(e){super(e),this._backing=e}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const t=this._backing.getCodec();return g(t!==null),Cr.some(s=>s.supports(t,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof N))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ye{constructor(e,t=1/0){this.source=e,this.maxStorableBytes=t,this.loadedSegments=[],this.loadingSegments=[],this.sourceSizePromise=null,this.nextAge=0,this.totalStoredBytes=0}async loadRange(e,t){var d,u;if(t=Math.min(t,await this.source.getSize()),e>=t)return;const s=this.loadingSegments.find(l=>l.start<=e&&l.end>=t);if(s){await s.promise;return}const i=D(this.loadedSegments,e,l=>l.start);if(i!==-1)for(let l=i;l<this.loadedSegments.length;l++){const f=this.loadedSegments[l];if(f.start>e)break;if(f.end>=t)return}(u=(d=this.source).onread)==null||u.call(d,e,t);const n=this.source._read(e,t),a={start:e,end:t,promise:n};this.loadingSegments.push(a);const o=await n;ks(this.loadingSegments,a),this.insertIntoLoadedSegments(e,o)}rangeIsLoaded(e,t){if(t<=e)return!0;const s=D(this.loadedSegments,e,i=>i.start);if(s===-1)return!1;for(let i=s;i<this.loadedSegments.length;i++){const n=this.loadedSegments[i];if(n.start>e)break;if(n.end>=t)return!0}return!1}insertIntoLoadedSegments(e,t){const s={start:e,end:e+t.byteLength,bytes:t,view:new DataView(t.buffer),age:this.nextAge++};let i=D(this.loadedSegments,e,n=>n.start);(i===-1||this.loadedSegments[i].start<s.start)&&i++,this.loadedSegments.splice(i,0,s),this.totalStoredBytes+=t.byteLength;for(let n=i+1;n<this.loadedSegments.length;n++){const a=this.loadedSegments[n];if(a.start>=s.end)break;s.start<=a.start&&a.end<=s.end&&(this.loadedSegments.splice(n,1),n--)}for(;this.totalStoredBytes>this.maxStorableBytes&&this.loadedSegments.length>1;){let n=null,a=-1;for(let o=0;o<this.loadedSegments.length;o++){const d=this.loadedSegments[o];(!n||d.age<n.age)&&(n=d,a=o)}g(n),this.totalStoredBytes-=n.bytes.byteLength,this.loadedSegments.splice(a,1)}}getViewAndOffset(e,t){const s=D(this.loadedSegments,e,n=>n.start);let i=null;if(s!==-1)for(let n=s;n<this.loadedSegments.length;n++){const a=this.loadedSegments[n];if(a.start>e)break;if(t<=a.end){i=a;break}}if(!i)throw new Error(`No segment loaded for range [${e}, ${t}).`);return i.age=this.nextAge++,{view:i.view,offset:i.bytes.byteOffset+e-i.start}}forgetRange(e,t){if(t<=e)return;const s=D(this.loadedSegments,e,n=>n.start);if(s===-1)return;const i=this.loadedSegments[s];i.start!==e||i.end!==t||(this.loadedSegments.splice(s,1),this.totalStoredBytes-=i.bytes.byteLength)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class _t{constructor(e){this.reader=e,this.pos=0,this.littleEndian=!0}readBytes(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);return this.pos+=e,new Uint8Array(t.buffer,s,e)}readU16(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getUint16(t,this.littleEndian)}readU32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,this.littleEndian)}readU64(){let e,t;return this.littleEndian?(e=this.readU32(),t=this.readU32()):(t=this.readU32(),e=this.readU32()),t*4294967296+e}readAscii(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i="";for(let n=0;n<e;n++)i+=String.fromCharCode(t.getUint8(s+n));return i}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var ie;(function(r){r[r.PCM=1]="PCM",r[r.IEEE_FLOAT=3]="IEEE_FLOAT",r[r.ALAW=6]="ALAW",r[r.MULAW=7]="MULAW",r[r.EXTENSIBLE=65534]="EXTENSIBLE"})(ie||(ie={}));class Kn extends Xe{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.metadataReader=new _t(e._mainReader),this.chunkReader=new _t(new Ye(e.source,64*2**20))}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{const e=await this.metadataReader.reader.source.getSize(),t=this.metadataReader.readAscii(4);this.metadataReader.littleEndian=t!=="RIFX";const s=t==="RF64",i=this.metadataReader.readU32();let n=s?e:Math.min(i+8,e);if(this.metadataReader.readAscii(4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");this.metadataReader.pos=12;let o=0,d=null;for(;this.metadataReader.pos<n;){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+8);const l=this.metadataReader.readAscii(4),f=this.metadataReader.readU32(),c=this.metadataReader.pos;if(s&&o===0&&l!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(l==="fmt ")await this.parseFmtChunk(f);else if(l==="data")d??(d=f),this.dataStart=this.metadataReader.pos,this.dataSize=Math.min(d,n-this.dataStart);else if(l==="ds64"){const m=this.metadataReader.readU64();d=this.metadataReader.readU64(),n=Math.min(m+8,e)}this.metadataReader.pos=c+f+(f&1),o++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const u=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/u)*u,this.tracks.push(new ge(new jn(this)))})())}async parseFmtChunk(e){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+e);let t=this.metadataReader.readU16();const s=this.metadataReader.readU16(),i=this.metadataReader.readU32();this.metadataReader.pos+=4;const n=this.metadataReader.readU16();let a;if(e===14?a=8:a=this.metadataReader.readU16(),e>=18&&t!==357){const o=this.metadataReader.readU16(),d=e-18;if(Math.min(d,o)>=22&&t===ie.EXTENSIBLE){this.metadataReader.pos+=6;const l=this.metadataReader.readBytes(16);t=l[0]|l[1]<<8}}(t===ie.MULAW||t===ie.ALAW)&&(a=8),this.audioInfo={format:t,numberOfChannels:s,sampleRate:i,sampleSizeInBytes:Math.ceil(a/8),blockSizeInBytes:n}}getCodec(){if(g(this.audioInfo),this.audioInfo.format===ie.MULAW)return"ulaw";if(this.audioInfo.format===ie.ALAW)return"alaw";if(this.audioInfo.format===ie.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===ie.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){return await this.readMetadata(),g(this.audioInfo),this.dataSize/this.audioInfo.blockSizeInBytes/this.audioInfo.sampleRate}async getTracks(){return await this.readMetadata(),this.tracks}}const ve=2048;class jn{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(g(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}computeDuration(){return this.demuxer.computeDuration()}getNumberOfChannels(){return g(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return g(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return g(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getLanguageCode(){return fe}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,t){g(this.demuxer.audioInfo);const s=e*ve*this.demuxer.audioInfo.blockSizeInBytes;if(s>=this.demuxer.dataSize)return null;const i=Math.min(ve*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-s);let n;if(t.metadataOnly)n=ce;else{const d=ve*this.demuxer.audioInfo.blockSizeInBytes,u=Math.ceil(2**19/d)*d,l=Math.floor(s/u)*u,f=l+u;await this.demuxer.chunkReader.reader.loadRange(this.demuxer.dataStart+l,this.demuxer.dataStart+f),this.demuxer.chunkReader.pos=this.demuxer.dataStart+s,n=this.demuxer.chunkReader.readBytes(i)}const a=e*ve/this.demuxer.audioInfo.sampleRate,o=i/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return new N(n,"key",a,o,e,i)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}getPacket(e,t){g(this.demuxer.audioInfo);const s=Math.floor(e*this.demuxer.audioInfo.sampleRate/ve);return this.getPacketAtIndex(s,t)}getNextPacket(e,t){g(this.demuxer.audioInfo);const s=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/ve);return this.getPacketAtIndex(s+1,t)}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Jr{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>ye.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>Se.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>st.includes(e))}_codecUnsupportedHint(e){return""}}class es extends Jr{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new kn(e,this)}}class ts extends es{get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...ye,...Pr,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...st]}_codecUnsupportedHint(e){return new rs().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class rs extends es{get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...ye,...Se]}_codecUnsupportedHint(e){return new ts().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ut{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class ss extends Ut{constructor(e){if(super(),this._connectedTrack=null,!ye.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${ye.join(", ")}.`);this._codec=e}}const qn=r=>{if(!r||typeof r!="object")throw new TypeError("Encoding config must be an object.");if(!ye.includes(r.codec))throw new TypeError(`Invalid video codec '${r.codec}'. Must be one of: ${ye.join(", ")}.`);if(!(r.bitrate instanceof he)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(r.latencyMode!==void 0&&!["quality","realtime"].includes(r.latencyMode))throw new TypeError("config.latencyMode, when provided, must be 'quality' or 'realtime'.");if(r.keyFrameInterval!==void 0&&(!Number.isFinite(r.keyFrameInterval)||r.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(r.fullCodecString!==void 0&&typeof r.fullCodecString!="string")throw new TypeError("config.fullCodecString, when provided, must be a string.");if(r.fullCodecString!==void 0&&Rr(r.fullCodecString)!==r.codec)throw new TypeError(`config.fullCodecString, when provided, must be a string that matches the specified codec (${r.codec}).`);if(r.onEncodedPacket!==void 0&&typeof r.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(r.onEncoderConfig!==void 0&&typeof r.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.")};class Qn{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.lastWidth=null,this.lastHeight=null,this.customEncoder=null,this.customEncoderCallSerializer=new Ft,this.customEncoderQueueSize=0,this.encoderError=null}async add(e,t,s){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastWidth!==null&&this.lastHeight!==null){if(e.codedWidth!==this.lastWidth||e.codedHeight!==this.lastHeight)throw new Error(`Video sample size must remain constant. Expected ${this.lastWidth}x${this.lastHeight}, got ${e.codedWidth}x${e.codedHeight}.`)}else this.lastWidth=e.codedWidth,this.lastHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),g(this.encoderInitialized);const i=this.encodingConfig.keyFrameInterval??5,n=Math.floor(e.timestamp/i),a={...s,keyFrame:(s==null?void 0:s.keyFrame)||i===0||n!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=n,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),d=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,a)).then(()=>this.customEncoderQueueSize--).catch(u=>this.encoderError??(this.encoderError=u)).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await d}else{g(this.encoder);const o=e.toVideoFrame();this.encoder.encode(o,a),o.close(),t&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(d=>this.encoder.addEventListener("dequeue",d,{once:!0}))}await this.muxer.mutex.currentPromise}finally{t&&e.close()}}async ensureEncoder(e){if(!this.encoder)return this.ensureEncoderPromise=(async()=>{var o,d,u;const t=e.codedWidth,s=e.codedHeight,i=this.encodingConfig.bitrate instanceof he?this.encodingConfig.bitrate._toVideoBitrate(this.encodingConfig.codec,t,s):this.encodingConfig.bitrate,n={codec:this.encodingConfig.fullCodecString??Is(this.encodingConfig.codec,t,s,i),width:t,height:s,bitrate:i,framerate:(o=this.source._connectedTrack)==null?void 0:o.metadata.frameRate,latencyMode:this.encodingConfig.latencyMode,...Fs(this.encodingConfig.codec)};(u=(d=this.encodingConfig).onEncoderConfig)==null||u.call(d,n);const a=_s.find(l=>l.supports(this.encodingConfig.codec,n));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(l,f)=>{var c,m;if(!(l instanceof N))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(f!==void 0&&(!f||typeof f!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(m=(c=this.encodingConfig).onEncodedPacket)==null||m.call(c,l,f),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,l,f)},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(!(await VideoEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.width}x${n.height}) is not supported by this browser. Consider using another codec or changing your video parameters.`);this.encoder=new VideoEncoder({output:(f,c)=>{var h,p;const m=N.fromEncodedChunk(f);(p=(h=this.encodingConfig).onEncodedPacket)==null||p.call(h,m,c),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,m,c)},error:f=>{f.stack=new Error().stack,this.encoderError??(this.encoderError=f)}}),this.encoder.configure(n)}g(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class Gn extends ss{constructor(e,t){if(!(typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement)&&!(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas))throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");qn(t),super(t.codec),this._encoder=new Qn(this,t),this._canvas=e}add(e,t=0,s){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(t)||t<0)throw new TypeError("duration must be a non-negative number.");const i=new Re(this._canvas,{timestamp:e,duration:t});return this._encoder.add(i,!0,s)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class is extends Ut{constructor(e){if(super(),this._connectedTrack=null,!Se.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Se.join(", ")}.`);this._codec=e}}const Xn=r=>{if(!r||typeof r!="object")throw new TypeError("Encoding config must be an object.");if(!Se.includes(r.codec))throw new TypeError(`Invalid audio codec '${r.codec}'. Must be one of: ${Se.join(", ")}.`);if(r.bitrate===void 0&&(!G.includes(r.codec)||r.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(r.bitrate!==void 0&&!(r.bitrate instanceof he)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(r.fullCodecString!==void 0&&typeof r.fullCodecString!="string")throw new TypeError("config.fullCodecString, when provided, must be a string.");if(r.fullCodecString!==void 0&&Rr(r.fullCodecString)!==r.codec)throw new TypeError(`config.fullCodecString, when provided, must be a string that matches the specified codec (${r.codec}).`);if(r.onEncodedPacket!==void 0&&typeof r.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(r.onEncoderConfig!==void 0&&typeof r.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.")};class Yn{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new Ft,this.customEncoderQueueSize=0,this.encoderError=null}async add(e,t){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),g(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const s=e.clone(),i=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(s)).then(()=>this.customEncoderQueueSize--).catch(n=>this.encoderError??(this.encoderError=n)).finally(()=>{s.close()});this.customEncoderQueueSize>=4&&await i,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,t);else{g(this.encoder);const s=e.toAudioData();this.encoder.encode(s),s.close(),t&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(i=>this.encoder.addEventListener("dequeue",i,{once:!0})),await this.muxer.mutex.currentPromise}}finally{t&&e.close()}}async doPcmEncoding(e,t){var c,m;g(this.outputSampleSize),g(this.writeOutputValue);const{numberOfChannels:s,numberOfFrames:i,sampleRate:n,timestamp:a}=e,o=2048,d=[];for(let h=0;h<i;h+=o){const p=Math.min(o,e.numberOfFrames-h),k=p*s*this.outputSampleSize,w=new ArrayBuffer(k),T=new DataView(w);d.push({frameCount:p,view:T})}const u=e.allocationSize({planeIndex:0,format:"f32-planar"}),l=new Float32Array(u/Float32Array.BYTES_PER_ELEMENT);for(let h=0;h<s;h++){e.copyTo(l,{planeIndex:h,format:"f32-planar"});for(let p=0;p<d.length;p++){const{frameCount:k,view:w}=d[p];for(let T=0;T<k;T++)this.writeOutputValue(w,(T*s+h)*this.outputSampleSize,l[p*o+T])}}t&&e.close();const f={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:s,sampleRate:n}};for(let h=0;h<d.length;h++){const{frameCount:p,view:k}=d[h],w=k.buffer,T=h*o,x=new N(new Uint8Array(w),"key",a+T/n,p/n);(m=(c=this.encodingConfig).onEncodedPacket)==null||m.call(c,x,f),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,x,f)}}ensureEncoder(e){if(!this.encoderInitialized)return this.ensureEncoderPromise=(async()=>{var o,d;const{numberOfChannels:t,sampleRate:s}=e,i=this.encodingConfig.bitrate instanceof he?this.encodingConfig.bitrate._toAudioBitrate(this.encodingConfig.codec):this.encodingConfig.bitrate,n={codec:this.encodingConfig.fullCodecString??wt(this.encodingConfig.codec,t,s),numberOfChannels:t,sampleRate:s,bitrate:i,...Tt(this.encodingConfig.codec)};(d=(o=this.encodingConfig).onEncoderConfig)==null||d.call(o,n);const a=kt.find(u=>u.supports(this.encodingConfig.codec,n));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(u,l)=>{var f,c;if(!(u instanceof N))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(l!==void 0&&(!l||typeof l!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(c=(f=this.encodingConfig).onEncodedPacket)==null||c.call(f,u,l),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,u,l)},await this.customEncoder.init();else if(G.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.numberOfChannels} channels, ${n.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(l,f)=>{var m,h;const c=N.fromEncodedChunk(l);(h=(m=this.encodingConfig).onEncodedPacket)==null||h.call(m,c,f),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,c,f)},error:l=>{l.stack=new Error().stack,this.encoderError??(this.encoderError=l)}}),this.encoder.configure(n)}g(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:t,sampleSize:s,littleEndian:i}=pe(e);switch(this.outputSampleSize=s,s){case 1:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint8(a,X((o+1)*127.5,0,255)):t==="signed"?this.writeOutputValue=(n,a,o)=>{n.setInt8(a,X(Math.round(o*128),-128,127))}:t==="ulaw"?this.writeOutputValue=(n,a,o)=>{const d=X(Math.floor(o*32767),-32768,32767);n.setUint8(a,zn(d))}:t==="alaw"?this.writeOutputValue=(n,a,o)=>{const d=X(Math.floor(o*32767),-32768,32767);n.setUint8(a,Un(d))}:g(!1);break;case 2:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint16(a,X((o+1)*32767.5,0,65535),i):t==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt16(a,X(Math.round(o*32767),-32768,32767),i):g(!1);break;case 3:t==="unsigned"?this.writeOutputValue=(n,a,o)=>xr(n,a,X((o+1)*83886075e-1,0,16777215),i):t==="signed"?this.writeOutputValue=(n,a,o)=>ys(n,a,X(Math.round(o*8388607),-8388608,8388607),i):g(!1);break;case 4:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint32(a,X((o+1)*21474836475e-1,0,4294967295),i):t==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt32(a,X(Math.round(o*2147483647),-2147483648,2147483647),i):t==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat32(a,o,i):g(!1);break;case 8:t==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat64(a,o,i):g(!1);break;default:$e(s),g(!1)}}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class Zn extends is{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="audio")throw new TypeError("track must be an audio MediaStreamTrack.");Xn(t),super(t.codec),this._abortController=null,this._audioContext=null,this._scriptProcessorNode=null,this._promiseWithResolvers=Y(),this._errorPromiseAccessed=!1,this._encoder=new Yn(this,t),this._track=e}async _start(){if(this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController,typeof MediaStreamTrackProcessor<"u"){let e=null;const t=new MediaStreamTrackProcessor({track:this._track}),s=new WritableStream({write:i=>{if(e===null){e=i.timestamp/1e6;const n=this._connectedTrack.output._muxer;n.firstMediaStreamTimestamp===null?(n.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-n.firstMediaStreamTimestamp-e}if(this._encoder.getQueueSize()>=4){i.close();return}this._encoder.add(new oe(i),!0).catch(n=>{var a;(a=this._abortController)==null||a.abort(),this._promiseWithResolvers.reject(n)})}});t.readable.pipeTo(s,{signal:this._abortController.signal}).catch(i=>{i instanceof DOMException&&i.name==="AbortError"||this._promiseWithResolvers.reject(i)})}else{const e=window.AudioContext||window.webkitAudioContext;this._audioContext=new e({sampleRate:this._track.getSettings().sampleRate});const t=this._audioContext.createMediaStreamSource(new MediaStream([this._track]));this._scriptProcessorNode=this._audioContext.createScriptProcessor(4096),this._audioContext.state==="suspended"&&await this._audioContext.resume(),t.connect(this._scriptProcessorNode),this._scriptProcessorNode.connect(this._audioContext.destination);let s=!1,i=0;this._scriptProcessorNode.onaudioprocess=n=>{const a=oe.fromAudioBuffer(n.inputBuffer,i);i+=n.inputBuffer.duration;for(const o of a){if(!s){s=!0;const d=this._connectedTrack.output._muxer;d.firstMediaStreamTimestamp===null?d.firstMediaStreamTimestamp=performance.now()/1e3:this._timestampOffset=performance.now()/1e3-d.firstMediaStreamTimestamp}if(this._encoder.getQueueSize()>=4){o.close();continue}this._encoder.add(o,!0).catch(d=>{this._audioContext.suspend(),this._promiseWithResolvers.reject(d)})}}}}async _flushAndClose(e){this._abortController&&(this._abortController.abort(),this._abortController=null),this._audioContext&&(g(this._scriptProcessorNode),this._scriptProcessorNode.disconnect(),await this._audioContext.suspend()),await this._encoder.flushAndClose(e)}}class Jn extends Ut{constructor(e){if(super(),this._connectedTrack=null,!st.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${st.join(", ")}.`);this._codec=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ea=["video","audio","subtitle"],pt=r=>{if(!r||typeof r!="object")throw new TypeError("metadata must be an object.");if(r.languageCode!==void 0&&!Rt(r.languageCode))throw new TypeError("metadata.languageCode must be a three-letter, ISO 639-2/T language code.")};class ta{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new Me,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof Jr))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof At))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof ss))throw new TypeError("source must be a VideoSource.");if(pt(t),t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&t.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(t.frameRate!==void 0&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive number.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof is))throw new TypeError("source must be an AudioSource.");pt(t),this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof Jn))throw new TypeError("source must be a SubtitleSource.");pt(t),this._addTrack("subtitle",e,t)}_addTrack(e,t,s){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(t._connectedTrack)throw new Error("Source is already used for a track.");const i=this.format.getSupportedTrackCounts(),n=this._tracks.reduce((u,l)=>u+(l.type===e?1:0),0),a=i[e].max;if(n===a)throw new Error(a===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track${a===1?"":"s"}.`);const o=i.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const d={id:this._tracks.length+1,output:this,type:e,source:t,metadata:s};if(d.type==="video"){const u=this.format.getSupportedVideoCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(d.source._codec));if(!u.includes(d.source._codec))throw new Error(`Codec '${d.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${u.map(l=>`'${l}'`).join(", ")}.`+this.format._codecUnsupportedHint(d.source._codec))}else if(d.type==="audio"){const u=this.format.getSupportedAudioCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(d.source._codec));if(!u.includes(d.source._codec))throw new Error(`Codec '${d.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${u.map(l=>`'${l}'`).join(", ")}.`+this.format._codecUnsupportedHint(d.source._codec))}else if(d.type==="subtitle"){const u=this.format.getSupportedSubtitleCodecs();if(u.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(d.source._codec));if(!u.includes(d.source._codec))throw new Error(`Codec '${d.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${u.map(l=>`'${l}'`).join(", ")}.`+this.format._codecUnsupportedHint(d.source._codec))}this._tracks.push(d),t._connectedTrack=d}async start(){const e=this.format.getSupportedTrackCounts();for(const s of ea){const i=this._tracks.reduce((a,o)=>a+(o.type===s?1:0),0),n=e[s].min;if(i<n)throw new Error(n===e[s].max?`${this.format._name} requires exactly ${n} ${s} track${n===1?"":"s"}.`:`${this.format._name} requires at least ${n} ${s} track${n===1?"":"s"}.`)}const t=e.total.min;if(this._tracks.length<t)throw new Error(t===e.total.max?`${this.format._name} requires exactly ${t} track${t===1?"":"s"}.`:`${this.format._name} requires at least ${t} track${t===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const s=await this._mutex.acquire();await this._muxer.start();const i=this._tracks.map(n=>n.source._start());await Promise.all(i),s()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),t=this._tracks.map(s=>s.source._flushOrWaitForOngoingClose(!0));await Promise.all(t),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),t=this._tracks.map(s=>s.source._flushOrWaitForOngoingClose(!1));await Promise.all(t),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ns{constructor(){this._sizePromise=null,this.onread=null}getSize(){return this._sizePromise??(this._sizePromise=this._retrieveSize())}}class ra extends ns{constructor(e){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");super(),this._blob=e}async _read(e,t){const i=await this._blob.slice(e,t).arrayBuffer();return new Uint8Array(i)}async _retrieveSize(){return this._blob.size}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class sa extends Xe{constructor(e){super(e),this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.fragments=[],this.currentFragment=null,this.fragmentLookupMutex=new Me,this.metadataReader=new yt(e._mainReader),this.chunkReader=new yt(new Ye(e.source,64*2**20))}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(s=>s.computeDuration()));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(t=>t.inputTrack.getCodecParameterString()));return qr({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(t=>{var s;return((s=t.info)==null?void 0:s.type)==="video"}),hasAudio:this.tracks.some(t=>{var s;return((s=t.info)==null?void 0:s.type)==="audio"}),codecStrings:e.filter(Boolean)})}readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{const e=await this.metadataReader.reader.source.getSize();for(;this.metadataReader.pos<e;){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Be);const t=this.metadataReader.pos,s=this.metadataReader.readBoxHeader();if(s.name==="ftyp"){const i=this.metadataReader.readAscii(4);this.isQuickTime=i==="qt  "}else if(s.name==="moov"){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+s.contentSize),this.readContiguousBoxes(s.contentSize);for(const i of this.tracks){const n=i.editListPreviousSegmentDurations/this.movieTimescale;i.editListOffset-=Math.round(n*i.timescale)}break}this.metadataReader.pos=t+s.totalSize}if(this.isFragmented){await this.metadataReader.reader.loadRange(e-4,e),this.metadataReader.pos=e-4;const t=this.metadataReader.readU32(),s=e-t;if(s>=0&&s<e){await this.metadataReader.reader.loadRange(s,e),this.metadataReader.pos=s;const i=this.metadataReader.readBoxHeader();i.name==="mfra"&&this.readContiguousBoxes(i.contentSize)}}})())}getSampleTableForTrack(e){var i,n;if(e.sampleTable)return e.sampleTable;const t={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};if(e.sampleTable=t,this.metadataReader.pos=e.sampleTableByteOffset,this.currentTrack=e,this.traverseBox(),this.currentTrack=null,((i=e.info)==null?void 0:i.type)==="audio"&&e.info.codec&&G.includes(e.info.codec)&&t.sampleCompositionTimeOffsets.length===0){g(((n=e.info)==null?void 0:n.type)==="audio");const a=pe(e.info.codec),o=[],d=[];for(let u=0;u<t.sampleToChunk.length;u++){const l=t.sampleToChunk[u],f=t.sampleToChunk[u+1],c=(f?f.startChunkIndex:t.chunkOffsets.length)-l.startChunkIndex;for(let m=0;m<c;m++){const h=l.startSampleIndex+m*l.samplesPerChunk,p=h+l.samplesPerChunk,k=D(t.sampleTimingEntries,h,R=>R.startIndex),w=t.sampleTimingEntries[k],T=D(t.sampleTimingEntries,p,R=>R.startIndex),x=t.sampleTimingEntries[T],S=w.startDecodeTimestamp+(h-w.startIndex)*w.delta,y=x.startDecodeTimestamp+(p-x.startIndex)*x.delta-S,C=K(o);C&&C.delta===y?C.count++:o.push({startIndex:l.startChunkIndex+m,startDecodeTimestamp:S,count:1,delta:y});const I=l.samplesPerChunk*a.sampleSize*e.info.numberOfChannels;d.push(I)}l.startSampleIndex=l.startChunkIndex,l.samplesPerChunk=1}t.sampleTimingEntries=o,t.sampleSizes=d}if(t.sampleCompositionTimeOffsets.length>0){t.presentationTimestamps=[];for(const a of t.sampleTimingEntries)for(let o=0;o<a.count;o++)t.presentationTimestamps.push({presentationTimestamp:a.startDecodeTimestamp+o*a.delta,sampleIndex:a.startIndex+o});for(const a of t.sampleCompositionTimeOffsets)for(let o=0;o<a.count;o++){const d=a.startIndex+o,u=t.presentationTimestamps[d];u&&(u.presentationTimestamp+=a.offset)}t.presentationTimestamps.sort((a,o)=>a.presentationTimestamp-o.presentationTimestamp),t.presentationTimestampIndexMap=Array(t.presentationTimestamps.length).fill(-1);for(let a=0;a<t.presentationTimestamps.length;a++)t.presentationTimestampIndexMap[t.presentationTimestamps[a].sampleIndex]=a}return t}async readFragment(){const e=this.metadataReader.pos;await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Be);const t=this.metadataReader.readBoxHeader();g(t.name==="moof");const s=this.metadataReader.pos;await this.metadataReader.reader.loadRange(s,s+t.contentSize),this.metadataReader.pos=e,this.traverseBox();const i=$(this.fragments,e,a=>a.moofOffset);g(i!==-1);const n=this.fragments[i];g(n.moofOffset===e),this.metadataReader.reader.forgetRange(s,s+t.contentSize);for(const[a,o]of n.trackData){if(o.startTimestampIsFinal)continue;const d=this.tracks.find(m=>m.id===a);this.metadataReader.pos=0;let u=null,l=null;const f=D(d.fragments,e-1,m=>m.moofOffset);f!==-1&&(u=d.fragments[f],l=u,this.metadataReader.pos=u.moofOffset+u.moofSize);let c=this.metadataReader.pos===0;for(;this.metadataReader.pos<e;){if(u!=null&&u.nextFragment)u=u.nextFragment,this.metadataReader.pos=u.moofOffset+u.moofSize;else{await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Be);const m=this.metadataReader.pos,h=this.metadataReader.readBoxHeader();if(h.name==="moof"){const p=$(this.fragments,m,w=>w.moofOffset);let k;p===-1?(this.metadataReader.pos=m,k=await this.readFragment()):k=this.fragments[p],u&&(u.nextFragment=k),u=k,c&&(k.isKnownToBeFirstFragment=!0,c=!1)}this.metadataReader.pos=m+h.totalSize}u&&u.trackData.has(a)&&(l=u)}if(l){const m=l.trackData.get(a);g(m.startTimestampIsFinal),mr(o,m.endTimestamp)}o.startTimestampIsFinal=!0}return n}readContiguousBoxes(e){const t=this.metadataReader.pos;for(;this.metadataReader.pos-t<=e-rt;)this.traverseBox()}traverseBox(){var i,n,a,o,d,u,l,f;const e=this.metadataReader.pos,t=this.metadataReader.readBoxHeader(),s=e+t.totalSize;switch(t.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":this.readContiguousBoxes(t.contentSize);break;case"mvhd":{const c=this.metadataReader.readU8();this.metadataReader.pos+=3,c===1?(this.metadataReader.pos+=16,this.movieTimescale=this.metadataReader.readU32(),this.movieDurationInTimescale=this.metadataReader.readU64()):(this.metadataReader.pos+=8,this.movieTimescale=this.metadataReader.readU32(),this.movieDurationInTimescale=this.metadataReader.readU32())}break;case"trak":{const c={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,languageCode:fe,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[],fragmentsWithKeyFrame:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=c,this.readContiguousBoxes(t.contentSize),c.id!==-1&&c.timescale!==-1&&c.info!==null){if(c.info.type==="video"&&c.info.width!==-1){const m=c;c.inputTrack=new Ot(new ia(m)),this.tracks.push(c)}else if(c.info.type==="audio"&&c.info.numberOfChannels!==-1){const m=c;c.inputTrack=new ge(new na(m)),this.tracks.push(c)}}this.currentTrack=null}break;case"tkhd":{const c=this.currentTrack;g(c);const m=this.metadataReader.readU8();if(!((this.metadataReader.readU24()&1)!==0))break;if(m===0)this.metadataReader.pos+=8,c.id=this.metadataReader.readU32(),this.metadataReader.pos+=4,c.durationInMovieTimescale=this.metadataReader.readU32();else if(m===1)this.metadataReader.pos+=16,c.id=this.metadataReader.readU32(),this.metadataReader.pos+=4,c.durationInMovieTimescale=this.metadataReader.readU64();else throw new Error(`Incorrect track header version ${m}.`);this.metadataReader.pos+=2*4+2+2+2+2;const k=[this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_2_30(),this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_2_30(),this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_16_16(),this.metadataReader.readFixed_2_30()],w=gr(Ss(da(k),90));g(w===0||w===90||w===180||w===270),c.rotation=w}break;case"elst":{const c=this.currentTrack;g(c);const m=this.metadataReader.readU8();this.metadataReader.pos+=3;let h=!1,p=0;const k=this.metadataReader.readU32();for(let w=0;w<k;w++){const T=m===1?this.metadataReader.readU64():this.metadataReader.readU32(),x=m===1?this.metadataReader.readI64():this.metadataReader.readI32(),S=this.metadataReader.readFixed_16_16();if(T!==0){if(h){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(x===-1){p+=T;continue}if(S!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}c.editListPreviousSegmentDurations=p,c.editListOffset=x,h=!0}}}break;case"mdhd":{const c=this.currentTrack;g(c);const m=this.metadataReader.readU8();this.metadataReader.pos+=3,m===0?(this.metadataReader.pos+=8,c.timescale=this.metadataReader.readU32(),c.durationInMediaTimescale=this.metadataReader.readU32()):m===1&&(this.metadataReader.pos+=16,c.timescale=this.metadataReader.readU32(),c.durationInMediaTimescale=this.metadataReader.readU64());let h=this.metadataReader.readU16();if(h>0){c.languageCode="";for(let p=0;p<3;p++)c.languageCode=String.fromCharCode(96+(h&31))+c.languageCode,h>>=5;Rt(c.languageCode)||(c.languageCode=fe)}}break;case"hdlr":{const c=this.currentTrack;g(c),this.metadataReader.pos+=8;const m=this.metadataReader.readAscii(4);m==="vide"?c.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:m==="soun"&&(c.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const c=this.currentTrack;g(c),c.sampleTableByteOffset=e,this.readContiguousBoxes(t.contentSize)}break;case"stsd":{const c=this.currentTrack;if(g(c),c.info===null||c.sampleTable)break;const m=this.metadataReader.readU8();this.metadataReader.pos+=3;const h=this.metadataReader.readU32();for(let p=0;p<h;p++){const k=this.metadataReader.pos,w=this.metadataReader.readBoxHeader(),T=w.name.toLowerCase();if(c.info.type==="video")T==="avc1"?c.info.codec="avc":T==="hvc1"||T==="hev1"?c.info.codec="hevc":T==="vp08"?c.info.codec="vp8":T==="vp09"?c.info.codec="vp9":T==="av01"?c.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${w.name}').`),this.metadataReader.pos+=6*1+2+2+2+3*4,c.info.width=this.metadataReader.readU16(),c.info.height=this.metadataReader.readU16(),this.metadataReader.pos+=50,this.readContiguousBoxes(k+w.totalSize-this.metadataReader.pos);else{T==="mp4a"||(T==="opus"?c.info.codec="opus":T==="flac"?c.info.codec="flac":T==="twos"||T==="sowt"||T==="raw "||T==="in24"||T==="in32"||T==="fl32"||T==="fl64"||T==="lpcm"||T==="ipcm"||T==="fpcm"||(T==="ulaw"?c.info.codec="ulaw":T==="alaw"?c.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${w.name}').`))),this.metadataReader.pos+=6*1+2;const x=this.metadataReader.readU16();this.metadataReader.pos+=3*2;let S=this.metadataReader.readU16(),b=this.metadataReader.readU16();this.metadataReader.pos+=2*2;let y=this.metadataReader.readU32()/65536;if(m===0&&x>0){if(x===1)this.metadataReader.pos+=4,b=8*this.metadataReader.readU32(),this.metadataReader.pos+=2*4;else if(x===2){this.metadataReader.pos+=4,y=this.metadataReader.readF64(),S=this.metadataReader.readU32(),this.metadataReader.pos+=4,b=this.metadataReader.readU32();const C=this.metadataReader.readU32();if(this.metadataReader.pos+=2*4,T==="lpcm"){const I=b+7>>3,R=!!(C&1),_=!!(C&2),F=C&4?-1:0;b>0&&b<=64&&(R?b===32&&(c.info.codec=_?"pcm-f32be":"pcm-f32"):F&1<<I-1?I===1?c.info.codec="pcm-s8":I===2?c.info.codec=_?"pcm-s16be":"pcm-s16":I===3?c.info.codec=_?"pcm-s24be":"pcm-s24":I===4&&(c.info.codec=_?"pcm-s32be":"pcm-s32"):I===1&&(c.info.codec="pcm-u8")),c.info.codec===null&&console.warn("Unsupported PCM format.")}}}c.info.numberOfChannels=S,c.info.sampleRate=y,T==="twos"?b===8?c.info.codec="pcm-s8":b===16?c.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${b} for codec 'twos'.`),c.info.codec=null):T==="sowt"?b===8?c.info.codec="pcm-s8":b===16?c.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${b} for codec 'sowt'.`),c.info.codec=null):T==="raw "?c.info.codec="pcm-u8":T==="in24"?c.info.codec="pcm-s24be":T==="in32"?c.info.codec="pcm-s32be":T==="fl32"?c.info.codec="pcm-f32be":T==="fl64"?c.info.codec="pcm-f64be":T==="ipcm"?c.info.codec="pcm-s16be":T==="fpcm"&&(c.info.codec="pcm-f32be"),this.readContiguousBoxes(k+w.totalSize-this.metadataReader.pos)}}}break;case"avcC":{const c=this.currentTrack;g(c&&c.info),c.info.codecDescription=this.metadataReader.readBytes(t.contentSize)}break;case"hvcC":{const c=this.currentTrack;g(c&&c.info),c.info.codecDescription=this.metadataReader.readBytes(t.contentSize)}break;case"vpcC":{const c=this.currentTrack;g(c&&((i=c.info)==null?void 0:i.type)==="video"),this.metadataReader.pos+=4;const m=this.metadataReader.readU8(),h=this.metadataReader.readU8(),p=this.metadataReader.readU8(),k=p>>4,w=p>>1&7,T=p&1,x=this.metadataReader.readU8(),S=this.metadataReader.readU8(),b=this.metadataReader.readU8();c.info.vp9CodecInfo={profile:m,level:h,bitDepth:k,chromaSubsampling:w,videoFullRangeFlag:T,colourPrimaries:x,transferCharacteristics:S,matrixCoefficients:b}}break;case"av1C":{const c=this.currentTrack;g(c&&((n=c.info)==null?void 0:n.type)==="video"),this.metadataReader.pos+=1;const m=this.metadataReader.readU8(),h=m>>5,p=m&31,k=this.metadataReader.readU8(),w=k>>7,T=k>>6&1,x=k>>5&1,S=k>>4&1,b=k>>3&1,y=k>>2&1,C=k&3,I=h==2&&T?x?12:10:T?10:8;c.info.av1CodecInfo={profile:h,level:p,tier:w,bitDepth:I,monochrome:S,chromaSubsamplingX:b,chromaSubsamplingY:y,chromaSamplePosition:C}}break;case"colr":{const c=this.currentTrack;if(g(c&&((a=c.info)==null?void 0:a.type)==="video"),this.metadataReader.readAscii(4)!=="nclx")break;const h=this.metadataReader.readU16(),p=this.metadataReader.readU16(),k=this.metadataReader.readU16(),w=!!(this.metadataReader.readU8()&128);c.info.colorSpace={primaries:kr[h],transfer:wr[p],matrix:Tr[k],fullRange:w}}break;case"wave":this.readContiguousBoxes(t.contentSize);break;case"esds":{const c=this.currentTrack;g(c&&((o=c.info)==null?void 0:o.type)==="audio"),this.metadataReader.pos+=4;const m=this.metadataReader.readU8();g(m===3),this.metadataReader.readIsomVariableInteger(),this.metadataReader.pos+=2;const h=this.metadataReader.readU8(),p=(h&128)!==0,k=(h&64)!==0,w=(h&32)!==0;if(p&&(this.metadataReader.pos+=2),k){const y=this.metadataReader.readU8();this.metadataReader.pos+=y}w&&(this.metadataReader.pos+=2);const T=this.metadataReader.readU8();g(T===4);const x=this.metadataReader.readIsomVariableInteger(),S=this.metadataReader.pos,b=this.metadataReader.readU8();if(b===64||b===103?(c.info.codec="aac",c.info.aacCodecInfo={isMpeg2:b===103}):b===105||b===107?c.info.codec="mp3":b===221?c.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${b}) - discarding track.`),this.metadataReader.pos+=12,x>this.metadataReader.pos-S){const y=this.metadataReader.readU8();g(y===5);const C=this.metadataReader.readIsomVariableInteger();if(c.info.codecDescription=this.metadataReader.readBytes(C),c.info.codec==="aac"){const I=Ir(c.info.codecDescription);I.numberOfChannels!==null&&(c.info.numberOfChannels=I.numberOfChannels),I.sampleRate!==null&&(c.info.sampleRate=I.sampleRate)}}}break;case"enda":{const c=this.currentTrack;g(c&&((d=c.info)==null?void 0:d.type)==="audio"),this.metadataReader.readU16()&255&&(c.info.codec==="pcm-s16be"?c.info.codec="pcm-s16":c.info.codec==="pcm-s24be"?c.info.codec="pcm-s24":c.info.codec==="pcm-s32be"?c.info.codec="pcm-s32":c.info.codec==="pcm-f32be"?c.info.codec="pcm-f32":c.info.codec==="pcm-f64be"&&(c.info.codec="pcm-f64"))}break;case"pcmC":{const c=this.currentTrack;g(c&&((u=c.info)==null?void 0:u.type)==="audio"),this.metadataReader.pos+=4;const h=!!(this.metadataReader.readU8()&1),p=this.metadataReader.readU8();c.info.codec==="pcm-s16be"?h?p===16?c.info.codec="pcm-s16":p===24?c.info.codec="pcm-s24":p===32?c.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${p}.`),c.info.codec=null):p===16?c.info.codec="pcm-s16be":p===24?c.info.codec="pcm-s24be":p===32?c.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${p}.`),c.info.codec=null):c.info.codec==="pcm-f32be"&&(h?p===32?c.info.codec="pcm-f32":p===64?c.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${p}.`),c.info.codec=null):p===32?c.info.codec="pcm-f32be":p===64?c.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${p}.`),c.info.codec=null));break}case"dOps":{const c=this.currentTrack;g(c&&((l=c.info)==null?void 0:l.type)==="audio"),this.metadataReader.pos+=1;const m=this.metadataReader.readU8(),h=this.metadataReader.readU16(),p=this.metadataReader.readU32(),k=this.metadataReader.readI16(),w=this.metadataReader.readU8();let T;w!==0?T=this.metadataReader.readBytes(2+m):T=new Uint8Array(0);const x=new Uint8Array(19+T.byteLength),S=new DataView(x.buffer);S.setUint32(0,1332770163,!1),S.setUint32(4,1214603620,!1),S.setUint8(8,1),S.setUint8(9,m),S.setUint16(10,h,!0),S.setUint32(12,p,!0),S.setInt16(16,k,!0),S.setUint8(18,w),x.set(T,19),c.info.codecDescription=x,c.info.numberOfChannels=m,c.info.sampleRate=p}break;case"dfLa":{const c=this.currentTrack;g(c&&((f=c.info)==null?void 0:f.type)==="audio"),this.metadataReader.pos+=4;const m=127,h=128,p=this.metadataReader.pos;for(;this.metadataReader.pos<s;){const S=this.metadataReader.readU8(),b=this.metadataReader.readU24();if((S&m)===0){this.metadataReader.pos+=10;const C=this.metadataReader.readU32(),I=C>>>12,R=(C>>9&7)+1;c.info.sampleRate=I,c.info.numberOfChannels=R,this.metadataReader.pos+=20}else this.metadataReader.pos+=b;if(S&h)break}const k=this.metadataReader.pos;this.metadataReader.pos=p;const w=this.metadataReader.readBytes(k-p),T=new Uint8Array(4+w.byteLength);new DataView(T.buffer).setUint32(0,1716281667,!1),T.set(w,4),c.info.codecDescription=T}break;case"stts":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32();let h=0,p=0;for(let k=0;k<m;k++){const w=this.metadataReader.readU32(),T=this.metadataReader.readU32();c.sampleTable.sampleTimingEntries.push({startIndex:h,startDecodeTimestamp:p,count:w,delta:T}),h+=w,p+=w*T}}break;case"ctts":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32();let h=0;for(let p=0;p<m;p++){const k=this.metadataReader.readU32(),w=this.metadataReader.readI32();c.sampleTable.sampleCompositionTimeOffsets.push({startIndex:h,count:k,offset:w}),h+=k}}break;case"stsz":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32(),h=this.metadataReader.readU32();if(m===0)for(let p=0;p<h;p++){const k=this.metadataReader.readU32();c.sampleTable.sampleSizes.push(k)}else c.sampleTable.sampleSizes.push(m)}break;case"stz2":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4,this.metadataReader.pos+=3;const m=this.metadataReader.readU8(),h=this.metadataReader.readU32(),p=this.metadataReader.readBytes(Math.ceil(h*m/8)),k=new Z(p);for(let w=0;w<h;w++){const T=k.readBits(m);c.sampleTable.sampleSizes.push(T)}}break;case"stss":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4,c.sampleTable.keySampleIndices=[];const m=this.metadataReader.readU32();for(let h=0;h<m;h++){const p=this.metadataReader.readU32()-1;c.sampleTable.keySampleIndices.push(p)}c.sampleTable.keySampleIndices[0]!==0&&c.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32();for(let p=0;p<m;p++){const k=this.metadataReader.readU32()-1,w=this.metadataReader.readU32(),T=this.metadataReader.readU32();c.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:k,samplesPerChunk:w,sampleDescriptionIndex:T})}let h=0;for(let p=0;p<c.sampleTable.sampleToChunk.length;p++)if(c.sampleTable.sampleToChunk[p].startSampleIndex=h,p<c.sampleTable.sampleToChunk.length-1){const w=c.sampleTable.sampleToChunk[p+1].startChunkIndex-c.sampleTable.sampleToChunk[p].startChunkIndex;h+=w*c.sampleTable.sampleToChunk[p].samplesPerChunk}}break;case"stco":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32();for(let h=0;h<m;h++){const p=this.metadataReader.readU32();c.sampleTable.chunkOffsets.push(p)}}break;case"co64":{const c=this.currentTrack;if(g(c),!c.sampleTable)break;this.metadataReader.pos+=4;const m=this.metadataReader.readU32();for(let h=0;h<m;h++){const p=this.metadataReader.readU64();c.sampleTable.chunkOffsets.push(p)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(t.contentSize);break;case"mehd":{const c=this.metadataReader.readU8();this.metadataReader.pos+=3;const m=c===1?this.metadataReader.readU64():this.metadataReader.readU32();this.movieDurationInTimescale=m}break;case"trex":{this.metadataReader.pos+=4;const c=this.metadataReader.readU32(),m=this.metadataReader.readU32(),h=this.metadataReader.readU32(),p=this.metadataReader.readU32(),k=this.metadataReader.readU32();this.fragmentTrackDefaults.push({trackId:c,defaultSampleDescriptionIndex:m,defaultSampleDuration:h,defaultSampleSize:p,defaultSampleFlags:k})}break;case"tfra":{const c=this.metadataReader.readU8();this.metadataReader.pos+=3;const m=this.metadataReader.readU32(),h=this.tracks.find(R=>R.id===m);if(!h)break;h.fragmentLookupTable=[];const p=this.metadataReader.readU32(),k=(p&48)>>4,w=(p&12)>>2,T=p&3,x=this.metadataReader,S=[x.readU8.bind(x),x.readU16.bind(x),x.readU24.bind(x),x.readU32.bind(x)],b=S[k],y=S[w],C=S[T],I=this.metadataReader.readU32();for(let R=0;R<I;R++){const _=c===1?this.metadataReader.readU64():this.metadataReader.readU32(),F=c===1?this.metadataReader.readU64():this.metadataReader.readU32();b(),y(),C(),h.fragmentLookupTable.push({timestamp:_,moofOffset:F})}}break;case"moof":{this.currentFragment={moofOffset:e,moofSize:t.totalSize,implicitBaseDataOffset:e,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null,isKnownToBeFirstFragment:!1},this.readContiguousBoxes(t.contentSize),Fe(this.fragments,this.currentFragment,c=>c.moofOffset);for(const[,c]of this.currentFragment.trackData){const m=c.samples[0],h=K(c.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,m.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,h.byteOffset+h.byteSize)}this.currentFragment=null}break;case"traf":if(g(this.currentFragment),this.readContiguousBoxes(t.contentSize),this.currentTrack){const c=this.currentFragment.trackData.get(this.currentTrack.id);if(c){Fe(this.currentTrack.fragments,this.currentFragment,p=>p.moofOffset),c.firstKeyFrameTimestamp!==null&&Fe(this.currentTrack.fragmentsWithKeyFrame,this.currentFragment,p=>p.moofOffset);const{currentFragmentState:h}=this.currentTrack;g(h),h.startTimestamp!==null&&(mr(c,h.startTimestamp),c.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{g(this.currentFragment),this.metadataReader.pos+=1;const c=this.metadataReader.readU24(),m=!!(c&1),h=!!(c&2),p=!!(c&8),k=!!(c&16),w=!!(c&32),T=!!(c&65536),x=!!(c&131072),S=this.metadataReader.readU32(),b=this.tracks.find(C=>C.id===S);if(!b)break;const y=this.fragmentTrackDefaults.find(C=>C.trackId===S);this.currentTrack=b,b.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:(y==null?void 0:y.defaultSampleDescriptionIndex)??null,defaultSampleDuration:(y==null?void 0:y.defaultSampleDuration)??null,defaultSampleSize:(y==null?void 0:y.defaultSampleSize)??null,defaultSampleFlags:(y==null?void 0:y.defaultSampleFlags)??null,startTimestamp:null},m?b.currentFragmentState.baseDataOffset=this.metadataReader.readU64():x&&(b.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),h&&(b.currentFragmentState.sampleDescriptionIndex=this.metadataReader.readU32()),p&&(b.currentFragmentState.defaultSampleDuration=this.metadataReader.readU32()),k&&(b.currentFragmentState.defaultSampleSize=this.metadataReader.readU32()),w&&(b.currentFragmentState.defaultSampleFlags=this.metadataReader.readU32()),T&&(b.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const c=this.currentTrack;if(!c)break;g(c.currentFragmentState);const m=this.metadataReader.readU8();this.metadataReader.pos+=3;const h=m===0?this.metadataReader.readU32():this.metadataReader.readU64();c.currentFragmentState.startTimestamp=h}break;case"trun":{const c=this.currentTrack;if(!c)break;if(g(this.currentFragment),g(c.currentFragmentState),this.currentFragment.trackData.has(c.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const m=this.metadataReader.readU8(),h=this.metadataReader.readU24(),p=!!(h&1),k=!!(h&4),w=!!(h&256),T=!!(h&512),x=!!(h&1024),S=!!(h&2048),b=this.metadataReader.readU32();let y=c.currentFragmentState.baseDataOffset;p&&(y+=this.metadataReader.readI32());let C=null;k&&(C=this.metadataReader.readU32());let I=y;if(b===0){this.currentFragment.implicitBaseDataOffset=I;break}let R=0;const _={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(c.id,_);for(let M=0;M<b;M++){let j;w?j=this.metadataReader.readU32():(g(c.currentFragmentState.defaultSampleDuration!==null),j=c.currentFragmentState.defaultSampleDuration);let q;T?q=this.metadataReader.readU32():(g(c.currentFragmentState.defaultSampleSize!==null),q=c.currentFragmentState.defaultSampleSize);let se;x?se=this.metadataReader.readU32():(g(c.currentFragmentState.defaultSampleFlags!==null),se=c.currentFragmentState.defaultSampleFlags),M===0&&C!==null&&(se=C);let Ce=0;S&&(m===0?Ce=this.metadataReader.readU32():Ce=this.metadataReader.readI32());const Ze=!(se&65536);_.samples.push({presentationTimestamp:R+Ce,duration:j,byteOffset:I,byteSize:q,isKeyFrame:Ze}),I+=q,R+=j}_.presentationTimestamps=_.samples.map((M,j)=>({presentationTimestamp:M.presentationTimestamp,sampleIndex:j})).sort((M,j)=>M.presentationTimestamp-j.presentationTimestamp);for(let M=0;M<_.presentationTimestamps.length;M++){const j=_.presentationTimestamps[M],q=_.samples[j.sampleIndex];if(_.firstKeyFrameTimestamp===null&&q.isKeyFrame&&(_.firstKeyFrameTimestamp=q.presentationTimestamp),M<_.presentationTimestamps.length-1){const se=_.presentationTimestamps[M+1];q.duration=se.presentationTimestamp-j.presentationTimestamp}}const F=_.samples[_.presentationTimestamps[0].sampleIndex],W=_.samples[K(_.presentationTimestamps).sampleIndex];_.startTimestamp=F.presentationTimestamp,_.endTimestamp=W.presentationTimestamp+W.duration,this.currentFragment.implicitBaseDataOffset=I}break}this.metadataReader.pos=s}}class as{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}async getFirstPacket(e){const t=await this.fetchPacketForSampleIndex(0,e);return t||!this.internalTrack.demuxer.isFragmented?t:this.performFragmentedLookup(()=>{const s=this.internalTrack.demuxer.fragments[0]??null;if(s!=null&&s.isKnownToBeFirstFragment){let i=s;for(;i;){if(i.trackData.get(this.internalTrack.id))return{fragmentIndex:$(this.internalTrack.fragments,i.moofOffset,a=>a.moofOffset),sampleIndex:0,correctSampleFound:!0};i=i.nextFragment}}return{fragmentIndex:-1,sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return Et(e*this.internalTrack.timescale,14)+this.internalTrack.editListOffset}async getPacket(e,t){const s=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=ur(i,s),a=await this.fetchPacketForSampleIndex(n,t);return!fr(i)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(s),s,s,t)}async getNextPacket(e,t){const s=this.packetToSampleIndex.get(e);if(s!==void 0)return this.fetchPacketForSampleIndex(s+1,t);const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const n=i.fragment.trackData.get(this.internalTrack.id),a=$(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return g(a!==-1),this.performFragmentedLookup(()=>{if(i.sampleIndex+1<n.samples.length)return{fragmentIndex:a,sampleIndex:i.sampleIndex+1,correctSampleFound:!0};{let o=i.fragment;for(;o.nextFragment;)if(o=o.nextFragment,o.trackData.get(this.internalTrack.id)){const u=$(this.internalTrack.fragments,o.moofOffset,l=>l.moofOffset);return g(u!==-1),{fragmentIndex:u,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,t)}async getKeyPacket(e,t){const s=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=ur(i,s),a=n===-1?-1:oa(i,n),o=await this.fetchPacketForSampleIndex(a,t);return!fr(i)||!this.internalTrack.demuxer.isFragmented?o:this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(s),s,s,t)}async getNextKeyPacket(e,t){const s=this.packetToSampleIndex.get(e);if(s!==void 0){const o=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),d=ca(o,s);return this.fetchPacketForSampleIndex(d,t)}const i=this.packetToFragmentLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");const n=i.fragment.trackData.get(this.internalTrack.id),a=$(this.internalTrack.fragments,i.fragment.moofOffset,o=>o.moofOffset);return g(a!==-1),this.performFragmentedLookup(()=>{const o=n.samples.findIndex((d,u)=>d.isKeyFrame&&u>i.sampleIndex);if(o!==-1)return{fragmentIndex:a,sampleIndex:o,correctSampleFound:!0};{let d=i.fragment;for(;d.nextFragment;){d=d.nextFragment;const u=d.trackData.get(this.internalTrack.id);if(u&&u.firstKeyFrameTimestamp!==null){const l=$(this.internalTrack.fragments,d.moofOffset,c=>c.moofOffset);g(l!==-1);const f=u.samples.findIndex(c=>c.isKeyFrame);return g(f!==-1),{fragmentIndex:l,sampleIndex:f,correctSampleFound:!0}}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,t)}async fetchPacketForSampleIndex(e,t){if(e===-1)return null;const s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=aa(s,e);if(!i)return null;let n;t.metadataOnly?n=ce:(await this.internalTrack.demuxer.chunkReader.reader.loadRange(i.chunkOffset,i.chunkOffset+i.chunkSize),this.internalTrack.demuxer.chunkReader.pos=i.sampleOffset,n=this.internalTrack.demuxer.chunkReader.readBytes(i.sampleSize));const a=(i.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=i.duration/this.internalTrack.timescale,d=new N(n,i.isKeyFrame?"key":"delta",a,o,e,i.sampleSize);return this.packetToSampleIndex.set(d,e),d}async fetchPacketInFragment(e,t,s){if(t===-1)return null;const n=e.trackData.get(this.internalTrack.id).samples[t];g(n);let a;s.metadataOnly?a=ce:(await this.internalTrack.demuxer.chunkReader.reader.loadRange(e.dataStart,e.dataEnd),this.internalTrack.demuxer.chunkReader.pos=n.byteOffset,a=this.internalTrack.demuxer.chunkReader.readBytes(n.byteSize));const o=(n.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,d=n.duration/this.internalTrack.timescale,u=new N(a,n.isKeyFrame?"key":"delta",o,d,e.moofOffset+t,n.byteSize);return this.packetToFragmentLocation.set(u,{fragment:e,sampleIndex:t}),u}findSampleInFragmentsForTimestamp(e){const t=D(this.internalTrack.fragments,e,n=>n.trackData.get(this.internalTrack.id).startTimestamp);let s=-1,i=!1;if(t!==-1){const a=this.internalTrack.fragments[t].trackData.get(this.internalTrack.id),o=D(a.presentationTimestamps,e,d=>d.presentationTimestamp);g(o!==-1),s=a.presentationTimestamps[o].sampleIndex,i=e<a.endTimestamp}return{fragmentIndex:t,sampleIndex:s,correctSampleFound:i}}findKeySampleInFragmentsForTimestamp(e){const t=D(this.internalTrack.fragmentsWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp);let s=-1,i=-1,n=!1;if(t!==-1){const a=this.internalTrack.fragmentsWithKeyFrame[t];s=$(this.internalTrack.fragments,a.moofOffset,l=>l.moofOffset),g(s!==-1);const o=a.trackData.get(this.internalTrack.id),d=yr(o.presentationTimestamps,l=>o.samples[l.sampleIndex].isKeyFrame&&l.presentationTimestamp<=e);g(d!==-1),i=o.presentationTimestamps[d].sampleIndex,n=e<o.endTimestamp}return{fragmentIndex:s,sampleIndex:i,correctSampleFound:n}}async performFragmentedLookup(e,t,s,i){const n=this.internalTrack.demuxer,a=await n.fragmentLookupMutex.acquire();try{const{fragmentIndex:o,sampleIndex:d,correctSampleFound:u}=e();if(u){const S=this.internalTrack.fragments[o];return this.fetchPacketInFragment(S,d,i)}const l=n.metadataReader,f=await l.reader.source.getSize();let c=null,m=o,h=d;const p=this.internalTrack.fragmentLookupTable?D(this.internalTrack.fragmentLookupTable,t,S=>S.timestamp):-1,k=p!==-1?this.internalTrack.fragmentLookupTable[p]:null;let w=!1;if(o===-1)l.pos=(k==null?void 0:k.moofOffset)??0,w=l.pos===0;else{const S=this.internalTrack.fragments[o];!k||S.moofOffset>=k.moofOffset?(l.pos=S.moofOffset+S.moofSize,c=S):l.pos=k.moofOffset}for(;l.pos<f;){if(c){const y=c.trackData.get(this.internalTrack.id);if(y&&y.startTimestamp>s)break;if(c.nextFragment){l.pos=c.nextFragment.moofOffset+c.nextFragment.moofSize,c=c.nextFragment;continue}}await l.reader.loadRange(l.pos,l.pos+Be);const S=l.pos,b=l.readBoxHeader();if(b.name==="moof"){const y=$(n.fragments,S,F=>F.moofOffset);let C;y===-1?(l.pos=S,C=await n.readFragment()):C=n.fragments[y],c&&(c.nextFragment=C),c=C,w&&(C.isKnownToBeFirstFragment=!0,w=!1);const{fragmentIndex:I,sampleIndex:R,correctSampleFound:_}=e();if(_){const F=this.internalTrack.fragments[I];return this.fetchPacketInFragment(F,R,i)}I!==-1&&(m=I,h=R)}l.pos=S+b.totalSize}let T=null;const x=m!==-1?this.internalTrack.fragments[m]:null;if(x&&(T=await this.fetchPacketInFragment(x,h,i)),!T&&k&&(!x||x.moofOffset<k.moofOffset)){const S=this.internalTrack.fragmentLookupTable[p-1],b=(S==null?void 0:S.timestamp)??-1/0;return this.performFragmentedLookup(e,b,s,i)}return T}finally{a()}}}class ia extends as{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){var e,t,s,i;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(t=this.internalTrack.info.colorSpace)==null?void 0:t.transfer,matrix:(s=this.internalTrack.info.colorSpace)==null?void 0:s.matrix,fullRange:(i=this.internalTrack.info.colorSpace)==null?void 0:i.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&Ar(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&Or(e.data)}return{codec:vr(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class na extends as{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:_r(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const ur=(r,e)=>{if(r.presentationTimestamps){const t=D(r.presentationTimestamps,e,s=>s.presentationTimestamp);return t===-1?-1:r.presentationTimestamps[t].sampleIndex}else{const t=D(r.sampleTimingEntries,e,i=>i.startDecodeTimestamp);if(t===-1)return-1;const s=r.sampleTimingEntries[t];return s.startIndex+Math.min(Math.floor((e-s.startDecodeTimestamp)/s.delta),s.count-1)}},aa=(r,e)=>{const t=D(r.sampleTimingEntries,e,w=>w.startIndex),s=r.sampleTimingEntries[t];if(!s||s.startIndex+s.count<=e)return null;let n=s.startDecodeTimestamp+(e-s.startIndex)*s.delta;const a=D(r.sampleCompositionTimeOffsets,e,w=>w.startIndex),o=r.sampleCompositionTimeOffsets[a];o&&e-o.startIndex<o.count&&(n+=o.offset);const d=r.sampleSizes[Math.min(e,r.sampleSizes.length-1)],u=D(r.sampleToChunk,e,w=>w.startSampleIndex),l=r.sampleToChunk[u];g(l);const f=l.startChunkIndex+Math.floor((e-l.startSampleIndex)/l.samplesPerChunk),c=r.chunkOffsets[f],m=l.startSampleIndex+(f-l.startChunkIndex)*l.samplesPerChunk;let h=0,p=c;if(r.sampleSizes.length===1)p+=d*(e-m),h+=d*l.samplesPerChunk;else for(let w=m;w<m+l.samplesPerChunk;w++){const T=r.sampleSizes[w];w<e&&(p+=T),h+=T}let k=s.delta;if(r.presentationTimestamps){const w=r.presentationTimestampIndexMap[e];g(w!==void 0),w<r.presentationTimestamps.length-1&&(k=r.presentationTimestamps[w+1].presentationTimestamp-n)}return{presentationTimestamp:n,duration:k,sampleOffset:p,sampleSize:d,chunkOffset:c,chunkSize:h,isKeyFrame:r.keySampleIndices?$(r.keySampleIndices,e,w=>w)!==-1:!0}},oa=(r,e)=>{if(!r.keySampleIndices)return e;const t=D(r.keySampleIndices,e,s=>s);return r.keySampleIndices[t]??-1},ca=(r,e)=>{if(!r.keySampleIndices)return e+1;const t=D(r.keySampleIndices,e,s=>s);return r.keySampleIndices[t+1]??-1},mr=(r,e)=>{r.startTimestamp+=e,r.endTimestamp+=e;for(const t of r.samples)t.presentationTimestamp+=e;for(const t of r.presentationTimestamps)t.presentationTimestamp+=e},da=r=>{const[e,,,t]=r,s=Math.hypot(e,t),i=e/s,n=t/s;return-Math.atan2(n,i)*(180/Math.PI)},fr=r=>r.sampleSizes.length===0;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var ne;(function(r){r[r.None=0]="None",r[r.Xiph=1]="Xiph",r[r.FixedSize=2]="FixedSize",r[r.Ebml=3]="Ebml"})(ne||(ne={}));const gt=[{id:P.SeekHead,flag:"seekHeadSeen"},{id:P.Info,flag:"infoSeen"},{id:P.Tracks,flag:"tracksSeen"},{id:P.Cues,flag:"cuesSeen"}];class la extends Xe{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentCueTime=null,this.isWebM=!1,this.metadataReader=new Pt(e._mainReader),this.clusterReader=new Pt(new Ye(e.source,64*2**20))}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(s=>s.computeDuration()));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(t=>t.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),t=await Promise.all(e.map(s=>s.getCodecParameterString()));return bn({isWebM:this.isWebM,hasVideo:this.segments.some(s=>s.tracks.some(i=>{var n;return((n=i.info)==null?void 0:n.type)==="video"})),hasAudio:this.segments.some(s=>s.tracks.some(i=>{var n;return((n=i.info)==null?void 0:n.type)==="audio"})),codecStrings:t.filter(Boolean)})}readMetadata(){return this.readMetadataPromise??(this.readMetadataPromise=(async()=>{this.metadataReader.pos=0;const e=await this.input.source.getSize();for(;this.metadataReader.pos<=e-Ct;){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Ae);const t=this.metadataReader.readElementHeader(),s=t.id;let i=t.size;const n=this.metadataReader.pos;if(s===P.EBML)_e(i),await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+i),this.readContiguousElements(this.metadataReader,i);else if(s===P.Segment){if(await this.readSegment(i),i===null)break}else if(s===P.Cluster){i===null&&(i=(await this.clusterReader.searchForNextElementId(xt,e)??e)-n);const a=K(this.segments);a&&(a.elementEndPos=n+i)}_e(i),this.metadataReader.pos=n+i}})())}async readSegment(e){const t=this.metadataReader.pos;this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:t,elementEndPos:e===null?await this.input.source.getSize():t+e,clusterSeekStartPos:t,clusters:[],clusterLookupMutex:new Me},this.segments.push(this.currentSegment),await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+2**14);let s=!1;for(;this.metadataReader.pos<this.currentSegment.elementEndPos;){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Ae);const d=this.metadataReader.pos,{id:u,size:l}=this.metadataReader.readElementHeader(),f=this.metadataReader.pos,c=gt.findIndex(m=>m.id===u);if(c!==-1){const m=gt[c].flag;this.currentSegment[m]=!0,_e(l),await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+l),this.readContiguousElements(this.metadataReader,l)}else u===P.Cluster&&(s||(s=!0,this.currentSegment.clusterSeekStartPos=d));if(this.currentSegment.infoSeen&&this.currentSegment.tracksSeen&&this.currentSegment.cuesSeen)break;if(this.currentSegment.seekHeadSeen){let m=this.currentSegment.infoSeen,h=this.currentSegment.tracksSeen,p=this.currentSegment.cuesSeen;for(const k of this.currentSegment.seekEntries)k.id===P.Info?m=!0:k.id===P.Tracks?h=!0:k.id===P.Cues&&(p=!0);if(m&&h&&p)break}if(l===null)break;this.metadataReader.pos=f+l,s||(this.currentSegment.clusterSeekStartPos=this.metadataReader.pos)}for(const d of gt){if(this.currentSegment[d.flag])continue;const u=this.currentSegment.seekEntries.find(c=>c.id===d.id);if(!u)continue;this.metadataReader.pos=t+u.segmentPosition,await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+2**12);const{id:l,size:f}=this.metadataReader.readElementHeader();l===d.id&&(_e(f),this.currentSegment[d.flag]=!0,await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+f),this.readContiguousElements(this.metadataReader,f))}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6),this.currentSegment.tracks.sort((d,u)=>Number(u.isDefault)-Number(d.isDefault)),this.currentSegment.cuePoints.sort((d,u)=>d.clusterPosition-u.clusterPosition);const i=this.currentSegment.tracks.map(d=>d.id),n=new Set;let a=null,o=null;for(const d of this.currentSegment.cuePoints){if(d.clusterPosition!==a){for(const l of n)g(o),this.currentSegment.tracks.find(c=>c.id===l).cuePoints.push(o);for(const l of i)n.add(l)}if(o=d,!n.has(d.trackId))continue;this.currentSegment.tracks.find(l=>l.id===d.trackId).cuePoints.push(d),n.delete(d.trackId),a=d.clusterPosition}for(const d of n)g(o),this.currentSegment.tracks.find(l=>l.id===d).cuePoints.push(o);for(const d of this.currentSegment.tracks)d.cuePoints.sort((u,l)=>u.time-l.time);this.currentSegment=null}async readCluster(e){await this.metadataReader.reader.loadRange(this.metadataReader.pos,this.metadataReader.pos+Ae);const t=this.metadataReader.pos,s=this.metadataReader.readElementHeader(),i=s.id;let n=s.size;const a=this.metadataReader.pos;n===null&&(this.clusterReader.pos=a,n=(await this.clusterReader.searchForNextElementId(xt,e.elementEndPos)??e.elementEndPos)-a),g(i===P.Cluster),this.clusterReader.pos=a,await this.clusterReader.reader.loadRange(this.clusterReader.pos,this.clusterReader.pos+n);const o={elementStartPos:t,elementEndPos:a+n,dataStartPos:a,timestamp:-1,trackData:new Map,nextCluster:null,isKnownToBeFirstCluster:!1};this.currentCluster=o,this.readContiguousElements(this.clusterReader,n);for(const[d,u]of o.trackData){const l=e.tracks.find(p=>p.id===d)??null;g(u.blocks.length>0);let f=!1,c=!1;for(let p=0;p<u.blocks.length;p++){const k=u.blocks[p];k.timestamp+=o.timestamp,f||(f=k.referencedTimestamps.length>0),c||(c=k.lacing!==ne.None)}f&&(u.blocks=fa(u.blocks)),u.presentationTimestamps=u.blocks.map((p,k)=>({timestamp:p.timestamp,blockIndex:k})).sort((p,k)=>p.timestamp-k.timestamp);for(let p=0;p<u.presentationTimestamps.length;p++){const k=u.presentationTimestamps[p],w=u.blocks[k.blockIndex];if(u.firstKeyFrameTimestamp===null&&w.isKeyFrame&&(u.firstKeyFrameTimestamp=w.timestamp),p<u.presentationTimestamps.length-1){const T=u.presentationTimestamps[p+1];w.duration=T.timestamp-w.timestamp}else w.duration===0&&(l==null?void 0:l.defaultDuration)!=null&&w.lacing===ne.None&&(w.duration=l.defaultDuration)}c&&(this.expandLacedBlocks(u.blocks,l),u.presentationTimestamps=u.blocks.map((p,k)=>({timestamp:p.timestamp,blockIndex:k})).sort((p,k)=>p.timestamp-k.timestamp));const m=u.blocks[u.presentationTimestamps[0].blockIndex],h=u.blocks[K(u.presentationTimestamps).blockIndex];u.startTimestamp=m.timestamp,u.endTimestamp=h.timestamp+h.duration,l&&(Fe(l.clusters,o,k=>k.elementStartPos),u.firstKeyFrameTimestamp!==null&&Fe(l.clustersWithKeyFrame,o,k=>k.elementStartPos))}return Fe(e.clusters,o,d=>d.elementStartPos),this.currentCluster=null,o}getTrackDataInCluster(e,t){let s=e.trackData.get(t);return s||(s={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(t,s)),s}expandLacedBlocks(e,t){for(let s=0;s<e.length;s++){const i=e[s];if(i.lacing===ne.None)continue;const n=i.data;let a=0;const o=[],d=n[a]+1;switch(a++,i.lacing){case ne.Xiph:{let l=0;for(let f=0;f<d-1;f++){let c=0;for(;a<n.length;){const m=n[a];if(c+=m,a++,m<255){o.push(c),l+=c;break}}}o.push(n.length-(a+l))}break;case ne.FixedSize:{const l=n.length-1,f=Math.floor(l/d);for(let c=0;c<d;c++)o.push(f)}break;case ne.Ebml:{const l=cr(n,a);let f=l.value;o.push(f),a+=l.width;let c=f;for(let m=1;m<d-1;m++){const h=cr(n,a),p=h.value,k=(1<<h.width*7-1)-1,w=p-k;f+=w,o.push(f),a+=h.width,c+=f}o.push(n.length-(a+c))}break;default:g(!1)}g(o.length===d),e.splice(s,1);let u=a;for(let l=0;l<d;l++){const f=o[l],c=n.subarray(u,u+f),m=i.duration||d*((t==null?void 0:t.defaultDuration)??0),h=i.timestamp+m*l/d,p=m/d;e.splice(s+l,0,{timestamp:h,duration:p,isKeyFrame:i.isKeyFrame,referencedTimestamps:i.referencedTimestamps,data:c,lacing:ne.None}),u+=f}s+=d,s--}}readContiguousElements(e,t){const s=e.pos;for(;e.pos-s<=t-Ct;)this.traverseElement(e)}traverseElement(e){var n,a,o,d,u,l,f,c,m,h,p,k,w,T,x,S,b,y,C,I,R,_,F,W,M,j,q,se,Ce,Ze,Mt,Dt;const{id:t,size:s}=e.readElementHeader(),i=e.pos;switch(_e(s),t){case P.DocType:this.isWebM=e.readAsciiString(s)==="webm";break;case P.Seek:{if(!this.currentSegment)break;const A={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(A),this.readContiguousElements(e,s),(A.id===-1||A.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case P.SeekID:{const A=(n=this.currentSegment)==null?void 0:n.seekEntries[this.currentSegment.seekEntries.length-1];if(!A)break;A.id=e.readUnsignedInt(s)}break;case P.SeekPosition:{const A=(a=this.currentSegment)==null?void 0:a.seekEntries[this.currentSegment.seekEntries.length-1];if(!A)break;A.segmentPosition=e.readUnsignedInt(s)}break;case P.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=e.readUnsignedInt(s),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case P.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=e.readFloat(s)}break;case P.TrackEntry:{if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusters:[],clustersWithKeyFrame:[],cuePoints:[],isDefault:!1,inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,languageCode:fe,info:null},this.readContiguousElements(e,s),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const A=this.currentTrack.codecId.indexOf("/"),H=A===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,A);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===ee.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===ee.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===ee.vp8?this.currentTrack.info.codec="vp8":H===ee.vp9?this.currentTrack.info.codec="vp9":H===ee.av1&&(this.currentTrack.info.codec="av1");const ke=this.currentTrack,we=new Ot(new ua(ke));this.currentTrack.inputTrack=we,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){H===ee.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===ee.mp3?this.currentTrack.info.codec="mp3":H===ee.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===ee.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===ee.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const ke=this.currentTrack,we=new ge(new ma(ke));this.currentTrack.inputTrack=we,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case P.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=e.readUnsignedInt(s)}break;case P.TrackType:{if(!this.currentTrack)break;const A=e.readUnsignedInt(s);A===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null}:A===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case P.FlagEnabled:{if(!this.currentTrack)break;e.readUnsignedInt(s)||(this.currentSegment.tracks.pop(),this.currentTrack=null)}break;case P.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.isDefault=!!e.readUnsignedInt(s)}break;case P.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=e.readAsciiString(s)}break;case P.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=e.readBytes(s)}break;case P.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*e.readUnsignedInt(s)/1e9}break;case P.Language:{if(!this.currentTrack)break;this.currentTrack.languageCode=e.readAsciiString(s),Rt(this.currentTrack.languageCode)||(this.currentTrack.languageCode=fe)}break;case P.Video:{if(((d=(o=this.currentTrack)==null?void 0:o.info)==null?void 0:d.type)!=="video")break;this.readContiguousElements(e,s)}break;case P.PixelWidth:{if(((l=(u=this.currentTrack)==null?void 0:u.info)==null?void 0:l.type)!=="video")break;this.currentTrack.info.width=e.readUnsignedInt(s)}break;case P.PixelHeight:{if(((c=(f=this.currentTrack)==null?void 0:f.info)==null?void 0:c.type)!=="video")break;this.currentTrack.info.height=e.readUnsignedInt(s)}break;case P.Colour:{if(((h=(m=this.currentTrack)==null?void 0:m.info)==null?void 0:h.type)!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e,s)}break;case P.MatrixCoefficients:{if(((k=(p=this.currentTrack)==null?void 0:p.info)==null?void 0:k.type)!=="video"||!this.currentTrack.info.colorSpace)break;const A=e.readUnsignedInt(s),H=Tr[A]??null;this.currentTrack.info.colorSpace.matrix=H}break;case P.Range:{if(((T=(w=this.currentTrack)==null?void 0:w.info)==null?void 0:T.type)!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=e.readUnsignedInt(s)===2}break;case P.TransferCharacteristics:{if(((S=(x=this.currentTrack)==null?void 0:x.info)==null?void 0:S.type)!=="video"||!this.currentTrack.info.colorSpace)break;const A=e.readUnsignedInt(s),H=wr[A]??null;this.currentTrack.info.colorSpace.transfer=H}break;case P.Primaries:{if(((y=(b=this.currentTrack)==null?void 0:b.info)==null?void 0:y.type)!=="video"||!this.currentTrack.info.colorSpace)break;const A=e.readUnsignedInt(s),H=kr[A]??null;this.currentTrack.info.colorSpace.primaries=H}break;case P.Projection:{if(((I=(C=this.currentTrack)==null?void 0:C.info)==null?void 0:I.type)!=="video")break;this.readContiguousElements(e,s)}break;case P.ProjectionPoseRoll:{if(((_=(R=this.currentTrack)==null?void 0:R.info)==null?void 0:_.type)!=="video")break;const H=-e.readFloat(s);try{this.currentTrack.info.rotation=gr(H)}catch{}}break;case P.Audio:{if(((W=(F=this.currentTrack)==null?void 0:F.info)==null?void 0:W.type)!=="audio")break;this.readContiguousElements(e,s)}break;case P.SamplingFrequency:{if(((j=(M=this.currentTrack)==null?void 0:M.info)==null?void 0:j.type)!=="audio")break;this.currentTrack.info.sampleRate=e.readFloat(s)}break;case P.Channels:{if(((se=(q=this.currentTrack)==null?void 0:q.info)==null?void 0:se.type)!=="audio")break;this.currentTrack.info.numberOfChannels=e.readUnsignedInt(s)}break;case P.BitDepth:{if(((Ze=(Ce=this.currentTrack)==null?void 0:Ce.info)==null?void 0:Ze.type)!=="audio")break;this.currentTrack.info.bitDepth=e.readUnsignedInt(s)}break;case P.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e,s),this.currentCueTime=null}break;case P.CueTime:this.currentCueTime=e.readUnsignedInt(s);break;case P.CueTrackPositions:{if(this.currentCueTime===null)break;g(this.currentSegment);const A={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(A),this.readContiguousElements(e,s),(A.trackId===-1||A.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case P.CueTrack:{const A=(Mt=this.currentSegment)==null?void 0:Mt.cuePoints[this.currentSegment.cuePoints.length-1];if(!A)break;A.trackId=e.readUnsignedInt(s)}break;case P.CueClusterPosition:{const A=(Dt=this.currentSegment)==null?void 0:Dt.cuePoints[this.currentSegment.cuePoints.length-1];if(!A)break;g(this.currentSegment),A.clusterPosition=this.currentSegment.dataStartPos+e.readUnsignedInt(s)}break;case P.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=e.readUnsignedInt(s)}break;case P.SimpleBlock:{if(!this.currentCluster)break;const A=e.readVarInt(),H=e.readS16(),ke=e.readU8(),we=!!(ke&128),nt=ke>>1&3;this.getTrackDataInCluster(this.currentCluster,A).blocks.push({timestamp:H,duration:0,isKeyFrame:we,referencedTimestamps:[],data:e.readBytes(s-(e.pos-i)),lacing:nt})}break;case P.BlockGroup:{if(!this.currentCluster)break;if(this.readContiguousElements(e,s),this.currentBlock){for(let A=0;A<this.currentBlock.referencedTimestamps.length;A++)this.currentBlock.referencedTimestamps[A]+=this.currentBlock.timestamp;this.currentBlock=null}}break;case P.Block:{if(!this.currentCluster)break;const A=e.readVarInt(),H=e.readS16(),we=e.readU8()>>1&3,nt=this.getTrackDataInCluster(this.currentCluster,A);this.currentBlock={timestamp:H,duration:0,isKeyFrame:!0,referencedTimestamps:[],data:e.readBytes(s-(e.pos-i)),lacing:we},nt.blocks.push(this.currentBlock)}break;case P.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=e.readUnsignedInt(s)}break;case P.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1;const A=e.readSignedInt(s);this.currentBlock.referencedTimestamps.push(A)}break}e.pos=i+s}}class os{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}async getFirstPacket(e){return this.performClusterLookup(()=>{const t=this.internalTrack.segment.clusters[0]??null;if(t!=null&&t.isKnownToBeFirstCluster){let s=t;for(;s;){if(s.trackData.get(this.internalTrack.id))return{clusterIndex:$(this.internalTrack.clusters,s.elementStartPos,n=>n.elementStartPos),blockIndex:0,correctBlockFound:!0};s=s.nextCluster}}return{clusterIndex:-1,blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,e)}intoTimescale(e){return Et(e*this.internalTrack.segment.timestampFactor,14)}async getPacket(e,t){const s=this.intoTimescale(e);return this.performClusterLookup(()=>this.findBlockInClustersForTimestamp(s),s,s,t)}async getNextPacket(e,t){const s=this.packetToClusterLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");const i=s.cluster.trackData.get(this.internalTrack.id),n=$(this.internalTrack.clusters,s.cluster.elementStartPos,a=>a.elementStartPos);return g(n!==-1),this.performClusterLookup(()=>{if(s.blockIndex+1<i.blocks.length)return{clusterIndex:n,blockIndex:s.blockIndex+1,correctBlockFound:!0};{let a=s.cluster;for(;a.nextCluster;)if(a=a.nextCluster,a.trackData.get(this.internalTrack.id)){const d=$(this.internalTrack.clusters,a.elementStartPos,u=>u.elementStartPos);return g(d!==-1),{clusterIndex:d,blockIndex:0,correctBlockFound:!0}}return{clusterIndex:n,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,t)}async getKeyPacket(e,t){const s=this.intoTimescale(e);return this.performClusterLookup(()=>this.findKeyBlockInClustersForTimestamp(s),s,s,t)}async getNextKeyPacket(e,t){const s=this.packetToClusterLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");const i=s.cluster.trackData.get(this.internalTrack.id),n=$(this.internalTrack.clusters,s.cluster.elementStartPos,a=>a.elementStartPos);return g(n!==-1),this.performClusterLookup(()=>{const a=i.blocks.findIndex((o,d)=>o.isKeyFrame&&d>s.blockIndex);if(a!==-1)return{clusterIndex:n,blockIndex:a,correctBlockFound:!0};{let o=s.cluster;for(;o.nextCluster;){o=o.nextCluster;const d=o.trackData.get(this.internalTrack.id);if(d&&d.firstKeyFrameTimestamp!==null){const u=$(this.internalTrack.clusters,o.elementStartPos,f=>f.elementStartPos);g(u!==-1);const l=d.blocks.findIndex(f=>f.isKeyFrame);return g(l!==-1),{clusterIndex:u,blockIndex:l,correctBlockFound:!0}}}return{clusterIndex:n,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,t)}async fetchPacketInCluster(e,t,s){if(t===-1)return null;const n=e.trackData.get(this.internalTrack.id).blocks[t];g(n);const a=s.metadataOnly?ce:n.data,o=n.timestamp/this.internalTrack.segment.timestampFactor,d=n.duration/this.internalTrack.segment.timestampFactor,u=new N(a,n.isKeyFrame?"key":"delta",o,d,e.dataStartPos+t,n.data.byteLength);return this.packetToClusterLocation.set(u,{cluster:e,blockIndex:t}),u}findBlockInClustersForTimestamp(e){const t=D(this.internalTrack.clusters,e,n=>n.trackData.get(this.internalTrack.id).startTimestamp);let s=-1,i=!1;if(t!==-1){const a=this.internalTrack.clusters[t].trackData.get(this.internalTrack.id),o=D(a.presentationTimestamps,e,d=>d.timestamp);g(o!==-1),s=a.presentationTimestamps[o].blockIndex,i=e<a.endTimestamp}return{clusterIndex:t,blockIndex:s,correctBlockFound:i}}findKeyBlockInClustersForTimestamp(e){const t=D(this.internalTrack.clustersWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp);let s=-1,i=-1,n=!1;if(t!==-1){const a=this.internalTrack.clustersWithKeyFrame[t];s=$(this.internalTrack.clusters,a.elementStartPos,l=>l.elementStartPos),g(s!==-1);const o=a.trackData.get(this.internalTrack.id),d=yr(o.presentationTimestamps,l=>o.blocks[l.blockIndex].isKeyFrame&&l.timestamp<=e);g(d!==-1),i=o.presentationTimestamps[d].blockIndex,n=e<o.endTimestamp}return{clusterIndex:s,blockIndex:i,correctBlockFound:n}}async performClusterLookup(e,t,s,i){const{demuxer:n,segment:a}=this.internalTrack,o=await a.clusterLookupMutex.acquire();try{const{clusterIndex:d,blockIndex:u,correctBlockFound:l}=e();if(l){const b=this.internalTrack.clusters[d];return this.fetchPacketInCluster(b,u,i)}const f=n.metadataReader,c=n.clusterReader;let m=null,h=d,p=u;const k=D(this.internalTrack.cuePoints,t,b=>b.time),w=k!==-1?this.internalTrack.cuePoints[k]:null;let T=!1;if(d===-1)f.pos=(w==null?void 0:w.clusterPosition)??a.clusterSeekStartPos,T=f.pos===a.clusterSeekStartPos;else{const b=this.internalTrack.clusters[d];!w||b.elementStartPos>=w.clusterPosition?(f.pos=b.elementEndPos,m=b):f.pos=w.clusterPosition}for(;f.pos<a.elementEndPos;){if(m){const _=m.trackData.get(this.internalTrack.id);if(_&&_.startTimestamp>s)break;if(m.nextCluster){f.pos=m.nextCluster.elementEndPos,m=m.nextCluster;continue}}await f.reader.loadRange(f.pos,f.pos+Ae);const b=f.pos,y=f.readElementHeader(),C=y.id;let I=y.size;const R=f.pos;if(C===P.Cluster){const _=$(a.clusters,b,q=>q.elementStartPos);let F;_===-1?(f.pos=b,F=await n.readCluster(a)):F=a.clusters[_],m&&(m.nextCluster=F),m=F,T&&(F.isKnownToBeFirstCluster=!0,T=!1);const{clusterIndex:W,blockIndex:M,correctBlockFound:j}=e();if(j){const q=this.internalTrack.clusters[W];return this.fetchPacketInCluster(q,M,i)}W!==-1&&(h=W,p=M)}if(I===null){C===P.Cluster?(g(m),I=m.elementEndPos-R):(c.pos=R,I=(await c.searchForNextElementId(xt,a.elementEndPos)??a.elementEndPos)-R);const _=R+I;if(_>a.elementEndPos-Ct)break;if(c.pos=_,c.readElementId()===P.Segment){a.elementEndPos=_;break}}f.pos=R+I}let x=null;const S=h!==-1?this.internalTrack.clusters[h]:null;if(S&&(x=await this.fetchPacketInCluster(S,p,i)),!x&&w&&(!S||S.elementStartPos<w.clusterPosition)){const b=this.internalTrack.cuePoints[k-1],y=(b==null?void 0:b.time)??-1/0;return this.performClusterLookup(e,y,s,i)}return x}finally{o()}}}class ua extends os{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){var e,t,s,i;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(t=this.internalTrack.info.colorSpace)==null?void 0:t.transfer,matrix:(s=this.internalTrack.info.colorSpace)==null?void 0:s.matrix,fullRange:(i=this.internalTrack.info.colorSpace)==null?void 0:i.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:vr({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?Fr(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?Br(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?Ar(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?Or(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class ma extends os{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:_r({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const fa=r=>{const e=new Map;for(let n=0;n<r.length;n++){const a=r[n];e.set(a.timestamp,a)}const t=new Set,s=[],i=n=>{if(!t.has(n)){t.add(n);for(let a=0;a<n.referencedTimestamps.length;a++){const o=n.referencedTimestamps[a],d=e.get(o);d&&i(d)}s.push(n)}};for(let n=0;n<r.length;n++)i(r[n]);return s};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class cs{constructor(e){this.reader=e,this.pos=0,this.fileSize=null}readBytes(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);return this.pos+=e,new Uint8Array(t.buffer,s,e)}readU16(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getUint16(t,!1)}readU32(){const{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,!1)}readAscii(e){const{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i="";for(let n=0;n<e;n++)i+=String.fromCharCode(t.getUint8(s+n));return i}readId3(){return this.readAscii(3)!=="ID3"?(this.pos-=3,null):(this.pos+=3,{size:ha(this.readU32())})}readNextFrameHeader(e){for(g(this.fileSize),e??(e=this.fileSize);this.pos<=e-vt;){const t=this.readU32();this.pos-=4;const s=In(t,this);if(s)return s}return null}}const ha=r=>{let e=2130706432,t=0;for(;e!==0;)t>>=1,t|=r&e,e>>=8;return t};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class pa extends Xe{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.loadingMutex=new Me,this.lastLoadedPos=0,this.fileSize=0,this.nextTimestampInSamples=0,this.reader=new cs(e._mainReader)}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(this.fileSize=await this.input.source.getSize(),this.reader.fileSize=this.fileSize;!this.firstFrameHeader&&this.lastLoadedPos<this.fileSize;)await this.loadNextChunk();if(!this.firstFrameHeader)throw new Error("No MP3 frames found.");this.tracks=[new ge(new ga(this))]})())}async loadNextChunk(){const e=await this.loadingMutex.acquire();try{g(this.lastLoadedPos<this.fileSize);const t=.5*1024*1024,s=Math.min(this.lastLoadedPos+t,this.fileSize);if(await this.reader.reader.loadRange(this.lastLoadedPos,s),this.lastLoadedPos=s,g(this.lastLoadedPos<=this.fileSize),this.reader.pos===0){const i=this.reader.readId3();i&&(this.reader.pos+=i.size)}this.parseFramesFromLoadedData()}finally{e()}}parseFramesFromLoadedData(){for(;;){const e=this.reader.pos,t=this.reader.readNextFrameHeader();if(!t)break;if(t.startPos+t.totalSize>this.lastLoadedPos){this.reader.pos=e,this.lastLoadedPos=e;break}const s=_n(t.mpegVersionId,t.channel);this.reader.pos=t.startPos+s;const i=this.reader.readU32(),n=i===Cn||i===Pn;if(this.reader.pos=t.startPos+t.totalSize-1,n)continue;this.firstFrameHeader||(this.firstFrameHeader=t);const a=t.audioSamplesInFrame/t.sampleRate,o={timestamp:this.nextTimestampInSamples/t.sampleRate,duration:a,dataStart:t.startPos,dataSize:t.totalSize};this.loadedSamples.push(o),this.nextTimestampInSamples+=t.audioSamplesInFrame}}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return g(e),e.computeDuration()}}class ga{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return g(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getLanguageCode(){return fe}getCodec(){return"mp3"}getNumberOfChannels(){return g(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return g(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}async getDecoderConfig(){return g(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}getPacketAtIndex(e,t){if(e===-1)return null;const s=this.demuxer.loadedSamples[e];if(!s)return null;let i;return t.metadataOnly?i=ce:(this.demuxer.reader.pos=s.dataStart,i=this.demuxer.reader.readBytes(s.dataSize)),new N(i,"key",s.timestamp,s.duration,e,s.dataSize)}async getFirstPacket(e){for(;this.demuxer.loadedSamples.length===0&&this.demuxer.lastLoadedPos<this.demuxer.fileSize;)await this.demuxer.loadNextChunk();return this.getPacketAtIndex(0,e)}async getNextPacket(e,t){const s=$(this.demuxer.loadedSamples,e.timestamp,n=>n.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const i=s+1;for(;i>=this.demuxer.loadedSamples.length&&this.demuxer.lastLoadedPos<this.demuxer.fileSize;)await this.demuxer.loadNextChunk();return this.getPacketAtIndex(i,t)}async getPacket(e,t){for(;;){const s=D(this.demuxer.loadedSamples,e,i=>i.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastLoadedPos===this.demuxer.fileSize)return this.getPacketAtIndex(s,t);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,t);await this.demuxer.loadNextChunk()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ka extends Xe{constructor(e){super(e),this.readingMutex=new Me,this.metadataPromise=null,this.fileSize=null,this.bitstreams=[],this.tracks=[],this.reader=new Xr(new Ye(e.source,64*2**20))}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(this.fileSize=await this.input.source.getSize();this.reader.pos<this.fileSize-Le;){await this.reader.reader.loadRange(this.reader.pos,this.reader.pos+ze);const e=this.reader.readPageHeader();if(!e||!!!(e.headerType&2))break;this.bitstreams.push({serialNumber:e.serialNumber,bosPage:e,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),this.reader.pos=e.headerStartPos+e.totalSize}for(const e of this.bitstreams){const t=await this.readPacket(this.reader,e.bosPage,0);t&&(t.data.byteLength>=7&&t.data[0]===1&&t.data[1]===118&&t.data[2]===111&&t.data[3]===114&&t.data[4]===98&&t.data[5]===105&&t.data[6]===115?await this.readVorbisMetadata(t,e):t.data.byteLength>=8&&t.data[0]===79&&t.data[1]===112&&t.data[2]===117&&t.data[3]===115&&t.data[4]===72&&t.data[5]===101&&t.data[6]===97&&t.data[7]===100&&await this.readOpusMetadata(t,e),e.codecInfo.codec!==null&&this.tracks.push(new ge(new wa(e,this))))}})())}async readVorbisMetadata(e,t){let s=await this.findNextPacketStart(this.reader,e);if(!s)return;const i=await this.readPacket(this.reader,s.startPage,s.startSegmentIndex);if(!i||(s=await this.findNextPacketStart(this.reader,i),!s))return;const n=await this.readPacket(this.reader,s.startPage,s.startSegmentIndex);if(!n||i.data[0]!==3||n.data[0]!==5)return;const a=[],o=f=>{for(;a.push(Math.min(255,f)),!(f<255);)f-=255};o(e.data.length),o(i.data.length);const d=new Uint8Array(1+a.length+e.data.length+i.data.length+n.data.length);d[0]=a.length,d.set(a,1),d.set(e.data,1+a.length),d.set(i.data,1+a.length+e.data.length),d.set(n.data,1+a.length+e.data.length+i.data.length),t.codecInfo.codec="vorbis",t.description=d,t.lastMetadataPacket=n;const u=Ue(e.data);t.numberOfChannels=u.getUint8(11),t.sampleRate=u.getUint32(12,!0);const l=u.getUint8(28);t.codecInfo.vorbisInfo={blocksizes:[1<<(l&15),1<<(l>>4)],modeBlockflags:ni(n.data).modeBlockflags}}async readOpusMetadata(e,t){const s=await this.findNextPacketStart(this.reader,e);if(!s)return;const i=await this.readPacket(this.reader,s.startPage,s.startSegmentIndex);if(!i)return;t.codecInfo.codec="opus",t.description=e.data,t.lastMetadataPacket=i;const n=Ur(e.data);t.numberOfChannels=n.outputChannelCount,t.sampleRate=n.inputSampleRate,t.codecInfo.opusInfo={preSkip:n.preSkip}}async readPacket(e,t,s){g(s<t.lacingValues.length),g(this.fileSize);let i=0;for(let c=0;c<s;c++)i+=t.lacingValues[c];let n=t,a=i,o=s;const d=[];e:for(;;){await e.reader.loadRange(n.dataStartPos,n.dataStartPos+n.dataSize),e.pos=n.dataStartPos;const c=e.readBytes(n.dataSize);for(;;){if(o===n.lacingValues.length){d.push(c.subarray(i,a));break}const m=n.lacingValues[o];if(a+=m,m<255){d.push(c.subarray(i,a));break e}o++}for(;;){if(e.pos=n.headerStartPos+n.totalSize,e.pos>=this.fileSize-Le)return null;await e.reader.loadRange(e.pos,e.pos+ze);const m=e.readPageHeader();if(!m)return null;if(n=m,n.serialNumber===t.serialNumber)break}i=0,a=0,o=0}const u=d.reduce((c,m)=>c+m.length,0),l=new Uint8Array(u);let f=0;for(let c=0;c<d.length;c++){const m=d[c];l.set(m,f),f+=m.length}return{data:l,endPage:n,endSegmentIndex:o}}async findNextPacketStart(e,t){if(g(this.fileSize!==null),t.endSegmentIndex<t.endPage.lacingValues.length-1)return{startPage:t.endPage,startSegmentIndex:t.endSegmentIndex+1};if(!!(t.endPage.headerType&4))return null;for(e.pos=t.endPage.headerStartPos+t.endPage.totalSize;;){if(e.pos>=this.fileSize-Le)return null;await e.reader.loadRange(e.pos,e.pos+ze);const i=e.readPageHeader();if(!i)return null;if(i.serialNumber===t.endPage.serialNumber)return{startPage:i,startSegmentIndex:0};e.pos=i.headerStartPos+i.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(t=>t.getCodecParameterString()));return Bn({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(s=>s.computeDuration()));return Math.max(0,...t)}}class wa{constructor(e,t){this.bitstream=e,this.demuxer=t,this.encodedPacketToMetadata=new WeakMap,this.internalSampleRate=e.codecInfo.codec==="opus"?Rs:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}async getDecoderConfig(){return g(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getLanguageCode(){return fe}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(g(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,t,s){if(!e)return null;const{durationInSamples:i,vorbisBlockSize:n}=Fn(e.data,this.bitstream.codecInfo,t.vorbisLastBlocksize),a=new N(s.metadataOnly?ce:e.data,"key",Math.max(0,t.timestampInSamples)/this.internalSampleRate,i/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:t.timestampInSamples,durationInSamples:i,vorbisBlockSize:n}),a}async getFirstPacket(e,t=!0){const s=t?await this.demuxer.readingMutex.acquire():null;try{g(this.bitstream.lastMetadataPacket);const i=await this.demuxer.findNextPacketStart(this.demuxer.reader,this.bitstream.lastMetadataPacket);if(!i)return null;let n=0;this.bitstream.codecInfo.codec==="opus"&&(g(this.bitstream.codecInfo.opusInfo),n-=this.bitstream.codecInfo.opusInfo.preSkip);const a=await this.demuxer.readPacket(this.demuxer.reader,i.startPage,i.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:n,vorbisLastBlocksize:null},e)}finally{s==null||s()}}async getNextPacket(e,t){const s=await this.demuxer.readingMutex.acquire();try{const i=this.encodedPacketToMetadata.get(e);if(!i)throw new Error("Packet was not created from this track.");const n=await this.demuxer.findNextPacketStart(this.demuxer.reader,i.packet);if(!n)return null;const a=i.timestampInSamples+i.durationInSamples,o=await this.demuxer.readPacket(this.demuxer.reader,n.startPage,n.startSegmentIndex);return this.createEncodedPacketFromOggPacket(o,{timestampInSamples:a,vorbisLastBlocksize:i.vorbisBlockSize},t)}finally{s()}}async getPacket(e,t){const s=await this.demuxer.readingMutex.acquire();try{g(this.demuxer.fileSize!==null);const i=Et(e*this.internalSampleRate,14);if(i===0)return this.getFirstPacket(t,!1);if(i<0)return null;const n=this.demuxer.reader;g(this.bitstream.lastMetadataPacket);const a=await this.demuxer.findNextPacketStart(n,this.bitstream.lastMetadataPacket);if(!a)return null;let o=a.startPage,d=this.demuxer.fileSize;const u=[o];e:for(;o.headerStartPos+o.totalSize<d;){const S=o.headerStartPos,b=Math.floor((S+d)/2);let y=b;for(;;){const C=Math.min(y+An,d-Le);if(await n.reader.loadRange(y,C),n.pos=y,!n.findNextPageHeader(C)){d=b+Le;continue e}await n.reader.loadRange(n.pos,n.pos+ze);const R=n.readPageHeader();g(R);let _=!1;if(R.serialNumber===this.bitstream.serialNumber)_=!0;else{await n.reader.loadRange(R.headerStartPos,R.headerStartPos+R.totalSize),n.pos=R.headerStartPos;const W=n.readBytes(R.totalSize);_=Rn(W)===R.checksum}if(!_){y=R.headerStartPos+4;continue}if(_&&R.serialNumber!==this.bitstream.serialNumber){y=R.headerStartPos+R.totalSize;continue}if(R.granulePosition===-1){y=R.headerStartPos+R.totalSize;continue}this.granulePositionToTimestampInSamples(R.granulePosition)>i?d=R.headerStartPos:(o=R,u.push(R));continue e}}let l=a.startPage;for(const S of u){if(S.granulePosition===o.granulePosition)break;(!l||S.headerStartPos>l.headerStartPos)&&(l=S)}let f=l;const c=[f];for(;!(f.serialNumber===this.bitstream.serialNumber&&f.granulePosition===o.granulePosition);){n.pos=f.headerStartPos+f.totalSize,await n.reader.loadRange(n.pos,n.pos+ze);const S=n.readPageHeader();g(S),f=S,f.serialNumber===this.bitstream.serialNumber&&c.push(f)}g(f.granulePosition!==-1);let m=null,h,p,k=f,w=0;if(f.headerStartPos===a.startPage.headerStartPos)h=this.granulePositionToTimestampInSamples(0),p=!0,m=0;else{h=0,p=!1;for(let y=f.lacingValues.length-1;y>=0;y--)if(f.lacingValues[y]<255){m=y+1;break}if(m===null)throw new Error("Invalid page with granule position: no packets end on this page.");w=m-1;const S={data:ce,endPage:k,endSegmentIndex:w};if(await this.demuxer.findNextPacketStart(n,S)){const y=pr(c,f,m);g(y);const C=hr(c,y.page,y.segmentIndex);C&&(f=C.page,m=C.segmentIndex)}else for(;;){const y=pr(c,f,m);if(!y)break;const C=hr(c,y.page,y.segmentIndex);if(!C)break;if(f=C.page,m=C.segmentIndex,y.page.headerStartPos!==k.headerStartPos){k=y.page,w=y.segmentIndex;break}}}let T=null,x=null;for(;f!==null;){g(m!==null);const S=await this.demuxer.readPacket(n,f,m);if(!S)break;if(!(f.headerStartPos===a.startPage.headerStartPos&&m<a.startSegmentIndex)){let C=this.createEncodedPacketFromOggPacket(S,{timestampInSamples:h,vorbisLastBlocksize:(x==null?void 0:x.vorbisBlockSize)??null},t);g(C);let I=this.encodedPacketToMetadata.get(C);if(g(I),!p&&S.endPage.headerStartPos===k.headerStartPos&&S.endSegmentIndex===w?(h=this.granulePositionToTimestampInSamples(f.granulePosition),p=!0,C=this.createEncodedPacketFromOggPacket(S,{timestampInSamples:h-I.durationInSamples,vorbisLastBlocksize:(x==null?void 0:x.vorbisBlockSize)??null},t),g(C),I=this.encodedPacketToMetadata.get(C),g(I)):h+=I.durationInSamples,T=C,x=I,p&&(Math.max(h,0)>i||Math.max(I.timestampInSamples,0)===i))break}const y=await this.demuxer.findNextPacketStart(n,S);if(!y)break;f=y.startPage,m=y.startSegmentIndex}return T}finally{s()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const hr=(r,e,t)=>{let s=e,i=t;e:for(;;){for(i--,i;i>=0;i--)if(s.lacingValues[i]<255){i++;break e}if(g(i===-1),!(s.headerType&1)){i=0;break}const a=br(r,o=>o.headerStartPos<s.headerStartPos);if(!a)return null;s=a,i=s.lacingValues.length}if(g(i!==-1),i===s.lacingValues.length){const n=r[r.indexOf(s)+1];g(n),s=n,i=0}return{page:s,segmentIndex:i}},pr=(r,e,t)=>{if(t>0)return{page:e,segmentIndex:t-1};const s=br(r,i=>i.headerStartPos<e.headerStartPos);return s?{page:s,segmentIndex:s.lacingValues.length-1}:null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class De{}class ds extends De{async _getMajorBrand(e){if(await e._mainReader.source.getSize()<12)return null;const s=new yt(e._mainReader);return s.pos=4,s.readAscii(4)!=="ftyp"?null:s.readAscii(4)}_createDemuxer(e){return new sa(e)}}class Ta extends ds{async _canReadInput(e){const t=await this._getMajorBrand(e);return!!t&&t!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class ba extends ds{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class ls extends De{async isSupportedEBMLOfDocType(e,t){if(await e._mainReader.source.getSize()<8)return!1;const i=new Pt(e._mainReader),n=i.readVarIntSize();if(n<1||n>8||i.readUnsignedInt(n)!==P.EBML)return!1;const o=i.readElementSize();if(o===null)return!1;const d=i.pos;for(;i.pos<d+o;){const{id:u,size:l}=i.readElementHeader(),f=i.pos;if(l===null)return!1;switch(u){case P.EBMLVersion:if(i.readUnsignedInt(l)!==1)return!1;break;case P.EBMLReadVersion:if(i.readUnsignedInt(l)!==1)return!1;break;case P.DocType:if(i.readAsciiString(l)!==t)return!1;break;case P.DocTypeVersion:if(i.readUnsignedInt(l)>4)return!1;break}i.pos=f+l}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new la(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class ya extends ls{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class Sa extends De{async _canReadInput(e){const t=await e._mainReader.source.getSize();if(t<4)return!1;const s=new cs(e._mainReader);s.fileSize=t;const i=s.readId3();i&&(s.pos+=i.size);const n=s.pos;await s.reader.loadRange(s.pos,s.pos+4096);const a=s.readNextFrameHeader(Math.min(n+4096,t));if(!a)return!1;if(i)return!0;s.pos=a.startPos+a.totalSize,await s.reader.loadRange(s.pos,s.pos+vt);const o=s.readNextFrameHeader(s.pos+vt);return!(!o||a.channel!==o.channel||a.sampleRate!==o.sampleRate)}_createDemuxer(e){return new pa(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class xa extends De{async _canReadInput(e){if(await e._mainReader.source.getSize()<12)return!1;const s=new _t(e._mainReader),i=s.readAscii(4);return i!=="RIFF"&&i!=="RIFX"&&i!=="RF64"?!1:(s.pos=8,s.readAscii(4)==="WAVE")}_createDemuxer(e){return new Kn(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class Ca extends De{async _canReadInput(e){return await e._mainReader.source.getSize()<4?!1:new Xr(e._mainReader).readAscii(4)==="OggS"}_createDemuxer(e){return new ka(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}const Pa=new Ta,va=new ba,_a=new ls,Ia=new ya,Ea=new Sa,Ra=new xa,Fa=new Ca,Ba=[Pa,va,_a,Ia,Ra,Fa,Ea];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Aa{constructor(e){if(this._demuxerPromise=null,this._format=null,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(t=>!(t instanceof De)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof ns))throw new TypeError("options.source must be a Source.");this._formats=e.formats,this._source=e.source,this._mainReader=new Ye(e.source)}_getDemuxer(){return this._demuxerPromise??(this._demuxerPromise=(async()=>{await this._mainReader.loadRange(0,4096);for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})())}get source(){return this._source}async getFormat(){return await this._getDemuxer(),g(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(t=>t.isVideoTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(t=>t.isVideoTrack())??null}async getAudioTracks(){return(await this.getTracks()).filter(t=>t.isAudioTrack())}async getPrimaryAudioTrack(){return(await this.getTracks()).find(t=>t.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}}var je;class za extends fs{constructor(){super();at(this,"description");at(this,"title");Ht(this,je);const t=document.createElement("div"),s=document.createElement("h1");s.setAttribute("id","title"),s.textContent="Exporting";const i=document.createElement("span");i.classList.add("ellipsis"),s.appendChild(i),t.appendChild(s);const n=new Image;n.src="./nyancat_big.gif",t.appendChild(n);const a=document.createElement("h4");a.setAttribute("id","desc"),t.appendChild(a),a.textContent="initializing sequence...",Lt(this,je,t),this.title=s,this.description=a}open(){super.open(Wt(this,je))}}je=new WeakMap;const Ie=new za,Oa=async(r,e,t)=>{const{trimStart:s,trimEnd:i,tlStart:n}=e.tlContent.getAllDataset(),{numberOfChannels:a,sampleRate:o}=r,d=Math.ceil(t*o),u=new AudioBuffer({length:d,numberOfChannels:a,sampleRate:o}),l=new $n(r);let f=Math.floor(o*+n);for await(const{buffer:c}of l.buffers(+s,+i)){for(let m=0;m<c.numberOfChannels;m++){const h=c.getChannelData(m);u.copyToChannel(h,m,f)}f+=c.length}return u},Ua=async()=>{const r=Ie.description,e=window.editor.myProject.getProjectDuration(),t=window.editor.audioContext,s=t.createBuffer(6,t.sampleRate*e+1,t.sampleRate),i=window.editor.myProject.nodes.filter(o=>o.hasAudio());for(let o=0;o<i.length;o++){const d=i[o],u=await ps(d.src),f=await new Aa({formats:Ba,source:new ra(u)}).getPrimaryAudioTrack(),m=await(f==null?void 0:f.canDecode())?await Oa(f,d,e):await d.getTrimmedAudioBuffer();for(let h=0;h<m.numberOfChannels;h++){const p=s.getChannelData(h),k=m.getChannelData(h);for(let w=0;w<m.getChannelData(h).length;w++)p[w]+=k[w];s.getChannelData(h).set(p)}r.textContent=`compiling audio... ${o+1}/${i.length}`}const n=t.createMediaStreamDestination(),a=t.createBufferSource();return a.buffer=s,a.connect(n),a.start(0),n.stream.getAudioTracks()},Na=async(r=30)=>{if(console.time("export"),window.editor.myProject.save(),window.editor.myProject.getProjectDuration()<=0)return alert("No project to export");window.editor.myProject.transformer.hide(),Ie.open();const e=Ie.title,t=Ie.description,s=window.editor.myProject.layers.background.getChildren();s.forEach(i=>{i.isVisible()===!0&&(i.moveTo(window.editor.myProject.layers.static),i.moveToBottom())});try{const i=new WritableStream({write({data:h}){return $t.saveChunk(h)}}),n=new ts({fastStart:"fragmented"}),a=new ta({target:new pn(i,{chunked:!0,chunkSize:2**20}),format:n});t.textContent="compiling audio...";const o=n.getSupportedAudioCodecs(),d=await $s(o);(await Ua()).forEach(h=>{const p=new Zn(h,{codec:d,bitrate:Bs});a.addAudioTrack(p)}),t.textContent="audio compiled!",t.textContent="compiling video...";const u=window.editor.myProject.layers.static.getNativeCanvasElement(),l=n.getSupportedVideoCodecs(),f=new Gn(u,{codec:l[1],bitrate:As});a.addVideoTrack(f),await a.start();const c=window.editor.myProject.getProjectDuration();window.editor.playHead.positionSec(0),await f.add(0);const m=hs(async h=>{if(window.editor.playHead.positionSec(h),await f.add(h),t.textContent=`compiling video...${Math.round(h/c*100)}%`,h>=c){f.close(),m(),await a.finalize(),e.textContent=" DONE!!! ",t.textContent="file was saved in your browser download folder";const p=`ratreel-hensemdev${a.format.fileExtension}`,k=await $t.getFile(),w=URL.createObjectURL(k),T=document.createElement("a");T.href=w,T.download=p,T.click(),URL.revokeObjectURL(w),s.forEach(S=>{S.moveTo(window.editor.myProject.layers.background),S.moveToBottom()});const x=setTimeout(()=>{console.timeEnd("export"),Ie.close(),clearTimeout(x)},1e3*5)}},r)}catch(i){e.textContent="[ERROR] Owh no!!! ",t.textContent="Unexpected error occured";const n=setTimeout(()=>{console.timeEnd("export"),Ie.close(),clearTimeout(n)},1e3*5);console.error(i)}};export{Na as default};
