var Ln=Object.defineProperty;var dr=t=>{throw TypeError(t)};var qn=(t,e,r)=>e in t?Ln(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var Ft=(t,e,r)=>qn(t,typeof e!="symbol"?e+"":e,r),fr=(t,e,r)=>e.has(t)||dr("Cannot "+r);var mr=(t,e,r)=>(fr(t,e,"read from private field"),r?r.call(t):e.get(t)),hr=(t,e,r)=>e.has(t)?dr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),pr=(t,e,r,n)=>(fr(t,e,"write to private field"),n?n.call(t,r):e.set(t,r),r);import{e as $n,T as gr,g as jn}from"./index-pqAkEMcf.js";/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */function m(t){if(!t)throw new Error("Assertion failed.")}const Hr=t=>{const e=(t%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${t}.`)},K=t=>t&&t[t.length-1],et=t=>t>=0&&t<2**32;class Z{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),r=this.bytes[e]??0,n=7-(this.pos&7),s=(r&1<<n)>>n;return this.pos++,s}readBits(e){if(e===1)return this.readBit();let r=0;for(let n=0;n<e;n++)r<<=1,r|=this.readBit();return r}writeBits(e,r){const n=this.pos+e;for(let s=this.pos;s<n;s++){const i=Math.floor(s/8);let a=this.bytes[i];const o=7-(s&7);a&=~(1<<o),a|=(r&1<<n-s-1)>>n-s-1<<o,this.bytes[i]=a}this.pos=n}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,r=this.bytes[e]??0;return this.pos+=8,r}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new Z(this.bytes);return e.pos=this.pos,e}}const B=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},dt=t=>{const e=B(t);return(e&1)===0?-(e>>1):e+1>>1},me=t=>t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength),ae=t=>t instanceof DataView?t:t instanceof ArrayBuffer?new DataView(t):new DataView(t.buffer,t.byteOffset,t.byteLength),Lr=new TextDecoder,Ae=new TextEncoder,tr=t=>Object.fromEntries(Object.entries(t).map(([e,r])=>[r,e])),gt={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},qr=tr(gt),kt={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18},$r=tr(kt),wt={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},jr=tr(wt),Kn=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,It=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class We{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const r=new Promise(s=>{e=s}),n=this.currentPromise;return this.currentPromise=r,await n,e}}const kr=t=>[...t].map(e=>e.toString(16).padStart(2,"0")).join(""),wr=t=>(t=t>>1&1431655765|(t&1431655765)<<1,t=t>>2&858993459|(t&858993459)<<2,t=t>>4&252645135|(t&252645135)<<4,t=t>>8&16711935|(t&16711935)<<8,t=t>>16&65535|(t&65535)<<16,t>>>0),j=(t,e,r)=>{let n=0,s=t.length-1,i=-1;for(;n<=s;){const a=n+s>>1,o=r(t[a]);o===e?(i=a,s=a-1):o<e?n=a+1:s=a-1}return i},W=(t,e,r)=>{let n=0,s=t.length-1,i=-1;for(;n<=s;){const a=n+(s-n+1)/2|0;r(t[a])<=e?(i=a,n=a+1):s=a-1}return i},Ze=(t,e,r)=>{const n=W(t,r(e),r);t.splice(n+1,0,e)},Ge=()=>{let t,e;return{promise:new Promise((n,s)=>{t=n,e=s}),resolve:t,reject:e}},Kr=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return t[r]},Qr=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1},rr=t=>{throw new Error(`Unexpected value: ${t}`)},Xr=(t,e,r,n)=>{r=r>>>0,r=r&16777215,n?(t.setUint8(e,r&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r>>>16&255)):(t.setUint8(e,r>>>16&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r&255))},Qn=(t,e,r,n)=>{r=Y(r,-8388608,8388607),r<0&&(r=r+16777216&16777215),Xr(t,e,r,n)},Y=(t,e,r)=>Math.max(e,Math.min(r,t)),ce="und",xt=(t,e)=>{const r=10**e;return Math.round(t*r)/r},Xn=(t,e)=>Math.round(t/e)*e,Gn=t=>{let e=0;for(;t;)e++,t>>=1;return e},Yn=/^[a-z]{3}$/,nr=t=>Yn.test(t),Ce=1e6*(1+Number.EPSILON),Zn=(t,e)=>{const r=t<0?-1:1;t=Math.abs(t);let n=0,s=1,i=1,a=0,o=t;for(;;){const l=Math.floor(o),d=l*i+n,u=l*a+s;if(u>e)return{numerator:r*i,denominator:a};if(n=i,s=a,i=d,a=u,o=1/(o-l),!isFinite(o))break}return{numerator:r*i,denominator:a}};class Gr{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}const br=(t,e,r,n)=>t<=n&&r<=e;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ne=["avc","hevc","vp9","av1","vp8"],ne=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],Yr=["aac","opus","mp3","vorbis","flac"],Ve=[...Yr,...ne],Ct=["webvtt"],Tr=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],yr=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Pe=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],Sr=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],xr=".01.01.01.01.00",Cr=".0.110.01.01.01.0",Jn=(t,e,r,n)=>{if(t==="avc"){const i=Math.ceil(e/16)*Math.ceil(r/16),a=Tr.find(f=>i<=f.maxMacroblocks&&n<=f.maxBitrate)??K(Tr),o=a?a.level:0,l="64".padStart(2,"0"),d="00",u=o.toString(16).padStart(2,"0");return`avc1.${l}${d}${u}`}else if(t==="hevc"){const s="",a="6",o=e*r,l=yr.find(u=>o<=u.maxPictureSize&&n<=u.maxBitrate)??K(yr);return`hev1.${s}1.${a}.${l.tier}${l.level}.B0`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const s="00",i=e*r,a=Pe.find(l=>i<=l.maxPictureSize&&n<=l.maxBitrate)??K(Pe);return`vp09.${s}.${a.level.toString().padStart(2,"0")}.08`}else if(t==="av1"){const i=e*r,a=Sr.find(d=>i<=d.maxPictureSize&&n<=d.maxBitrate)??K(Sr);return`av01.0.${a.level.toString().padStart(2,"0")}${a.tier}.08`}}throw new TypeError(`Unhandled codec '${t}'.`)},es=t=>{const e=t.split("."),s=(1<<7)+1,i=Number(e[1]),a=e[2],o=Number(a.slice(0,-1)),l=(i<<5)+o,d=a.slice(-1)==="H"?1:0,f=Number(e[3])===8?0:1,h=0,w=e[4]?Number(e[4]):0,c=e[5]?Number(e[5][0]):1,p=e[5]?Number(e[5][1]):1,b=e[5]?Number(e[5][2]):0,k=(d<<7)+(f<<6)+(h<<5)+(w<<4)+(c<<3)+(p<<2)+b;return[s,l,k,0]},Zr=t=>{const{codec:e,codecDescription:r,colorSpace:n,avcCodecInfo:s,hevcCodecInfo:i,vp9CodecInfo:a,av1CodecInfo:o}=t;if(e==="avc"){if(s){const l=new Uint8Array([s.avcProfileIndication,s.profileCompatibility,s.avcLevelIndication]);return`avc1.${kr(l)}`}if(!r||r.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc1.${kr(r.subarray(1,4))}`}else if(e==="hevc"){let l,d,u,f,h,w;if(i)l=i.generalProfileSpace,d=i.generalProfileIdc,u=wr(i.generalProfileCompatibilityFlags),f=i.generalTierFlag,h=i.generalLevelIdc,w=[...i.generalConstraintIndicatorFlags];else{if(!r||r.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const p=ae(r),b=p.getUint8(1);l=b>>6&3,d=b&31,u=wr(p.getUint32(2)),f=b>>5&1,h=p.getUint8(12),w=[];for(let k=0;k<6;k++)w.push(p.getUint8(6+k))}let c="hev1.";for(c+=["","A","B","C"][l]+d,c+=".",c+=u.toString(16).toUpperCase(),c+=".",c+=f===0?"L":"H",c+=h;w.length>0&&w[w.length-1]===0;)w.pop();return w.length>0&&(c+=".",c+=w.map(p=>p.toString(16).toUpperCase()).join(".")),c}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!a){const k=t.width*t.height;let g=K(Pe).level;for(const y of Pe)if(k<=y.maxPictureSize){g=y.level;break}return`vp09.00.${g.toString().padStart(2,"0")}.08`}const l=a.profile.toString().padStart(2,"0"),d=a.level.toString().padStart(2,"0"),u=a.bitDepth.toString().padStart(2,"0"),f=a.chromaSubsampling.toString().padStart(2,"0"),h=a.colourPrimaries.toString().padStart(2,"0"),w=a.transferCharacteristics.toString().padStart(2,"0"),c=a.matrixCoefficients.toString().padStart(2,"0"),p=a.videoFullRangeFlag.toString().padStart(2,"0");let b=`vp09.${l}.${d}.${u}.${f}`;return b+=`.${h}.${w}.${c}.${p}`,b.endsWith(xr)&&(b=b.slice(0,-xr.length)),b}else if(e==="av1"){if(!o){const y=t.width*t.height;let T=K(Pe).level;for(const S of Pe)if(y<=S.maxPictureSize){T=S.level;break}return`av01.0.${T.toString().padStart(2,"0")}M.08`}const l=o.profile,d=o.level.toString().padStart(2,"0"),u=o.tier?"H":"M",f=o.bitDepth.toString().padStart(2,"0"),h=o.monochrome?"1":"0",w=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),c=n!=null&&n.primaries?gt[n.primaries]:1,p=n!=null&&n.transfer?kt[n.transfer]:1,b=n!=null&&n.matrix?wt[n.matrix]:1,k=n!=null&&n.fullRange?1:0;let g=`av01.${l}.${d}${u}.${f}`;return g+=`.${h}.${w.toString().padStart(3,"0")}`,g+=`.${c.toString().padStart(2,"0")}`,g+=`.${p.toString().padStart(2,"0")}`,g+=`.${b.toString().padStart(2,"0")}`,g+=`.${k}`,g.endsWith(Cr)&&(g=g.slice(0,-Cr.length)),g}}throw new TypeError(`Unhandled codec '${e}'.`)},ts=(t,e,r)=>{if(t==="aac")return e>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if(t==="mp3")return"mp3";if(t==="opus")return"opus";if(t==="vorbis")return"vorbis";if(t==="flac")return"flac";if(ne.includes(t))return t;throw new TypeError(`Unhandled codec '${t}'.`)},Jr=t=>{const{codec:e,codecDescription:r,aacCodecInfo:n}=t;if(e==="aac"){if(!n)throw new TypeError("AAC codec info must be provided.");return n.isMpeg2?"mp4a.67":`mp4a.40.${tn(r).objectType}`}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&ne.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},Pt=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],en=[-1,1,2,3,4,5,6,8],tn=t=>{if(!t||t.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new Z(t);let r=e.readBits(5);r===31&&(r=32+e.readBits(6));const n=e.readBits(4);let s=null;n===15?s=e.readBits(24):n<Pt.length&&(s=Pt[n]);const i=e.readBits(4);let a=null;return i>=1&&i<=7&&(a=en[i]),{objectType:r,frequencyIndex:n,sampleRate:s,channelConfiguration:i,numberOfChannels:a}},rs=48e3,rn=/^pcm-([usf])(\d+)+(be)?$/,He=t=>{if(m(ne.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=rn.exec(t);m(e);let r;e[1]==="u"?r="unsigned":e[1]==="s"?r="signed":r="float";const n=Number(e[2])/8,s=e[3]!=="be",i=t==="pcm-u8"?2**7:0;return{dataType:r,sampleSize:n,littleEndian:s,silentValue:i}},nn=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ulaw"?"ulaw":t==="alaw"?"alaw":rn.test(t)?t:t==="webvtt"?"webvtt":null,ns=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},ss=t=>t==="aac"?{aac:{format:"aac"}}:t==="opus"?{opus:{format:"opus"}}:{};class rt{constructor(e){this._factor=e}_toVideoBitrate(e,r,n){const s=r*n,i={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},a=1920*1080,o=3e6,l=Math.pow(s/a,.95),f=o*l*i[e]*this._factor;return Math.ceil(f/1e3)*1e3}_toAudioBitrate(e){if(ne.includes(e)||e==="flac")return;const n={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!n)throw new Error(`Unhandled codec: ${e}`);let s=n*this._factor;return e==="aac"?s=[96e3,128e3,16e4,192e3].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a):e==="opus"||e==="vorbis"?s=Math.max(6e3,s):e==="mp3"&&(s=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a)),Math.round(s/1e3)*1e3}}const Pr=new rt(4),is=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],as=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,os=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,cs=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,ls=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,us=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!is.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!It(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(gt);if(e.primaries!=null&&!r.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const n=Object.keys(kt);if(e.transfer!=null&&!n.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${n.join(", ")}.`);const s=Object.keys(wt);if(e.matrix!=null&&!s.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!as.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!os.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!cs.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!ls.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},ds=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],fs=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!ds.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!It(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!ne.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${ne.join(", ")}).`)},ms=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class hs{constructor(e){this.mutex=new We,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,r,n){r+=e.source._timestampOffset;let s=this.trackTimestampInfo.get(e);if(!s){if(!n)throw new Error("First frame must be a key frame.");s={maxTimestamp:r,maxTimestampBeforeLastKeyFrame:r},this.trackTimestampInfo.set(e,s)}if(r<0)throw new Error(`Timestamps must be non-negative (got ${r}s).`);if(n&&(s.maxTimestampBeforeLastKeyFrame=s.maxTimestamp),r<s.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a key frame and ends right before the next key frame). Got ${r}s, but highest timestamp is ${s.maxTimestampBeforeLastKeyFrame}s.`);return s.maxTimestamp=Math.max(s.maxTimestamp,r),r}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const vr=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,ps=t=>{const e=Math.floor(t/36e5),r=Math.floor(t%(60*60*1e3)/(60*1e3)),n=Math.floor(t%(60*1e3)/1e3),s=t%1e3;return e.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+n.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const mt=t=>{const e=[];let r=0;for(;r<t.length;){let n=-1,s=0;for(let i=r;i<t.length-3;i++){if(t[i]===0&&t[i+1]===0&&t[i+2]===1){n=i,s=3;break}if(i<t.length-4&&t[i]===0&&t[i+1]===0&&t[i+2]===0&&t[i+3]===1){n=i,s=4;break}}if(n===-1)break;if(r>0&&n>r){const i=t.subarray(r,n);i.length>0&&e.push(i)}r=n+s}if(r<t.length){const n=t.subarray(r);n.length>0&&e.push(n)}return e},Er=(t,e)=>{const r=[];let n=0;const s=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;n+e<=t.length;){let i;e===1?i=s.getUint8(n):e===2?i=s.getUint16(n,!1):e===3?i=(s.getUint16(n,!1)<<8)+s.getUint8(n+2):e===4?i=s.getUint32(n,!1):(rr(e),m(!1)),n+=e;const a=t.subarray(n,n+i);r.push(a),n+=i}return r},qt=t=>{const e=[],r=t.length;for(let n=0;n<r;n++)n+2<r&&t[n]===0&&t[n+1]===0&&t[n+2]===3?(e.push(0,0),n+=2):e.push(t[n]);return new Uint8Array(e)},gs=t=>{const r=mt(t);if(r.length===0)return null;let n=0;for(const o of r)n+=4+o.byteLength;const s=new Uint8Array(n),i=new DataView(s.buffer);let a=0;for(const o of r){const l=o.byteLength;i.setUint32(a,l,!1),a+=4,s.set(o,a),a+=o.byteLength}return s},St=t=>t[0]&31,sn=t=>{try{const e=mt(t),r=e.filter(h=>St(h)===7),n=e.filter(h=>St(h)===8),s=e.filter(h=>St(h)===13);if(r.length===0||n.length===0)return null;const i=r[0],a=new Z(qt(i));if(a.skipBits(1),a.skipBits(2),a.readBits(5)!==7)return console.error("Invalid SPS NAL unit type"),null;const l=a.readAlignedByte(),d=a.readAlignedByte(),u=a.readAlignedByte(),f={configurationVersion:1,avcProfileIndication:l,profileCompatibility:d,avcLevelIndication:u,lengthSizeMinusOne:3,sequenceParameterSets:r,pictureParameterSets:n,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(l===100||l===110||l===122||l===144){B(a);const h=B(a);h===3&&a.skipBits(1);const w=B(a),c=B(a);f.chromaFormat=h,f.bitDepthLumaMinus8=w,f.bitDepthChromaMinus8=c,f.sequenceParameterSetExt=s}return f}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},ks=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const r of t.sequenceParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let s=0;s<n;s++)e.push(r[s])}e.push(t.pictureParameterSets.length);for(const r of t.pictureParameterSets){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let s=0;s<n;s++)e.push(r[s])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){m(t.chromaFormat!==null),m(t.bitDepthLumaMinus8!==null),m(t.bitDepthChromaMinus8!==null),m(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const r of t.sequenceParameterSetExt){const n=r.byteLength;e.push(n>>8),e.push(n&255);for(let s=0;s<n;s++)e.push(r[s])}}return new Uint8Array(e)},Ir=32,_r=33,Fr=34,ws=39,bs=40,Fe=t=>t[0]>>1&63,an=t=>{try{const e=mt(t),r=e.filter(P=>Fe(P)===Ir),n=e.filter(P=>Fe(P)===_r),s=e.filter(P=>Fe(P)===Fr),i=e.filter(P=>Fe(P)===ws||Fe(P)===bs);if(n.length===0||s.length===0)return null;const a=n[0],o=new Z(qt(a));o.skipBits(16),o.readBits(4);const l=o.readBits(3),d=o.readBits(1),{general_profile_space:u,general_tier_flag:f,general_profile_idc:h,general_profile_compatibility_flags:w,general_constraint_indicator_flags:c,general_level_idc:p}=Ts(o,l);B(o);const b=B(o);b===3&&o.skipBits(1),B(o),B(o),o.readBits(1)&&(B(o),B(o),B(o),B(o));const k=B(o),g=B(o);B(o);const T=o.readBits(1)?0:l;for(let P=T;P<=l;P++)B(o),B(o),B(o);B(o),B(o),B(o),B(o),B(o),B(o),o.readBits(1)&&o.readBits(1)&&ys(o),o.skipBits(1),o.skipBits(1),o.readBits(1)&&(o.skipBits(4),o.skipBits(4),B(o),B(o),o.skipBits(1));const S=B(o);if(Ss(o,S),o.readBits(1)){const P=B(o);for(let A=0;A<P;A++)B(o),o.skipBits(1)}o.skipBits(1),o.skipBits(1);let x=0;o.readBits(1)&&(x=Cs(o,l));let C=0;if(s.length>0){const P=s[0],A=new Z(qt(P));A.skipBits(16),B(A),B(A),A.skipBits(1),A.skipBits(1),A.skipBits(3),A.skipBits(1),A.skipBits(1),B(A),B(A),dt(A),A.skipBits(1),A.skipBits(1),A.readBits(1)&&B(A),dt(A),dt(A),A.skipBits(1),A.skipBits(1),A.skipBits(1),A.skipBits(1);const M=A.readBits(1),X=A.readBits(1);!M&&!X?C=0:M&&!X?C=2:!M&&X?C=3:C=0}const _=[...r.length?[{arrayCompleteness:1,nalUnitType:Ir,nalUnits:r}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:_r,nalUnits:n}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:Fr,nalUnits:s}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:Fe(i[0]),nalUnits:i}]:[]];return{configurationVersion:1,generalProfileSpace:u,generalTierFlag:f,generalProfileIdc:h,generalProfileCompatibilityFlags:w,generalConstraintIndicatorFlags:c,generalLevelIdc:p,minSpatialSegmentationIdc:x,parallelismType:C,chromaFormatIdc:b,bitDepthLumaMinus8:k,bitDepthChromaMinus8:g,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:l+1,temporalIdNested:d,lengthSizeMinusOne:3,arrays:_}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Ts=(t,e)=>{const r=t.readBits(2),n=t.readBits(1),s=t.readBits(5);let i=0;for(let u=0;u<32;u++)i=i<<1|t.readBits(1);const a=new Uint8Array(6);for(let u=0;u<6;u++)a[u]=t.readBits(8);const o=t.readBits(8),l=[],d=[];for(let u=0;u<e;u++)l.push(t.readBits(1)),d.push(t.readBits(1));if(e>0)for(let u=e;u<8;u++)t.skipBits(2);for(let u=0;u<e;u++)l[u]&&t.skipBits(88),d[u]&&t.skipBits(8);return{general_profile_space:r,general_tier_flag:n,general_profile_idc:s,general_profile_compatibility_flags:i,general_constraint_indicator_flags:a,general_level_idc:o}},ys=t=>{for(let e=0;e<4;e++)for(let r=0;r<(e===3?2:6);r++)if(!t.readBits(1))B(t);else{const s=Math.min(64,1<<4+(e<<1));e>1&&dt(t);for(let i=0;i<s;i++)dt(t)}},Ss=(t,e)=>{const r=[];for(let n=0;n<e;n++)r[n]=xs(t,n,e,r)},xs=(t,e,r,n)=>{let s=0,i=0,a=0;if(e!==0&&(i=t.readBits(1)),i){if(e===r){const l=B(t);a=e-(l+1)}else a=e-1;t.readBits(1),B(t);const o=n[a]??0;for(let l=0;l<=o;l++)t.readBits(1)||t.readBits(1);s=n[a]}else{const o=B(t),l=B(t);for(let d=0;d<o;d++)B(t),t.readBits(1);for(let d=0;d<l;d++)B(t),t.readBits(1);s=o+l}return s},Cs=(t,e)=>{if(t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),t.readBits(1),t.readBits(1)&&(t.readBits(8),t.readBits(8),t.readBits(8))),t.readBits(1)&&(B(t),B(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(B(t),B(t),B(t),B(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&B(t),t.readBits(1)&&Ps(t,!0,e)),t.readBits(1)){t.readBits(1),t.readBits(1),t.readBits(1);const r=B(t);return B(t),B(t),B(t),B(t),r}return 0},Ps=(t,e,r)=>{let n=!1,s=!1,i=!1;n=t.readBits(1)===1,s=t.readBits(1)===1,(n||s)&&(i=t.readBits(1)===1,i&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),i&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5));for(let a=0;a<=r;a++){const o=t.readBits(1)===1;let l=!0;o||(l=t.readBits(1)===1);let d=!1;l?B(t):d=t.readBits(1)===1;let u=1;d||(u=B(t)+1),n&&Br(t,u,i),s&&Br(t,u,i)}},Br=(t,e,r)=>{for(let n=0;n<e;n++)B(t),B(t),r&&(B(t),B(t)),t.readBits(1)},vs=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const r of t.arrays){e.push((r.arrayCompleteness&1)<<7|0|r.nalUnitType&63),e.push(r.nalUnits.length>>8&255),e.push(r.nalUnits.length&255);for(const n of r.nalUnits){e.push(n.length>>8&255),e.push(n.length&255);for(let s=0;s<n.length;s++)e.push(n[s])}}return new Uint8Array(e)},on=t=>{const e=new Z(t);if(e.readBits(2)!==2)return null;const n=e.readBits(1),i=(e.readBits(1)<<1)+n;if(i===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let d=8;i>=2&&(d=e.readBits(1)?12:10);const u=e.readBits(3);let f=0,h=0;if(u!==7)if(h=e.readBits(1),i===1||i===3){const C=e.readBits(1),_=e.readBits(1);f=!C&&!_?3:C&&!_?2:1,e.skipBits(1)}else f=1;else f=3,h=1;const w=e.readBits(16),c=e.readBits(16),p=w+1,b=c+1,k=p*b;let g=K(Pe).level;for(const x of Pe)if(k<=x.maxPictureSize){g=x.level;break}return{profile:i,level:g,bitDepth:d,chromaSubsampling:f,videoFullRangeFlag:h,colourPrimaries:u===2?1:u===1?6:2,transferCharacteristics:u===2?1:u===1?6:2,matrixCoefficients:u===7?0:u===2?1:u===1?6:2}},cn=function*(t){const e=new Z(t),r=()=>{let n=0;for(let s=0;s<8;s++){const i=e.readAlignedByte();if(n|=(i&127)<<s*7,!(i&128))break;if(s===7&&i&128)return null}return n>=2**32-1?null:n};for(;e.getBitsLeft()>=8;){e.skipBits(1);const n=e.readBits(4),s=e.readBits(1),i=e.readBits(1);e.skipBits(1),s&&e.skipBits(8);let a;if(i){const o=r();if(o===null)return;a=o}else a=Math.floor(e.getBitsLeft()/8);m(e.pos%8===0),yield{type:n,data:t.subarray(e.pos/8,e.pos/8+a)},e.skipBits(a*8)}},ln=t=>{for(const{type:e,data:r}of cn(t)){if(e!==1)continue;const n=new Z(r),s=n.readBits(3);n.readBits(1);const i=n.readBits(1);let a=0,o=0,l=0;if(i)a=n.readBits(5);else{if(n.readBits(1)&&(n.skipBits(32),n.skipBits(32),n.readBits(1)))return null;const b=n.readBits(1);b&&(l=n.readBits(5),n.skipBits(32),n.skipBits(5),n.skipBits(5));const k=n.readBits(5);for(let g=0;g<=k;g++){n.skipBits(12);const y=n.readBits(5);if(g===0&&(a=y),y>7){const S=n.readBits(1);g===0&&(o=S)}if(b&&n.readBits(1)){const x=l+1;n.skipBits(x),n.skipBits(x),n.skipBits(1)}n.readBits(1)&&n.skipBits(4)}}const d=n.readBits(1);let u=8;s===2&&d?u=n.readBits(1)?12:10:s<=2&&(u=d?10:8);let f=0;s!==1&&(f=n.readBits(1));let h=1,w=1,c=0;return f||(s===0?(h=1,w=1):s===1?(h=0,w=0):u===12&&(h=n.readBits(1),h&&(w=n.readBits(1))),h&&w&&(c=n.readBits(2))),{profile:s,level:a,tier:o,bitDepth:u,monochrome:f,chromaSubsamplingX:h,chromaSubsamplingY:w,chromaSamplePosition:c}}return null},un=t=>{const e=ae(t),r=e.getUint8(9),n=e.getUint16(10,!0),s=e.getUint32(12,!0),i=e.getInt16(16,!0),a=e.getUint8(18);let o=null;return a&&(o=t.subarray(19,21+r)),{outputChannelCount:r,preSkip:n,inputSampleRate:s,outputGain:i,channelMappingFamily:a,channelMappingTable:o}},Es=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],Is=t=>{const e=t[0]>>3;return{durationInSamples:Es[e]}},_s=t=>{if(t.length<7)throw new Error("Setup header is too short.");if(t[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...t.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const r=t.length,n=new Uint8Array(r);for(let f=0;f<r;f++)n[f]=t[r-1-f];const s=new Z(n);let i=0;for(;s.getBitsLeft()>97;)if(s.readBits(1)===1){i=s.pos;break}if(i===0)throw new Error("Invalid Setup header: framing bit not found.");let a=0,o=!1,l=0;for(;s.getBitsLeft()>=97;){const f=s.pos,h=s.readBits(8),w=s.readBits(16),c=s.readBits(16);if(h>63||w!==0||c!==0){s.pos=f;break}if(s.skipBits(1),a++,a>64)break;s.clone().readBits(6)+1===a&&(o=!0,l=a)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(l>63)throw new Error(`Unsupported mode count: ${l}.`);const d=l;s.pos=0,s.skipBits(i);const u=Array(d).fill(0);for(let f=d-1;f>=0;f--)s.skipBits(40),u[f]=s.readBits(1);return{modeBlockflags:u}},Fs=async(t,e)=>{switch(m(t.codec),t.codec){case"avc":{const r=await t.getDecoderConfig();m(r);let n;if(r.description){const o=(me(r.description)[4]&3)+1;n=Er(e.data,o)}else n=mt(e.data);return n.some(i=>St(i)===5)?"key":"delta"}case"hevc":{const r=await t.getDecoderConfig();m(r);let n;if(r.description){const o=(me(r.description)[21]&3)+1;n=Er(e.data,o)}else n=mt(e.data);return n.some(i=>{const a=Fe(i);return 16<=a&&a<=23})?"key":"delta"}case"vp8":return(e.data[0]&1)===0?"key":"delta";case"vp9":{const r=new Z(e.data);if(r.readBits(2)!==2)return null;const n=r.readBits(1);return(r.readBits(1)<<1)+n===3&&r.skipBits(1),r.readBits(1)?null:r.readBits(1)===0?"key":"delta"}case"av1":{let r=!1;for(const{type:n,data:s}of cn(e.data))if(n===1){const i=new Z(s);i.skipBits(4),r=!!i.readBits(1)}else if(n===3||n===6||n===7){if(r)return"key";const i=new Z(s);return i.readBits(1)?null:i.readBits(2)===0?"key":"delta"}return null}default:rr(t.codec),m(!1)}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ar{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let r=0;r<e.length;r++)this.helperView.setUint8(r%8,e.charCodeAt(r)),r%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const r=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const i of e.children)i&&this.writeBox(i);const n=this.writer.getPos(),s=e.size??n-r;this.writer.seek(r),this.writeBoxHeader(e,s),this.writer.seek(n)}}writeBoxHeader(e,r){this.writeU32(e.largeSize?1:r),this.writeAscii(e.type),e.largeSize&&this.writeU64(r)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const r=this.offsets.get(e);m(r!==void 0);const n=this.writer.getPos();this.writer.seek(r),this.writeBox(e),this.writer.seek(n)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let r=this.measureBoxHeader(e);if(e.contents&&(r+=e.contents.byteLength),e.children)for(const n of e.children)n&&(r+=this.measureBox(n));return r}}}const N=new Uint8Array(8),he=new DataView(N.buffer),L=t=>[(t%256+256)%256],R=t=>(he.setUint16(0,t,!1),[N[0],N[1]]),dn=t=>(he.setInt16(0,t,!1),[N[0],N[1]]),fn=t=>(he.setUint32(0,t,!1),[N[1],N[2],N[3]]),I=t=>(he.setUint32(0,t,!1),[N[0],N[1],N[2],N[3]]),ye=t=>(he.setInt32(0,t,!1),[N[0],N[1],N[2],N[3]]),Ue=t=>(he.setUint32(0,Math.floor(t/2**32),!1),he.setUint32(4,t,!1),[N[0],N[1],N[2],N[3],N[4],N[5],N[6],N[7]]),mn=t=>(he.setInt16(0,2**8*t,!1),[N[0],N[1]]),be=t=>(he.setInt32(0,2**16*t,!1),[N[0],N[1],N[2],N[3]]),Bt=t=>(he.setInt32(0,2**30*t,!1),[N[0],N[1],N[2],N[3]]),At=(t,e)=>{const r=[];let n=t;do{let s=n&127;n>>=7,r.length>0&&(s|=128),r.push(s)}while(n>0||e);return r.reverse()},J=(t,e=!1)=>{const r=Array(t.length).fill(null).map((n,s)=>t.charCodeAt(s));return e&&r.push(0),r},sr=t=>{let e=null;for(const r of t)(!e||r.timestamp>e.timestamp)&&(e=r);return e},hn=t=>{const e=t*(Math.PI/180),r=Math.round(Math.cos(e)),n=Math.round(Math.sin(e));return[r,n,0,-n,r,0,0,0,1]},pn=hn(0),gn=t=>[be(t[0]),be(t[1]),Bt(t[2]),be(t[3]),be(t[4]),Bt(t[5]),be(t[6]),be(t[7]),Bt(t[8])],D=(t,e,r)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:r}),V=(t,e,r,n,s)=>D(t,[L(e),fn(r),n??[]],s),Bs=t=>t.isQuickTime?D("ftyp",[J("qt  "),I(512),J("qt  ")]):t.fragmented?D("ftyp",[J("iso5"),I(512),J("iso5"),J("iso6"),J("mp41")]):D("ftyp",[J("isom"),I(512),J("isom"),t.holdsAvc?J("avc1"):[],J("mp41")]),zt=t=>({type:"mdat",largeSize:t}),Tt=(t,e,r=!1)=>D("moov",void 0,[As(e,t),...t.map(n=>zs(n,e)),r?pi(t):null]),As=(t,e)=>{const r=Q(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{const o=sr(a.samples);return o.timestamp+o.duration})),jt),n=Math.max(0,...e.map(a=>a.track.id))+1,s=!et(t)||!et(r),i=s?Ue:I;return V("mvhd",+s,0,[i(t),i(t),I(jt),i(r),be(1),mn(1),Array(10).fill(0),gn(pn),Array(24).fill(0),I(n)])},zs=(t,e)=>{const r=qi(t);return D("trak",void 0,[Os(t,e),Ms(t,e),r.name!==void 0?D("udta",void 0,[D("Â©nam",[...Ae.encode(r.name)])]):null])},Os=(t,e)=>{const r=sr(t.samples),n=Q(r?r.timestamp+r.duration:0,jt),s=!et(e)||!et(n),i=s?Ue:I;let a;if(t.type==="video"){const o=t.track.metadata.rotation;a=hn(o??0)}else a=pn;return V("tkhd",+s,3,[i(e),i(e),I(t.track.id),I(0),i(n),Array(8).fill(0),R(0),R(t.track.id),mn(t.type==="audio"?1:0),R(0),gn(a),be(t.type==="video"?t.info.width:0),be(t.type==="video"?t.info.height:0)])},Ms=(t,e)=>D("mdia",void 0,[Rs(t,e),Vs(!0,Ds[t.type],Ns[t.type]),Us(t)]),Rs=(t,e)=>{const r=sr(t.samples),n=Q(r?r.timestamp+r.duration:0,t.timescale),s=!et(e)||!et(n),i=s?Ue:I;let a=0;for(const o of t.track.metadata.languageCode??ce)a<<=5,a+=o.charCodeAt(0)-96;return V("mdhd",+s,0,[i(e),i(e),I(t.timescale),i(n),R(a),R(0)])},Ds={video:"vide",audio:"soun",subtitle:"text"},Ns={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Vs=(t,e,r)=>V("hdlr",0,0,[J("mhlr"),J(e),I(0),I(0),I(0),J(r,!0)]),Us=t=>D("minf",void 0,[qs[t.type](),$s(),Qs(t)]),Ws=()=>V("vmhd",0,1,[R(0),R(0),R(0),R(0)]),Hs=()=>V("smhd",0,0,[R(0),R(0)]),Ls=()=>V("nmhd",0,0),qs={video:Ws,audio:Hs,subtitle:Ls},$s=()=>D("dinf",void 0,[js()]),js=()=>V("dref",0,0,[I(1)],[Ks()]),Ks=()=>V("url ",0,1),Qs=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(r=>r.sampleCompositionTimeOffset!==0);return D("stbl",void 0,[Xs(t),ci(t),e?mi(t):null,e?hi(t):null,ui(t),di(t),fi(t),li(t)])},Xs=t=>{let e;if(t.type==="video")e=Gs(Ii[t.track.source._codec],t);else if(t.type==="audio"){const r=wn(t.track.source._codec,t.muxer.isQuickTime);m(r),e=ti(r,t)}else t.type==="subtitle"&&(e=ai(Bi[t.track.source._codec],t));return m(e),V("stsd",0,0,[I(1)],[e])},Gs=(t,e)=>D(t,[Array(6).fill(0),R(1),R(0),R(0),Array(12).fill(0),R(e.info.width),R(e.info.height),I(4718592),I(4718592),I(0),R(1),Array(32).fill(0),R(24),dn(65535)],[_i[e.track.source._codec](e),Kn(e.info.decoderConfig.colorSpace)?Ys(e):null]),Ys=t=>D("colr",[J("nclx"),R(gt[t.info.decoderConfig.colorSpace.primaries]),R(kt[t.info.decoderConfig.colorSpace.transfer]),R(wt[t.info.decoderConfig.colorSpace.matrix]),L((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Zs=t=>t.info.decoderConfig&&D("avcC",[...me(t.info.decoderConfig.description)]),Js=t=>t.info.decoderConfig&&D("hvcC",[...me(t.info.decoderConfig.description)]),zr=t=>{var h,w,c,p;if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,r=e.codec.split("."),n=Number(r[1]),s=Number(r[2]),i=Number(r[3]),a=r[4]?Number(r[4]):1,o=r[8]?Number(r[8]):Number(((h=e.colorSpace)==null?void 0:h.fullRange)??0),l=(i<<4)+(a<<1)+o,d=r[5]?Number(r[5]):(w=e.colorSpace)!=null&&w.primaries?gt[e.colorSpace.primaries]:2,u=r[6]?Number(r[6]):(c=e.colorSpace)!=null&&c.transfer?kt[e.colorSpace.transfer]:2,f=r[7]?Number(r[7]):(p=e.colorSpace)!=null&&p.matrix?wt[e.colorSpace.matrix]:2;return V("vpcC",1,0,[L(n),L(s),L(l),L(d),L(u),L(f),R(0)])},ei=t=>D("av1C",es(t.info.decoderConfig.codec)),ti=(t,e)=>{var i;let r=0,n,s=16;if(ne.includes(e.track.source._codec)){const a=e.track.source._codec,{sampleSize:o}=He(a);s=8*o,s>16&&(r=1)}return r===0?n=[Array(6).fill(0),R(1),R(r),R(0),I(0),R(e.info.numberOfChannels),R(s),R(0),R(0),R(e.info.sampleRate<2**16?e.info.sampleRate:0),R(0)]:n=[Array(6).fill(0),R(1),R(r),R(0),I(0),R(e.info.numberOfChannels),R(Math.min(s,16)),R(0),R(0),R(e.info.sampleRate<2**16?e.info.sampleRate:0),R(0),I(1),I(s/8),I(e.info.numberOfChannels*s/8),I(2)],D(t,n,[((i=Fi(e.track.source._codec,e.muxer.isQuickTime))==null?void 0:i(e))??null])},Ot=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let r=[...L(e),...L(21),...fn(0),...I(0),...I(0)];if(t.info.decoderConfig.description){const n=me(t.info.decoderConfig.description);r=[...r,...L(5),...At(n.byteLength),...n]}return r=[...R(1),...L(0),...L(4),...At(r.length),...r,...L(6),...L(1),...L(2)],r=[...L(3),...At(r.length),...r],V("esds",0,0,r)},Te=t=>D("wave",void 0,[ri(t),ni(t),D("\0\0\0\0")]),ri=t=>D("frma",[J(wn(t.track.source._codec,t.muxer.isQuickTime))]),ni=t=>{const{littleEndian:e}=He(t.track.source._codec);return D("enda",[R(+e)])},si=t=>{var l;let e=t.info.numberOfChannels,r=3840,n=t.info.sampleRate,s=0,i=0,a=new Uint8Array(0);const o=(l=t.info.decoderConfig)==null?void 0:l.description;if(o){m(o.byteLength>=18);const d=me(o),u=un(d);e=u.outputChannelCount,r=u.preSkip,n=u.inputSampleRate,s=u.outputGain,i=u.channelMappingFamily,u.channelMappingTable&&(a=u.channelMappingTable)}return D("dOps",[L(0),L(e),R(r),I(n),dn(s),L(i),...a])},ii=t=>{var n;const e=(n=t.info.decoderConfig)==null?void 0:n.description;m(e);const r=me(e);return V("dfLa",0,0,[...r.subarray(4)])},ue=t=>{const{littleEndian:e,sampleSize:r}=He(t.track.source._codec),n=+e;return V("pcmC",0,0,[L(n),L(8*r)])},ai=(t,e)=>D(t,[Array(6).fill(0),R(1)],[Ai[e.track.source._codec](e)]),oi=t=>D("vttC",[...Ae.encode(t.info.config.description)]),ci=t=>V("stts",0,0,[I(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[I(e.sampleCount),I(e.sampleDelta)])]),li=t=>{if(t.samples.every(r=>r.type==="key"))return null;const e=[...t.samples.entries()].filter(([,r])=>r.type==="key");return V("stss",0,0,[I(e.length),e.map(([r])=>I(r+1))])},ui=t=>V("stsc",0,0,[I(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[I(e.firstChunk),I(e.samplesPerChunk),I(1)])]),di=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=He(t.track.source._codec);return V("stsz",0,0,[I(e*t.info.numberOfChannels),I(t.samples.reduce((r,n)=>r+Q(n.duration,t.timescale),0))])}return V("stsz",0,0,[I(0),I(t.samples.length),t.samples.map(e=>I(e.size))])},fi=t=>t.finalizedChunks.length>0&&K(t.finalizedChunks).offset>=2**32?V("co64",0,0,[I(t.finalizedChunks.length),t.finalizedChunks.map(e=>Ue(e.offset))]):V("stco",0,0,[I(t.finalizedChunks.length),t.finalizedChunks.map(e=>I(e.offset))]),mi=t=>V("ctts",1,0,[I(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[I(e.sampleCount),ye(e.sampleCompositionTimeOffset)])]),hi=t=>{let e=1/0,r=-1/0,n=1/0,s=-1/0;m(t.compositionTimeOffsetTable.length>0),m(t.samples.length>0);for(let a=0;a<t.compositionTimeOffsetTable.length;a++){const o=t.compositionTimeOffsetTable[a];e=Math.min(e,o.sampleCompositionTimeOffset),r=Math.max(r,o.sampleCompositionTimeOffset)}for(let a=0;a<t.samples.length;a++){const o=t.samples[a];n=Math.min(n,Q(o.timestamp,t.timescale)),s=Math.max(s,Q(o.timestamp+o.duration,t.timescale))}const i=Math.max(-e,0);return s>=2**31?null:V("cslg",0,0,[ye(i),ye(e),ye(r),ye(n),ye(s)])},pi=t=>D("mvex",void 0,t.map(gi)),gi=t=>V("trex",0,0,[I(t.track.id),I(1),I(0),I(0),I(0)]),Or=(t,e)=>D("moof",void 0,[ki(t),...e.map(wi)]),ki=t=>V("mfhd",0,0,[I(t)]),kn=t=>{let e=0,r=0;const n=0,s=0,i=t.type==="delta";return r|=+i,i?e|=1:e|=2,e<<24|r<<16|n<<8|s},wi=t=>D("traf",void 0,[bi(t),Ti(t),yi(t)]),bi=t=>{m(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const r=t.currentChunk.samples[1]??t.currentChunk.samples[0],n={duration:r.timescaleUnitsToNextSample,size:r.size,flags:kn(r)};return V("tfhd",0,e,[I(t.track.id),I(n.duration),I(n.size),I(n.flags)])},Ti=t=>(m(t.currentChunk),V("tfdt",1,0,[Ue(Q(t.currentChunk.startTimestamp,t.timescale))])),yi=t=>{m(t.currentChunk);const e=t.currentChunk.samples.map(p=>p.timescaleUnitsToNextSample),r=t.currentChunk.samples.map(p=>p.size),n=t.currentChunk.samples.map(kn),s=t.currentChunk.samples.map(p=>Q(p.timestamp-p.decodeTimestamp,t.timescale)),i=new Set(e),a=new Set(r),o=new Set(n),l=new Set(s),d=o.size===2&&n[0]!==n[1],u=i.size>1,f=a.size>1,h=!d&&o.size>1,w=l.size>1||[...l].some(p=>p!==0);let c=0;return c|=1,c|=4*+d,c|=256*+u,c|=512*+f,c|=1024*+h,c|=2048*+w,V("trun",1,c,[I(t.currentChunk.samples.length),I(t.currentChunk.offset-t.currentChunk.moofOffset||0),d?I(n[0]):[],t.currentChunk.samples.map((p,b)=>[u?I(e[b]):[],f?I(r[b]):[],h?I(n[b]):[],w?ye(s[b]):[]])])},Si=t=>D("mfra",void 0,[...t.map(xi),Ci()]),xi=(t,e)=>V("tfra",1,0,[I(t.track.id),I(63),I(t.finalizedChunks.length),t.finalizedChunks.map(n=>[Ue(Q(n.samples[0].timestamp,t.timescale)),Ue(n.moofOffset),I(e+1),I(1),I(1)])]),Ci=()=>V("mfro",0,0,[I(0)]),Pi=()=>D("vtte"),vi=(t,e,r,n,s)=>D("vttc",void 0,[s!==null?D("vsid",[ye(s)]):null,r!==null?D("iden",[...Ae.encode(r)]):null,e!==null?D("ctim",[...Ae.encode(ps(e))]):null,n!==null?D("sttg",[...Ae.encode(n)]):null,D("payl",[...Ae.encode(t)])]),Ei=t=>D("vtta",[...Ae.encode(t)]),Ii={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},_i={avc:Zs,hevc:Js,vp8:zr,vp9:zr,av1:ei},wn=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},Fi=(t,e)=>{switch(t){case"aac":return Ot;case"mp3":return Ot;case"opus":return si;case"vorbis":return Ot;case"flac":return ii}if(e)switch(t){case"pcm-s24":return Te;case"pcm-s24be":return Te;case"pcm-s32":return Te;case"pcm-s32be":return Te;case"pcm-f32":return Te;case"pcm-f32be":return Te;case"pcm-f64":return Te;case"pcm-f64be":return Te}else switch(t){case"pcm-s16":return ue;case"pcm-s16be":return ue;case"pcm-s24":return ue;case"pcm-s24be":return ue;case"pcm-s32":return ue;case"pcm-s32be":return ue;case"pcm-f32":return ue;case"pcm-f32be":return ue;case"pcm-f64":return ue;case"pcm-f64be":return ue}return null},Bi={webvtt:"wvtt"},Ai={webvtt:oi};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class bn{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let r=this.getPos();if(r<this.trackedStart){if(r+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-r),r=0}const n=r+e.byteLength-this.trackedStart;let s=this.trackedWrites.byteLength;for(;s<n;)s*=2;if(s!==this.trackedWrites.byteLength){const i=new Uint8Array(s);i.set(this.trackedWrites,0),this.trackedWrites=i}this.trackedWrites.set(e,r-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,r+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const r={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,r}}const Mt=2**16,Rt=2**32;class Tn extends bn{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Mt,{maxByteLength:Rt})}catch{this.buffer=new ArrayBuffer(Mt),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Mt);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let r=this.buffer.byteLength;for(;r<e;)r*=2;if(r!==this.buffer.byteLength){if(r>Rt)throw new Error(`ArrayBuffer exceeded maximum size of ${Rt} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(r);else{const n=new ArrayBuffer(r),s=new Uint8Array(n);s.set(this.bytes,0),this.buffer=n,this.bytes=s}}}write(e){var r,n;this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),(n=(r=this.target).onwrite)==null||n.call(r,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,r){return this.bytes.slice(e,r)}}const zi=2**24,Oi=2;class Mi extends bn{constructor(e){super(),this.pos=0,this.sections=[],this.lastWriteEnd=0,this.lastFlushEnd=0,this.writer=null,this.chunks=[],this.target=e,this.chunked=e._options.chunked??!1,this.chunkSize=e._options.chunkSize??zi}start(){this.writer=this.target._writable.getWriter()}write(e){var r,n;if(this.pos>this.lastWriteEnd){const s=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(s))}this.maybeTrackWrites(e),this.sections.push({data:e.slice(),start:this.pos}),(n=(r=this.target).onwrite)==null||n.call(r,this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.lastWriteEnd=Math.max(this.lastWriteEnd,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(this.pos>this.lastWriteEnd){const n=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(n))}if(m(this.writer),this.sections.length===0)return;const e=[],r=[...this.sections].sort((n,s)=>n.start-s.start);e.push({start:r[0].start,size:r[0].data.byteLength});for(let n=1;n<r.length;n++){const s=e[e.length-1],i=r[n];i.start<=s.start+s.size?s.size=Math.max(s.size,i.start+i.data.byteLength-s.start):e.push({start:i.start,size:i.data.byteLength})}for(const n of e){n.data=new Uint8Array(n.size);for(const s of this.sections)n.start<=s.start&&s.start<n.start+n.size&&n.data.set(s.data,s.start-n.start);if(this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.chunked)this.writeDataIntoChunks(n.data,n.start),this.tryToFlushChunks();else{if(this.ensureMonotonicity&&n.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:n.data,position:n.start}),this.lastFlushEnd=n.start+n.data.byteLength}}this.sections.length=0}writeDataIntoChunks(e,r){let n=this.chunks.findIndex(l=>l.start<=r&&r<l.start+this.chunkSize);n===-1&&(n=this.createChunk(r));const s=this.chunks[n],i=r-s.start,a=e.subarray(0,Math.min(this.chunkSize-i,e.byteLength));s.data.set(a,i);const o={start:i,end:i+a.byteLength};if(this.insertSectionIntoChunk(s,o),s.written[0].start===0&&s.written[0].end===this.chunkSize&&(s.shouldFlush=!0),this.chunks.length>Oi){for(let l=0;l<this.chunks.length-1;l++)this.chunks[l].shouldFlush=!0;this.tryToFlushChunks()}a.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(a.byteLength),r+a.byteLength)}insertSectionIntoChunk(e,r){let n=0,s=e.written.length-1,i=-1;for(;n<=s;){const a=Math.floor(n+(s-n+1)/2);e.written[a].start<=r.start?(n=a+1,i=a):s=a-1}for(e.written.splice(i+1,0,r),(i===-1||e.written[i].end<r.start)&&i++;i<e.written.length-1&&e.written[i].end>=e.written[i+1].start;)e.written[i].end=Math.max(e.written[i].end,e.written[i+1].end),e.written.splice(i+1,1)}createChunk(e){const n={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(n),this.chunks.sort((s,i)=>s.start-i.start),this.chunks.indexOf(n)}tryToFlushChunks(e=!1){m(this.writer);for(let r=0;r<this.chunks.length;r++){const n=this.chunks[r];if(!(!n.shouldFlush&&!e)){for(const s of n.written){const i=n.start+s.start;if(this.ensureMonotonicity&&i!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:n.data.subarray(s.start,s.end),position:i}),this.lastFlushEnd=n.start+s.end}this.chunks.splice(r--,1)}}}finalize(){return this.chunked&&this.tryToFlushChunks(!0),m(this.writer),this.writer.close()}async close(){var e;return(e=this.writer)==null?void 0:e.close()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ir{constructor(){this._output=null,this.onwrite=null}}class Ri extends ir{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new Tn(this)}}class Di extends ir{constructor(e,r={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(r!=null&&typeof r!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(r.chunked!==void 0&&typeof r.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(r.chunkSize!==void 0&&(!Number.isInteger(r.chunkSize)||r.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an integer and not smaller than 1024.");this._writable=e,this._options=r}_createWriter(){return new Mi(this)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const yn=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings)];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ni{constructor(e){this.source=e}requestSlice(e,r){if(this.fileSize!==null&&e+r>this.fileSize)return null;const n=e+r,s=this.source._read(e,n);return s instanceof Promise?s.then(i=>i?new tt(i.bytes,i.view,i.offset,e,n):null):s?new tt(s.bytes,s.view,s.offset,e,n):null}requestSliceRange(e,r,n){if(this.fileSize!==null)return this.requestSlice(e,Y(this.fileSize-e,r,n));{const s=this.requestSlice(e,n),i=a=>{if(a)return a;const o=d=>(m(d!==null),this.requestSlice(e,Y(d-e,r,n))),l=this.source._retrieveSize();return l instanceof Promise?l.then(o):o(l)};return s instanceof Promise?s.then(i):i(s)}}}class tt{constructor(e,r,n,s,i){this.bytes=e,this.view=r,this.offset=n,this.start=s,this.end=i,this.bufferPos=s-n}static tempFromBytes(e){return new tt(e,ae(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}skip(e){this.bufferPos+=e}slice(e,r=this.end-e){if(e<this.start||e+r>this.end)throw new RangeError("Slicing outside of original slice.");return new tt(this.bytes,this.view,this.offset,e,e+r)}}const q=(t,e)=>{const r=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,r},O=t=>t.view.getUint8(t.bufferPos++),st=(t,e)=>{const r=t.view.getUint16(t.bufferPos,e);return t.bufferPos+=2,r},te=t=>{const e=t.view.getUint16(t.bufferPos,!1);return t.bufferPos+=2,e},it=t=>{const e=te(t),r=O(t);return e*256+r},$t=t=>{const e=t.view.getInt16(t.bufferPos,!1);return t.bufferPos+=2,e},ze=(t,e)=>{const r=t.view.getUint32(t.bufferPos,e);return t.bufferPos+=4,r},F=t=>{const e=t.view.getUint32(t.bufferPos,!1);return t.bufferPos+=4,e},Ye=t=>{const e=t.view.getUint32(t.bufferPos,!0);return t.bufferPos+=4,e},Oe=t=>{const e=t.view.getInt32(t.bufferPos,!1);return t.bufferPos+=4,e},Vi=t=>{const e=t.view.getInt32(t.bufferPos,!0);return t.bufferPos+=4,e},Mr=(t,e)=>{let r,n;return e?(r=ze(t,!0),n=ze(t,!0)):(n=ze(t,!1),r=ze(t,!1)),n*4294967296+r},ie=t=>{const e=F(t),r=F(t);return e*4294967296+r},Ui=t=>{const e=Oe(t),r=F(t);return e*4294967296+r},Wi=t=>{const e=Ye(t);return Vi(t)*4294967296+e},Hi=t=>{const e=t.view.getFloat32(t.bufferPos,!1);return t.bufferPos+=4,e},Sn=t=>{const e=t.view.getFloat64(t.bufferPos,!1);return t.bufferPos+=8,e},re=(t,e)=>{if(t.bufferPos+e>t.bytes.length)throw new RangeError("Reading past end of slice.");let r="";for(let n=0;n<e;n++)r+=String.fromCharCode(t.bytes[t.bufferPos++]);return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const fe=8,Se=16,Be=t=>{let e=F(t);const r=re(t,4);let n=8;e===1&&(e=ie(t),n=16);const i=e-n;return i<0?null:{name:r,totalSize:e,headerSize:n,contentSize:i}},_e=t=>Oe(t)/65536,Dt=t=>Oe(t)/1073741824,Nt=t=>{let e=0;for(let r=0;r<4;r++){e<<=7;const n=O(t);if(e|=n&127,(n&128)===0)break}return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const jt=1e3,Li=2082844800,qi=t=>{const e={},r=t.track;return r.metadata.name!==void 0&&(e.name=r.metadata.name),e},Q=(t,e,r=!0)=>{const n=t*e;return r?Math.round(n):n};class $i extends hs{constructor(e,r){super(e),this.auxTarget=new Ri,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new Ar(this.auxWriter),this.mdat=null,this.trackDatas=[],this.allTracksKnown=Ge(),this.creationTime=Math.floor(Date.now()/1e3)+Li,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=r,this.writer=e._writer,this.boxWriter=new Ar(this.writer),this.isQuickTime=r instanceof An;const n=this.writer instanceof Tn?"in-memory":!1;this.fastStart=r._options.fastStart??n,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=r._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),r=this.output._tracks.some(n=>n.type==="video"&&n.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(Bs({isQuickTime:this.isQuickTime,holdsAvc:r,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:n,start:s}=this.writer.stopTrackingWrites();this.format._options.onFtyp(n,s)}this.fastStart==="in-memory"?this.mdat=zt(!1):this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=zt(!0),this.boxWriter.writeBox(this.mdat)),await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(r=>r.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(r=>r.type==="video"||r.type==="audio"?r.info.decoderConfig.codec:{webvtt:"wvtt"}[r.track.source._codec]);return yn({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(r=>r.type==="video"),hasAudio:this.trackDatas.some(r=>r.type==="audio"),codecStrings:e})}getVideoTrackData(e,r,n){const s=this.trackDatas.find(d=>d.track===e);if(s)return s;us(n),m(n),m(n.decoderConfig);const i={...n.decoderConfig};m(i.codedWidth!==void 0),m(i.codedHeight!==void 0);let a=!1;if(e.source._codec==="avc"&&!i.description){const d=sn(r.data);if(!d)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");i.description=ks(d),a=!0}else if(e.source._codec==="hevc"&&!i.description){const d=an(r.data);if(!d)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");i.description=vs(d),a=!0}const o=Zn(1/(e.metadata.frameRate??57600),1e6).denominator,l={muxer:this,track:e,type:"video",info:{width:i.codedWidth,height:i.codedHeight,decoderConfig:i,requiresAnnexBTransformation:a},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(l),this.trackDatas.sort((d,u)=>d.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),l}getAudioTrackData(e,r){const n=this.trackDatas.find(i=>i.track===e);if(n)return n;fs(r),m(r),m(r.decoderConfig);const s={muxer:this,track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:r.decoderConfig,requiresPcmTransformation:!this.isFragmented&&ne.includes(e.source._codec)},timescale:r.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(s),this.trackDatas.sort((i,a)=>i.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getSubtitleTrackData(e,r){const n=this.trackDatas.find(i=>i.track===e);if(n)return n;ms(r),m(r),m(r.config);const s={muxer:this,track:e,type:"subtitle",info:{config:r.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort((i,a)=>i.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,r,n){const s=await this.mutex.acquire();try{const i=this.getVideoTrackData(e,r,n);let a=r.data;if(i.info.requiresAnnexBTransformation){const d=gs(a);if(!d)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");a=d}const o=this.validateAndNormalizeTimestamp(i.track,r.timestamp,r.type==="key"),l=this.createSampleForTrack(i,a,o,r.duration,r.type);await this.registerSample(i,l)}finally{s()}}async addEncodedAudioPacket(e,r,n){const s=await this.mutex.acquire();try{const i=this.getAudioTrackData(e,n),a=this.validateAndNormalizeTimestamp(i.track,r.timestamp,r.type==="key"),o=this.createSampleForTrack(i,r.data,a,r.duration,r.type);i.info.requiresPcmTransformation&&await this.maybePadWithSilence(i,a),await this.registerSample(i,o)}finally{s()}}async maybePadWithSilence(e,r){const n=K(e.samples),s=n?n.timestamp+n.duration:0,i=r-s,a=Q(i,e.timescale);if(a>0){const{sampleSize:o,silentValue:l}=He(e.info.decoderConfig.codec),d=a*e.info.numberOfChannels,u=new Uint8Array(o*d).fill(l),f=this.createSampleForTrack(e,new Uint8Array(u.buffer),s,i,"key");await this.registerSample(e,f)}}async addSubtitleCue(e,r,n){const s=await this.mutex.acquire();try{const i=this.getSubtitleTrackData(e,n);this.validateAndNormalizeTimestamp(i.track,r.timestamp,!0),e.source._codec==="webvtt"&&(i.cueQueue.push(r),await this.processWebVTTCues(i,r.timestamp))}finally{s()}}async processWebVTTCues(e,r){for(;e.cueQueue.length>0;){const n=new Set([]);for(const d of e.cueQueue)m(d.timestamp<=r),m(e.lastCueEndTimestamp<=d.timestamp+d.duration),n.add(Math.max(d.timestamp,e.lastCueEndTimestamp)),n.add(d.timestamp+d.duration);const s=[...n].sort((d,u)=>d-u),i=s[0],a=s[1]??i;if(r<a)break;if(e.lastCueEndTimestamp<i){this.auxWriter.seek(0);const d=Pi();this.auxBoxWriter.writeBox(d);const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),f=this.createSampleForTrack(e,u,e.lastCueEndTimestamp,i-e.lastCueEndTimestamp,"key");await this.registerSample(e,f),e.lastCueEndTimestamp=i}this.auxWriter.seek(0);for(let d=0;d<e.cueQueue.length;d++){const u=e.cueQueue[d];if(u.timestamp>=a)break;vr.lastIndex=0;const f=vr.test(u.text),h=u.timestamp+u.duration;let w=e.cueToSourceId.get(u);if(w===void 0&&a<h&&(w=e.nextSourceId++,e.cueToSourceId.set(u,w)),u.notes){const p=Ei(u.notes);this.auxBoxWriter.writeBox(p)}const c=vi(u.text,f?i:null,u.identifier??null,u.settings??null,w??null);this.auxBoxWriter.writeBox(c),h===a&&e.cueQueue.splice(d--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),l=this.createSampleForTrack(e,o,i,a-i,"key");await this.registerSample(e,l),e.lastCueEndTimestamp=a}}createSampleForTrack(e,r,n,s,i){return{timestamp:n,decodeTimestamp:n,duration:s,data:r,size:r.byteLength,type:i,timescaleUnitsToNextSample:Q(s,e.timescale)}}processTimestamps(e,r){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let s=0;for(let i=0;i<e.timestampProcessingQueue.length;i++){const a=e.timestampProcessingQueue[i],o=Q(a.duration,e.timescale);s+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:s,sampleDelta:1});else{const i=K(e.timeToSampleTable);i.sampleCount+=s}e.timestampProcessingQueue.length=0;return}const n=e.timestampProcessingQueue.map(s=>s.timestamp).sort((s,i)=>s-i);for(let s=0;s<e.timestampProcessingQueue.length;s++){const i=e.timestampProcessingQueue[s];i.decodeTimestamp=n[s],!this.isFragmented&&e.lastTimescaleUnits===null&&(i.decodeTimestamp=0);const a=Q(i.timestamp-i.decodeTimestamp,e.timescale),o=Q(i.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);const l=Q(i.decodeTimestamp,e.timescale,!1),d=Math.round(l-e.lastTimescaleUnits);if(m(d>=0),e.lastTimescaleUnits+=d,e.lastSample.timescaleUnitsToNextSample=d,!this.isFragmented){let u=K(e.timeToSampleTable);if(m(u),u.sampleCount===1){u.sampleDelta=d;const h=e.timeToSampleTable[e.timeToSampleTable.length-2];h&&h.sampleDelta===d&&(h.sampleCount++,e.timeToSampleTable.pop(),u=h)}else u.sampleDelta!==d&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:d}));u.sampleDelta===o?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const f=K(e.compositionTimeOffsetTable);m(f),f.sampleCompositionTimeOffset===a?f.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=Q(i.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=i}if(e.timestampProcessingQueue.length=0,m(e.lastSample),m(e.lastTimescaleUnits!==null),r!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){m(r.type==="key");const s=Q(r.timestamp,e.timescale,!1),i=Math.round(s-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=i}}async registerSample(e,r){r.type==="key"&&this.processTimestamps(e,r),e.timestampProcessingQueue.push(r),this.isFragmented?(e.sampleQueue.push(r),await this.interleaveSamples()):await this.addSampleToTrack(e,r)}async addSampleToTrack(e,r){this.isFragmented||e.samples.push(r);let n=!1;if(!e.currentChunk)n=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,r.timestamp);const s=r.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const i=this.trackDatas.every(a=>{if(e===a)return r.type==="key";const o=a.sampleQueue[0];return o?o.type==="key":a.track.source._closed});s>=this.minimumFragmentDuration&&i&&r.timestamp>this.maxWrittenTimestamp&&(n=!0,await this.finalizeFragment())}else n=s>=.5}n&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:r.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(r),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,r.timestamp))}async finalizeCurrentChunk(e){if(m(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let r=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(r=e.currentChunk.samples.reduce((n,s)=>n+Q(s.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||K(e.compactlyCodedChunkTable).samplesPerChunk!==r)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:r}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const n of e.currentChunk.samples)m(n.data),this.writer.write(n.data),n.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(m(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let r=null,n=1/0;for(const i of this.trackDatas){if(!e&&i.sampleQueue.length===0&&!i.track.source._closed)break e;i.sampleQueue.length>0&&i.sampleQueue[0].timestamp<n&&(r=i,n=i.sampleQueue[0].timestamp)}if(!r)break;const s=r.sampleQueue.shift();await this.addSampleToTrack(r,s)}}async finalizeFragment(e=!0){m(this.isFragmented);const r=this.nextFragmentNumber++;if(r===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const w=Tt(this.trackDatas,this.creationTime,!0);if(this.boxWriter.writeBox(w),this.format._options.onMoov){const{data:c,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoov(c,p)}}const n=this.trackDatas.filter(w=>w.currentChunk),s=Or(r,n),i=this.writer.getPos(),a=i+this.boxWriter.measureBox(s);let o=a+fe,l=1/0;for(const w of n){w.currentChunk.offset=o,w.currentChunk.moofOffset=i;for(const c of w.currentChunk.samples)o+=c.size;l=Math.min(l,w.currentChunk.startTimestamp)}const d=o-a,u=d>=2**32;if(u)for(const w of n)w.currentChunk.offset+=Se-fe;this.format._options.onMoof&&this.writer.startTrackingWrites();const f=Or(r,n);if(this.boxWriter.writeBox(f),this.format._options.onMoof){const{data:w,start:c}=this.writer.stopTrackingWrites();this.format._options.onMoof(w,c,l)}m(this.writer.getPos()===a),this.format._options.onMdat&&this.writer.startTrackingWrites();const h=zt(u);h.size=d,this.boxWriter.writeBox(h),this.writer.seek(a+(u?Se:fe));for(const w of n)for(const c of w.currentChunk.samples)this.writer.write(c.data),c.data=null;if(this.format._options.onMdat){const{data:w,start:c}=this.writer.stopTrackingWrites();this.format._options.onMdat(w,c)}for(const w of n)w.finalizedChunks.push(w.currentChunk),this.finalizedChunks.push(w.currentChunk),w.currentChunk=null;e&&await this.writer.flush()}async onTrackClose(e){const r=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const n=this.trackDatas.find(s=>s.track===e);n&&await this.processWebVTTCues(n,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),r()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const r of this.trackDatas)r.type==="subtitle"&&r.track.source._codec==="webvtt"&&await this.processWebVTTCues(r,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const r of this.trackDatas)this.processTimestamps(r);await this.finalizeFragment(!1)}else for(const r of this.trackDatas)this.processTimestamps(r),await this.finalizeCurrentChunk(r);if(this.fastStart==="in-memory"){m(this.mdat);let r;for(let s=0;s<2;s++){const i=Tt(this.trackDatas,this.creationTime),a=this.boxWriter.measureBox(i);r=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+a+r;for(const l of this.finalizedChunks){l.offset=o;for(const{data:d}of l.samples)m(d),o+=d.byteLength,r+=d.byteLength}if(o<2**32)break;r>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const n=Tt(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(n),this.format._options.onMoov){const{data:s,start:i}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,i)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=r,this.boxWriter.writeBox(this.mdat);for(const s of this.finalizedChunks)for(const i of s.samples)m(i.data),this.writer.write(i.data),i.data=null;if(this.format._options.onMdat){const{data:s,start:i}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,i)}}else if(this.isFragmented){const r=this.writer.getPos(),n=Si(this.trackDatas);this.boxWriter.writeBox(n);const s=this.writer.getPos()-r;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(s)}else{m(this.mdat);const r=this.boxWriter.offsets.get(this.mdat);m(r!==void 0);const n=this.writer.getPos()-r;if(this.mdat.size=n,this.mdat.largeSize=n>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:i,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(i,a)}this.format._options.onMoov&&this.writer.startTrackingWrites();const s=Tt(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(s),this.format._options.onMoov){const{data:i,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(i,a)}}e()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var v;(function(t){t[t.EBML=440786851]="EBML",t[t.EBMLVersion=17030]="EBMLVersion",t[t.EBMLReadVersion=17143]="EBMLReadVersion",t[t.EBMLMaxIDLength=17138]="EBMLMaxIDLength",t[t.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",t[t.DocType=17026]="DocType",t[t.DocTypeVersion=17031]="DocTypeVersion",t[t.DocTypeReadVersion=17029]="DocTypeReadVersion",t[t.Void=236]="Void",t[t.Segment=408125543]="Segment",t[t.SeekHead=290298740]="SeekHead",t[t.Seek=19899]="Seek",t[t.SeekID=21419]="SeekID",t[t.SeekPosition=21420]="SeekPosition",t[t.Duration=17545]="Duration",t[t.Info=357149030]="Info",t[t.TimestampScale=2807729]="TimestampScale",t[t.MuxingApp=19840]="MuxingApp",t[t.WritingApp=22337]="WritingApp",t[t.Tracks=374648427]="Tracks",t[t.TrackEntry=174]="TrackEntry",t[t.TrackNumber=215]="TrackNumber",t[t.TrackUID=29637]="TrackUID",t[t.TrackType=131]="TrackType",t[t.FlagEnabled=185]="FlagEnabled",t[t.FlagDefault=136]="FlagDefault",t[t.FlagForced=21930]="FlagForced",t[t.FlagLacing=156]="FlagLacing",t[t.Name=21358]="Name",t[t.Language=2274716]="Language",t[t.LanguageBCP47=2274717]="LanguageBCP47",t[t.CodecID=134]="CodecID",t[t.CodecPrivate=25506]="CodecPrivate",t[t.CodecDelay=22186]="CodecDelay",t[t.SeekPreRoll=22203]="SeekPreRoll",t[t.DefaultDuration=2352003]="DefaultDuration",t[t.Video=224]="Video",t[t.PixelWidth=176]="PixelWidth",t[t.PixelHeight=186]="PixelHeight",t[t.Audio=225]="Audio",t[t.SamplingFrequency=181]="SamplingFrequency",t[t.Channels=159]="Channels",t[t.BitDepth=25188]="BitDepth",t[t.SimpleBlock=163]="SimpleBlock",t[t.BlockGroup=160]="BlockGroup",t[t.Block=161]="Block",t[t.BlockAdditions=30113]="BlockAdditions",t[t.BlockMore=166]="BlockMore",t[t.BlockAdditional=165]="BlockAdditional",t[t.BlockAddID=238]="BlockAddID",t[t.BlockDuration=155]="BlockDuration",t[t.ReferenceBlock=251]="ReferenceBlock",t[t.Cluster=524531317]="Cluster",t[t.Timestamp=231]="Timestamp",t[t.Cues=475249515]="Cues",t[t.CuePoint=187]="CuePoint",t[t.CueTime=179]="CueTime",t[t.CueTrackPositions=183]="CueTrackPositions",t[t.CueTrack=247]="CueTrack",t[t.CueClusterPosition=241]="CueClusterPosition",t[t.Colour=21936]="Colour",t[t.MatrixCoefficients=21937]="MatrixCoefficients",t[t.TransferCharacteristics=21946]="TransferCharacteristics",t[t.Primaries=21947]="Primaries",t[t.Range=21945]="Range",t[t.Projection=30320]="Projection",t[t.ProjectionType=30321]="ProjectionType",t[t.ProjectionPoseRoll=30325]="ProjectionPoseRoll",t[t.Attachments=423732329]="Attachments",t[t.Chapters=272869232]="Chapters",t[t.Tags=307544935]="Tags"})(v||(v={}));const ji=[v.EBML,v.Segment],ht=[v.SeekHead,v.Info,v.Cluster,v.Tracks,v.Cues,v.Attachments,v.Chapters,v.Tags],Kt=[...ji,...ht],Qt=8,oe=2,ve=2*Qt,xn=t=>{const e=O(t);if(t.skip(-1),e===0)return null;let r=1,n=128;for(;(e&n)===0;)r++,n>>=1;return r},lt=t=>{const e=O(t);if(e===0)return null;let r=1,n=128;for(;(e&n)===0;)r++,n>>=1;let s=e&n-1;for(let i=1;i<r;i++)s*=256,s+=O(t);return s},U=(t,e)=>{if(e<1||e>8)throw new Error("Bad unsigned int size "+e);let r=0;for(let n=0;n<e;n++)r*=256,r+=O(t);return r},Ki=(t,e)=>{let r=U(t,e);return r&1<<e*8-1&&(r-=2**(e*8)),r},ar=t=>{const e=xn(t);return e===null?null:U(t,e)},Cn=t=>{let e=O(t);return e===255?e=null:(t.skip(-1),e=lt(t),e===72057594037927940&&(e=null)),e},xe=t=>{const e=ar(t);if(e===null)return null;const r=Cn(t);return{id:e,size:r}},ut=(t,e)=>{const r=q(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return String.fromCharCode(...r.subarray(0,n))},Qi=(t,e)=>{const r=q(t,e);let n=0;for(;n<e&&r[n]!==0;)n+=1;return Lr.decode(r.subarray(0,n))},Vt=(t,e)=>{if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);return e===4?Hi(t):Sn(t)},Xt=async(t,e,r,n)=>{const s=new Set(r);let i=e;for(;n===null||i<n;){let a=t.requestSliceRange(i,oe,ve);if(a instanceof Promise&&(a=await a),!a)break;const o=xe(a);if(!o)break;if(s.has(o.id))return{pos:i,found:!0};Qe(o.size),i=a.filePos+o.size}return{pos:n!==null&&n>i?n:i,found:!1}},Pn=async(t,e,r,n)=>{const i=new Set(r);let a=e;for(;a<n;){let o=t.requestSliceRange(a,0,Math.min(65536,n-a));if(o instanceof Promise&&(o=await o),!o||o.length<Qt)break;for(let l=0;l<o.length-Qt;l++){o.filePos=a;const d=ar(o);if(d!==null&&i.has(d))return a;a++}}return null},de={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC"};function Qe(t){if(t===null)throw new Error("Undefined element size is used in a place where it is not supported.")}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Xi=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isWebM?"webm":"x-matroska");if(t.codecStrings.length>0){const n=[...new Set(t.codecStrings.filter(Boolean))];r+=`; codecs="${n.join(", ")}"`}return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const vn=4,Gi={1:[-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1],2:[-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1],3:[-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1]},Yi={1:[-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],2:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1],3:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1]},Zi={0:[11025,12e3,8e3,-1],2:[22050,24e3,16e3,-1],3:[44100,48e3,32e3,-1]},Ji=1483304551,ea=1231971951,ta=(t,e,r,n)=>Math.floor(t===3?(12*e/r+n)*4:144*e/r+n),ra=(t,e)=>t===3?e===3?21:36:e===3?13:21,na=(t,e)=>{var S,x,C;const r=t>>>24,n=t>>>16&255,s=t>>>8&255,i=t&255;if(r!==255&&n!==255&&s!==255&&i!==255)return{header:null,bytesAdvanced:4};if(r!==255)return{header:null,bytesAdvanced:1};if((n&224)!==224)return{header:null,bytesAdvanced:1};const a=n>>3&3,o=n>>1&3,l=s>>4&15,d=s>>2&3,u=s>>1&1,f=i>>6&3,h=i>>4&3,w=i>>3&1,c=i>>2&1,p=i&3,b=a===3?(S=Gi[o])==null?void 0:S[l]:(x=Yi[o])==null?void 0:x[l];if(!b||b===-1)return{header:null,bytesAdvanced:1};const k=b*1e3,g=(C=Zi[a])==null?void 0:C[d];if(!g||g===-1)return{header:null,bytesAdvanced:1};const y=ta(o,k,g,u);if(e!==null&&e<y)return{header:null,bytesAdvanced:1};let T;return a===3?T=o===3?384:1152:o===3?T=384:o===2?T=1152:T=576,{header:{totalSize:y,mpegVersionId:a,layer:o,bitrate:k,frequencyIndex:d,sampleRate:g,channel:f,modeExtension:h,copyright:w,original:c,emphasis:p,audioSamplesInFrame:T},bytesAdvanced:1}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const En=1399285583,sa=79764919,In=new Uint32Array(256);for(let t=0;t<256;t++){let e=t<<24;for(let r=0;r<8;r++)e=e&2147483648?e<<1^sa:e<<1;In[t]=e>>>0&4294967295}const ia=t=>{const e=ae(t),r=e.getUint32(22,!0);e.setUint32(22,0,!0);let n=0;for(let s=0;s<t.length;s++){const i=t[s];n=(n<<8^In[n>>>24^i])>>>0}return e.setUint32(22,r,!0),n},aa=(t,e,r)=>{let n=0,s=null;if(t.length>0)if(e.codec==="vorbis"){m(e.vorbisInfo);const i=e.vorbisInfo.modeBlockflags.length,o=(1<<Gn(i-1))-1<<1,l=(t[0]&o)>>1;if(l>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let d=r;const u=e.vorbisInfo.modeBlockflags[l];if(s=e.vorbisInfo.blocksizes[u],u===1){const f=(o|1)+1,h=t[0]&f?1:0;d=e.vorbisInfo.blocksizes[h]}n=d!==null?d+s>>2:0}else e.codec==="opus"&&(n=Is(t).durationInSamples);return{durationInSamples:n,vorbisBlockSize:s}},oa=t=>{let e="audio/ogg";if(t.codecStrings){const r=[...new Set(t.codecStrings)];e+=`; codecs="${r.join(", ")}"`}return e};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Me=27,Je=282,ca=Je+255*255,ft=t=>{const e=t.filePos;if(Ye(t)!==En)return null;t.skip(1);const n=O(t),s=Wi(t),i=Ye(t),a=Ye(t),o=Ye(t),l=O(t),d=new Uint8Array(l);for(let w=0;w<l;w++)d[w]=O(t);const u=27+l,f=d.reduce((w,c)=>w+c,0),h=u+f;return{headerStartPos:e,totalSize:h,dataStartPos:e+u,dataSize:f,headerType:n,granulePosition:s,serialNumber:i,sequenceNumber:a,checksum:o,lacingValues:d}},la=(t,e)=>{for(;t.filePos<e-3;){const r=Ye(t),n=r&255,s=r>>>8&255,i=r>>>16&255,a=r>>>24&255,o=79;if(!(n!==o&&s!==o&&i!==o&&a!==o)){if(t.skip(-4),r===En)return!0;t.skip(1)}}return!1};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class nt{constructor(e){this.input=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ua=[],da=[],fa=[],Gt=[];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const pe=new Uint8Array(0);class ${constructor(e,r,n,s,i=-1,a){if(this.data=e,this.type=r,this.timestamp=n,this.duration=s,this.sequenceNumber=i,e===pe&&a===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(a===void 0&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!=="key"&&r!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(n))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(s)||s<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(i))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");this.byteLength=a}get isMetadataOnly(){return this.data===pe}get microsecondTimestamp(){return Math.trunc(Ce*this.timestamp)}get microsecondDuration(){return Math.trunc(Ce*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const r=new Uint8Array(e.byteLength);return e.copyTo(r),new $(r,e.type,e.timestamp/1e6,(e.duration??0)/1e6)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if((e==null?void 0:e.timestamp)!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if((e==null?void 0:e.duration)!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new $(this.data,this.type,(e==null?void 0:e.timestamp)??this.timestamp,(e==null?void 0:e.duration)??this.duration,this.sequenceNumber,this.byteLength)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const ma=t=>{let n=t,s=4096,i=0,a=12,o=0;for(n<0&&(n=-n,i=128),n+=33,n>8191&&(n=8191);(n&s)!==s&&a>=5;)s>>=1,a--;return o=n>>a-4&15,~(i|a-5<<4|o)&255},ha=t=>{let r=2048,n=0,s=11,i=0,a=t;for(a<0&&(a=-a,n=128),a>4095&&(a=4095);(a&r)!==r&&s>=5;)r>>=1,s--;return i=a>>(s===4?1:s-4)&15,(n|s-4<<4|i)^85};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Re{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(Ce*this.timestamp)}get microsecondDuration(){return Math.trunc(Ce*this.duration)}constructor(e,r){if(this._closed=!1,e instanceof ArrayBuffer||ArrayBuffer.isView(e)){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(!("format"in r)||typeof r.format!="string")throw new TypeError("init.format must be a string.");if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=me(e).slice(),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace(r.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if((r==null?void 0:r.rotation)!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if((r==null?void 0:r.timestamp)!==void 0&&!Number.isFinite(r==null?void 0:r.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if((r==null?void 0:r.duration)!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=(r==null?void 0:r.rotation)??0,this.timestamp=(r==null?void 0:r.timestamp)??e.timestamp/1e6,this.duration=(r==null?void 0:r.duration)??(e.duration??0)/1e6,this.colorSpace=e.colorSpace}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new Re(new VideoFrame(e,{timestamp:Math.trunc(r.timestamp*Ce),duration:Math.trunc((r.duration??0)*Ce)}),r);let n=0,s=0;if("naturalWidth"in e?(n=e.naturalWidth,s=e.naturalHeight):"videoWidth"in e?(n=e.videoWidth,s=e.videoHeight):"width"in e&&(n=Number(e.width),s=Number(e.height)),!n||!s)throw new TypeError("Could not determine dimensions.");const i=new OffscreenCanvas(n,s),a=i.getContext("2d",{alpha:!1,willReadFrequently:!0});m(a),a.drawImage(e,0,0),this._data=i,this.format="RGBX",this.codedWidth=n,this.codedHeight=s,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.")}clone(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),at(this._data)?new Re(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new Re(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new Re(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(at(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),at(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e){if(!It(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),at(this._data))await this._data.copyTo(e);else if(this._data instanceof Uint8Array)me(e).set(this._data);else{const n=this._data.getContext("2d",{alpha:!1});m(n);const s=n.getImageData(0,0,this.codedWidth,this.codedHeight);me(e).set(s.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),at(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}draw(e,r,n,s,i,a,o,l,d){let u=0,f=0,h=this.displayWidth,w=this.displayHeight,c=0,p=0,b=this.displayWidth,k=this.displayHeight;if(a!==void 0?(u=r,f=n,h=s,w=i,c=a,p=o,l!==void 0?(b=l,k=d):(b=h,k=w)):(c=r,p=n,s!==void 0&&(b=s,k=i)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(f))throw new TypeError("sy must be a number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(w)||w<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(c))throw new TypeError("dx must be a number.");if(!Number.isFinite(p))throw new TypeError("dy must be a number.");if(!Number.isFinite(b)||b<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(k)||k<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");this.rotation===90?[u,f,h,w]=[f,this.codedHeight-u-h,w,h]:this.rotation===180?[u,f]=[this.codedWidth-u-h,this.codedHeight-f-w]:this.rotation===270&&([u,f,h,w]=[this.codedWidth-f-w,u,w,h]);const g=this.toCanvasImageSource();e.save();const y=c+b/2,T=p+k/2;e.translate(y,T),e.rotate(this.rotation*Math.PI/180);const S=this.rotation%180===0?1:b/k;e.scale(1/S,S),e.drawImage(g,u,f,h,w,-b/2,-k/2,b,k),e.restore()}drawWithFit(e,r){const n=e.canvas.width,s=e.canvas.height,i=r.rotation??this.rotation;let a,o,l,d;if(r.fit==="fill")a=0,o=0,l=n,d=s;else{const[f,h]=i%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth],w=r.fit==="contain"?Math.min(n/f,s/h):Math.max(n/f,s/h);l=f*w,d=h*w,a=(n-l)/2,o=(s-d)/2}const u=i%180===0?1:l/d;e.translate(n/2,s/2),e.rotate(i*Math.PI/180),e.scale(1/u,u),e.translate(-n/2,-s/2),e.drawImage(this.toCanvasImageSource(),a,o,l,d)}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}}const at=t=>typeof VideoFrame<"u"&&t instanceof VideoFrame,Ut=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class De{get microsecondTimestamp(){return Math.trunc(Ce*this.timestamp)}get microsecondDuration(){return Math.trunc(Ce*this.duration)}constructor(e){if(this._closed=!1,ct(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!Ut.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e==null?void 0:e.timestamp))throw new TypeError("init.timestamp must be a number.");const r=e.data.byteLength/(ot(e.format)*e.numberOfChannels);if(!Number.isInteger(r))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=r,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=r/e.sampleRate;let n;if(e.data instanceof ArrayBuffer)n=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))n=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const s=this.numberOfFrames*this.numberOfChannels*ot(this.format);if(n.byteLength<s)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=n}}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!Ut.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const r=e.format??this.format,n=e.frameOffset??0;if(n>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const s=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-n;if(s>this.numberOfFrames-n)throw new RangeError("frameCount out of range");const i=ot(r),a=yt(r);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(a?s:s*this.numberOfChannels)*i}copyTo(e,r){if(!It(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(r.planeIndex)||r.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(r.format!==void 0&&!Ut.has(r.format))throw new TypeError("Invalid format.");if(r.frameOffset!==void 0&&(!Number.isInteger(r.frameOffset)||r.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(r.frameCount!==void 0&&(!Number.isInteger(r.frameCount)||r.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:n,format:s,frameCount:i,frameOffset:a}=r,o=s??this.format;if(!o)throw new Error("Destination format not determined");const l=this.numberOfFrames,d=this.numberOfChannels,u=a??0;if(u>=l)throw new RangeError("frameOffset out of range");const f=i!==void 0?i:l-u;if(f>l-u)throw new RangeError("frameCount out of range");const h=ot(o),w=yt(o);if(w&&n>=d)throw new RangeError("planeIndex out of range");if(!w&&n!==0)throw new RangeError("planeIndex out of range");const p=(w?f:f*d)*h;if(e.byteLength<p)throw new RangeError("Destination buffer is too small");const b=ae(e),k=ga(o);if(ct(this._data))if(w)if(o==="f32-planar")this._data.copyTo(e,{planeIndex:n,frameOffset:u,frameCount:f,format:"f32-planar"});else{const g=new ArrayBuffer(f*4),y=new Float32Array(g);this._data.copyTo(y,{planeIndex:n,frameOffset:u,frameCount:f,format:"f32-planar"});const T=new DataView(g);for(let S=0;S<f;S++){const x=S*h,C=T.getFloat32(S*4,!0);k(b,x,C)}}else{const g=d,y=new Float32Array(f);for(let T=0;T<g;T++){this._data.copyTo(y,{planeIndex:T,frameOffset:u,frameCount:f,format:"f32-planar"});for(let S=0;S<f;S++){const C=(S*g+T)*h;k(b,C,y[S])}}}else{const g=this._data,y=new DataView(g.buffer,g.byteOffset,g.byteLength),T=this.format,S=pa(T),x=ot(T),C=yt(T);for(let _=0;_<f;_++)if(w){const E=_*h;let P;C?P=(n*l+(_+u))*x:P=((_+u)*d+n)*x;const A=S(y,P);k(b,E,A)}else for(let E=0;E<d;E++){const A=(_*d+E)*h;let M;C?M=(E*l+(_+u))*x:M=((_+u)*d+E)*x;const X=S(y,M);k(b,A,X)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(ct(this._data)){const e=new De(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new De({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(ct(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(ct(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(yt(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),r=new ArrayBuffer(e*this.numberOfChannels);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(new Uint8Array(r,n*e,e),{planeIndex:n,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:r})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),r=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let n=0;n<this.numberOfChannels;n++)this.copyTo(r,{planeIndex:n,format:"f32-planar"}),e.copyToChannel(r,n);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}static*_fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,s=e.numberOfChannels,i=e.sampleRate,a=e.length,o=Math.floor(n/s);let l=0,d=a;for(;d>0;){const u=Math.min(o,d),f=new Float32Array(s*u);for(let h=0;h<s;h++)e.copyFromChannel(f.subarray(h*u,(h+1)*u),h,l);yield new De({format:"f32-planar",sampleRate:i,numberOfFrames:u,numberOfChannels:s,timestamp:r+l/i,data:f}),l+=u,d-=u}}static fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const n=48e3*5,s=e.numberOfChannels,i=e.sampleRate,a=e.length,o=Math.floor(n/s);let l=0,d=a;const u=[];for(;d>0;){const f=Math.min(o,d),h=new Float32Array(s*f);for(let c=0;c<s;c++)e.copyFromChannel(h.subarray(c*f,(c+1)*f),c,l);const w=new De({format:"f32-planar",sampleRate:i,numberOfFrames:f,numberOfChannels:s,timestamp:r+l/i,data:h});u.push(w),l+=f,d-=f}return u}}const ot=t=>{switch(t){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},yt=t=>{switch(t){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},pa=t=>{switch(t){case"u8":case"u8-planar":return(e,r)=>(e.getUint8(r)-128)/128;case"s16":case"s16-planar":return(e,r)=>e.getInt16(r,!0)/32768;case"s32":case"s32-planar":return(e,r)=>e.getInt32(r,!0)/2147483648;case"f32":case"f32-planar":return(e,r)=>e.getFloat32(r,!0)}},ga=t=>{switch(t){case"u8":case"u8-planar":return(e,r,n)=>e.setUint8(r,Y((n+1)*127.5,0,255));case"s16":case"s16-planar":return(e,r,n)=>e.setInt16(r,Y(Math.round(n*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,r,n)=>e.setInt32(r,Y(Math.round(n*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,r,n)=>e.setFloat32(r,n,!0)}},ct=t=>typeof AudioData<"u"&&t instanceof AudioData;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const je=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.metadataOnly!==void 0&&typeof t.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(t.verifyKeyPackets!==void 0&&typeof t.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(t.verifyKeyPackets&&t.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},Rr=t=>{if(typeof t!="number"||Number.isNaN(t))throw new TypeError("timestamp must be a number.")},Wt=(t,e,r)=>r.verifyKeyPackets?e.then(async n=>{if(!n||n.type==="delta")return n;const s=await t.determinePacketType(n);return s&&(n.type=s),n}):e;class ka{constructor(e){if(!(e instanceof or))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){return je(e),Wt(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,r={}){return Rr(e),je(r),Wt(this._track,this._track._backing.getPacket(e,r),r)}getNextPacket(e,r={}){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");return je(r),Wt(this._track,this._track._backing.getNextPacket(e,r),r)}async getKeyPacket(e,r={}){if(Rr(e),je(r),!r.verifyKeyPackets)return this._track._backing.getKeyPacket(e,r);const n=await this._track._backing.getKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getKeyPacket(n.timestamp-1/this._track.timeResolution,r):n}async getNextKeyPacket(e,r={}){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(je(r),!r.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,r);const n=await this._track._backing.getNextKeyPacket(e,r);return!n||n.type==="delta"?n:await this._track.determinePacketType(n)==="delta"?this.getNextKeyPacket(n,r):n}packets(e,r,n={}){if(e!==void 0&&!(e instanceof $))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!(n!=null&&n.metadataOnly))throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(r!==void 0&&!(r instanceof $))throw new TypeError("endPacket must be an EncodedPacket.");je(n);const s=[];let{promise:i,resolve:a}=Ge(),{promise:o,resolve:l}=Ge(),d=!1,u=!1,f=null;const h=[],w=()=>Math.max(2,h.length);return(async()=>{let c=e??await this.getFirstPacket(n);for(;c&&!u&&!(r&&c.sequenceNumber>=(r==null?void 0:r.sequenceNumber));){if(s.length>w()){({promise:o,resolve:l}=Ge()),await o;continue}s.push(c),a(),{promise:i,resolve:a}=Ge(),c=await this.getNextPacket(c,n)}d=!0,a()})().catch(c=>{f||(f=c,a())}),{async next(){for(;;){if(u)return{value:void 0,done:!0};if(f)throw f;if(s.length>0){const c=s.shift(),p=performance.now();for(h.push(p);h.length>0&&p-h[0]>=1e3;)h.shift();return l(),{value:c,done:!1}}else{if(d)return{value:void 0,done:!0};await i}}},async return(){return u=!0,l(),a(),{value:void 0,done:!0}},async throw(c){throw c},[Symbol.asyncIterator](){return this}}}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class or{constructor(e){this._backing=e}isVideoTrack(){return this instanceof cr}isAudioTrack(){return this instanceof Le}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const r=new ka(this);let n=1/0,s=-1/0,i=0,a=0;for await(const o of r.packets(void 0,void 0,{metadataOnly:!0})){if(i>=e&&o.timestamp>=s)break;n=Math.min(n,o.timestamp),s=Math.max(s,o.timestamp+o.duration),i++,a+=o.byteLength}return{packetCount:i,averagePacketRate:i?Number((i/(s-n)).toPrecision(16)):0,averageBitrate:i?Number((8*a/(s-n)).toPrecision(16)):0}}}class cr extends or{constructor(e){super(e),this._backing=e}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),ua.some(s=>s.supports(r,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");return this.codec===null?null:Fs(this,e)}}class Le extends or{constructor(e){super(e),this._backing=e}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return(e==null?void 0:e.codec)??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),da.some(n=>n.supports(r,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var ke;(function(t){t[t.PCM=1]="PCM",t[t.IEEE_FLOAT=3]="IEEE_FLOAT",t[t.ALAW=6]="ALAW",t[t.MULAW=7]="MULAW",t[t.EXTENSIBLE=65534]="EXTENSIBLE"})(ke||(ke={}));class wa extends nt{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.lastKnownPacketIndex=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=this.reader.requestSlice(0,12);e instanceof Promise&&(e=await e),m(e);const r=re(e,4),n=r!=="RIFX",s=r==="RF64",i=ze(e,n);let a=s?this.reader.fileSize:Math.min(i+8,this.reader.fileSize??1/0);if(re(e,4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");let l=0,d=null,u=e.filePos;for(;a===null||u<a;){let h=this.reader.requestSlice(u,8);if(h instanceof Promise&&(h=await h),!h)break;const w=re(h,4),c=ze(h,n),p=h.filePos;if(s&&l===0&&w!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(w==="fmt ")await this.parseFmtChunk(p,c,n);else if(w==="data")d??(d=c),this.dataStart=h.filePos,this.dataSize=Math.min(d,(a??1/0)-this.dataStart);else if(w==="ds64"){const b=Mr(h,n);d=Mr(h,n),a=Math.min(b+8,this.reader.fileSize??1/0)}u=p+c+(c&1),l++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const f=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/f)*f,this.tracks.push(new Le(new ba(this)))})())}async parseFmtChunk(e,r,n){let s=this.reader.requestSlice(e,r);if(s instanceof Promise&&(s=await s),!s)return;let i=st(s,n);const a=st(s,n),o=ze(s,n);s.skip(4);const l=st(s,n);let d;if(r===14?d=8:d=st(s,n),r>=18&&i!==357){const u=st(s,n),f=r-18;if(Math.min(f,u)>=22&&i===ke.EXTENSIBLE){s.skip(6);const w=q(s,16);i=w[0]|w[1]<<8}}(i===ke.MULAW||i===ke.ALAW)&&(d=8),this.audioInfo={format:i,numberOfChannels:a,sampleRate:o,sampleSizeInBytes:Math.ceil(d/8),blockSizeInBytes:l}}getCodec(){if(m(this.audioInfo),this.audioInfo.format===ke.MULAW)return"ulaw";if(this.audioInfo.format===ke.ALAW)return"alaw";if(this.audioInfo.format===ke.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===ke.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getTracks(){return await this.readMetadata(),this.tracks}}const Ke=2048;class ba{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(m(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return ce}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,r){m(this.demuxer.audioInfo);const n=e*Ke*this.demuxer.audioInfo.blockSizeInBytes;if(n>=this.demuxer.dataSize)return null;const s=Math.min(Ke*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-n);if(this.demuxer.reader.fileSize===null){let l=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,s);if(l instanceof Promise&&(l=await l),!l)return null}let i;if(r.metadataOnly)i=pe;else{let l=this.demuxer.reader.requestSlice(this.demuxer.dataStart+n,s);l instanceof Promise&&(l=await l),m(l),i=q(l,s)}const a=e*Ke/this.demuxer.audioInfo.sampleRate,o=s/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return this.demuxer.lastKnownPacketIndex=Math.max(e,a),new $(i,"key",a,o,e,s)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getPacket(e,r){m(this.demuxer.audioInfo);const n=Math.floor(Math.min(e*this.demuxer.audioInfo.sampleRate/Ke,(this.demuxer.dataSize-1)/(Ke*this.demuxer.audioInfo.blockSizeInBytes))),s=await this.getPacketAtIndex(n,r);if(s)return s;if(n===0)return null;m(this.demuxer.reader.fileSize===null);let i=await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex,r);for(;i;){const a=await this.getNextPacket(i,r);if(!a)break;i=a}return i}getNextPacket(e,r){m(this.demuxer.audioInfo);const n=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/Ke);return this.getPacketAtIndex(n+1,r)}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class _n{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>Ne.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>Ve.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>Ct.includes(e))}_codecUnsupportedHint(e){return""}}class Fn extends _n{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new $i(e,this)}}class Bn extends Fn{get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...Ne,...Yr,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...Ct]}_codecUnsupportedHint(e){return new An().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class An extends Fn{get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...Ne,...Ve]}_codecUnsupportedHint(e){return new Bn().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ta=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ne.includes(t.codec))throw new TypeError(`Invalid video codec '${t.codec}'. Must be one of: ${Ne.join(", ")}.`);if(!(t.bitrate instanceof rt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(t.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(t.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(t.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");ya(t.codec,t)},ya=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&nn(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},Sa=t=>{const e=t.bitrate instanceof rt?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??Jn(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...ns(t.codec)}},xa=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ve.includes(t.codec))throw new TypeError(`Invalid audio codec '${t.codec}'. Must be one of: ${Ve.join(", ")}.`);if(t.bitrate===void 0&&(!ne.includes(t.codec)||t.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(t.bitrate!==void 0&&!(t.bitrate instanceof rt)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");zn(t.codec,t)},zn=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&nn(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`)},Yt=t=>{const e=t.bitrate instanceof rt?t.bitrate._toAudioBitrate(t.codec):t.bitrate;return{codec:t.fullCodecString??ts(t.codec,t.numberOfChannels,t.sampleRate),numberOfChannels:t.numberOfChannels,sampleRate:t.sampleRate,bitrate:e,bitrateMode:t.bitrateMode,...ss(t.codec)}},Ca=async(t,{numberOfChannels:e=2,sampleRate:r=48e3,bitrate:n=128e3,...s}={})=>{if(!Ve.includes(t))return!1;if(!Number.isInteger(e)||e<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(r)||r<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(n instanceof rt)&&(!Number.isInteger(n)||n<=0))throw new TypeError("bitrate must be a positive integer.");zn(t,s);let i=null;return Gt.length>0&&(i??(i=Yt({codec:t,numberOfChannels:e,sampleRate:r,bitrate:n,...s})),Gt.some(o=>o.supports(t,i)))||ne.includes(t)?!0:typeof AudioEncoder>"u"?!1:(i??(i=Yt({codec:t,numberOfChannels:e,sampleRate:r,bitrate:n,...s})),(await AudioEncoder.isConfigSupported(i)).supported===!0)},Pa=async(t,e)=>{for(const r of t)if(await Ca(r,e))return r;return null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class lr{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class On extends lr{constructor(e){if(super(),this._connectedTrack=null,!Ne.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${Ne.join(", ")}.`);this._codec=e}}class va{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new Gr,this.customEncoderQueueSize=0,this.encoderError=null}async add(e,r,n){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const o=this.encodingConfig.sizeChangeBehavior??"deny";if(o!=="passThrough"){if(o==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let l=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),l=!0);const d=this.resizeCanvas.getContext("2d",{alpha:!1});m(d),l||d.clearRect(0,0,this.codedWidth,this.codedHeight),e.drawWithFit(d,{fit:o}),r&&e.close(),e=new Re(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),r=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);const s=this.encodingConfig.keyFrameInterval??5,i=Math.floor(e.timestamp/s),a={...n,keyFrame:(n==null?void 0:n.keyFrame)||s===0||i!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=i,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),l=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,a)).then(()=>this.customEncoderQueueSize--).catch(d=>this.encoderError??(this.encoderError=d)).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await l}else{m(this.encoder);const o=e.toVideoFrame();this.encoder.encode(o,a),o.close(),r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(l=>this.encoder.addEventListener("dequeue",l,{once:!0}))}await this.muxer.mutex.currentPromise}finally{r&&e.close()}}async ensureEncoder(e){if(!this.encoder)return this.ensureEncoderPromise=(async()=>{var s,i,a;const r=Sa({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:(s=this.source._connectedTrack)==null?void 0:s.metadata.frameRate});(a=(i=this.encodingConfig).onEncoderConfig)==null||a.call(i,r);const n=fa.find(o=>o.supports(this.encodingConfig.codec,r));if(n)this.customEncoder=new n,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=r,this.customEncoder.onPacket=(o,l)=>{var d,u;if(!(o instanceof $))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(l!==void 0&&(!l||typeof l!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(u=(d=this.encodingConfig).onEncodedPacket)==null||u.call(d,o,l),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,o,l)},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(!(await VideoEncoder.isConfigSupported(r)).supported)throw new Error(`This specific encoder configuration (${r.codec}, ${r.bitrate} bps, ${r.width}x${r.height}, hardware acceleration: ${r.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);this.encoder=new VideoEncoder({output:(l,d)=>{var f,h;const u=$.fromEncodedChunk(l);(h=(f=this.encodingConfig).onEncodedPacket)==null||h.call(f,u,d),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,u,d)},error:l=>{l.stack=new Error().stack,this.encoderError??(this.encoderError=l)}}),this.encoder.configure(r)}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class Ea extends On{constructor(e,r){if(!(typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement)&&!(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas))throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");Ta(r),super(r.codec),this._encoder=new va(this,r),this._canvas=e}add(e,r=0,n){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(r)||r<0)throw new TypeError("duration must be a non-negative number.");const s=new Re(this._canvas,{timestamp:e,duration:r});return this._encoder.add(s,!0,n)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Mn extends lr{constructor(e){if(super(),this._connectedTrack=null,!Ve.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Ve.join(", ")}.`);this._codec=e}}class Ia{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new Gr,this.customEncoderQueueSize=0,this.encoderError=null}async add(e,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const n=e.clone(),s=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(n)).then(()=>this.customEncoderQueueSize--).catch(i=>this.encoderError??(this.encoderError=i)).finally(()=>{n.close()});this.customEncoderQueueSize>=4&&await s,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,r);else{m(this.encoder);const n=e.toAudioData();this.encoder.encode(n),n.close(),r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(s=>this.encoder.addEventListener("dequeue",s,{once:!0})),await this.muxer.mutex.currentPromise}}finally{r&&e.close()}}async doPcmEncoding(e,r){var h,w;m(this.outputSampleSize),m(this.writeOutputValue);const{numberOfChannels:n,numberOfFrames:s,sampleRate:i,timestamp:a}=e,o=2048,l=[];for(let c=0;c<s;c+=o){const p=Math.min(o,e.numberOfFrames-c),b=p*n*this.outputSampleSize,k=new ArrayBuffer(b),g=new DataView(k);l.push({frameCount:p,view:g})}const d=e.allocationSize({planeIndex:0,format:"f32-planar"}),u=new Float32Array(d/Float32Array.BYTES_PER_ELEMENT);for(let c=0;c<n;c++){e.copyTo(u,{planeIndex:c,format:"f32-planar"});for(let p=0;p<l.length;p++){const{frameCount:b,view:k}=l[p];for(let g=0;g<b;g++)this.writeOutputValue(k,(g*n+c)*this.outputSampleSize,u[p*o+g])}}r&&e.close();const f={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:n,sampleRate:i}};for(let c=0;c<l.length;c++){const{frameCount:p,view:b}=l[c],k=b.buffer,g=c*o,y=new $(new Uint8Array(k),"key",a+g/i,p/i);(w=(h=this.encodingConfig).onEncodedPacket)==null||w.call(h,y,f),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,y,f)}}ensureEncoder(e){if(!this.encoderInitialized)return this.ensureEncoderPromise=(async()=>{var a,o;const{numberOfChannels:r,sampleRate:n}=e,s=Yt({numberOfChannels:r,sampleRate:n,...this.encodingConfig});(o=(a=this.encodingConfig).onEncoderConfig)==null||o.call(a,s);const i=Gt.find(l=>l.supports(this.encodingConfig.codec,s));if(i)this.customEncoder=new i,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=s,this.customEncoder.onPacket=(l,d)=>{var u,f;if(!(l instanceof $))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(d!==void 0&&(!d||typeof d!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");(f=(u=this.encodingConfig).onEncodedPacket)==null||f.call(u,l,d),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,l,d)},await this.customEncoder.init();else if(ne.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(s)).supported)throw new Error(`This specific encoder configuration (${s.codec}, ${s.bitrate} bps, ${s.numberOfChannels} channels, ${s.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(d,u)=>{var h,w;const f=$.fromEncodedChunk(d);(w=(h=this.encodingConfig).onEncodedPacket)==null||w.call(h,f,u),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,f,u)},error:d=>{d.stack=new Error().stack,this.encoderError??(this.encoderError=d)}}),this.encoder.configure(s)}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:r,sampleSize:n,littleEndian:s}=He(e);switch(this.outputSampleSize=n,n){case 1:r==="unsigned"?this.writeOutputValue=(i,a,o)=>i.setUint8(a,Y((o+1)*127.5,0,255)):r==="signed"?this.writeOutputValue=(i,a,o)=>{i.setInt8(a,Y(Math.round(o*128),-128,127))}:r==="ulaw"?this.writeOutputValue=(i,a,o)=>{const l=Y(Math.floor(o*32767),-32768,32767);i.setUint8(a,ma(l))}:r==="alaw"?this.writeOutputValue=(i,a,o)=>{const l=Y(Math.floor(o*32767),-32768,32767);i.setUint8(a,ha(l))}:m(!1);break;case 2:r==="unsigned"?this.writeOutputValue=(i,a,o)=>i.setUint16(a,Y((o+1)*32767.5,0,65535),s):r==="signed"?this.writeOutputValue=(i,a,o)=>i.setInt16(a,Y(Math.round(o*32767),-32768,32767),s):m(!1);break;case 3:r==="unsigned"?this.writeOutputValue=(i,a,o)=>Xr(i,a,Y((o+1)*83886075e-1,0,16777215),s):r==="signed"?this.writeOutputValue=(i,a,o)=>Qn(i,a,Y(Math.round(o*8388607),-8388608,8388607),s):m(!1);break;case 4:r==="unsigned"?this.writeOutputValue=(i,a,o)=>i.setUint32(a,Y((o+1)*21474836475e-1,0,4294967295),s):r==="signed"?this.writeOutputValue=(i,a,o)=>i.setInt32(a,Y(Math.round(o*2147483647),-2147483648,2147483647),s):r==="float"?this.writeOutputValue=(i,a,o)=>i.setFloat32(a,o,s):m(!1);break;case 8:r==="float"?this.writeOutputValue=(i,a,o)=>i.setFloat64(a,o,s):m(!1);break;default:rr(n),m(!1)}}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){var e;return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:((e=this.encoder)==null?void 0:e.encodeQueueSize)??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class _a extends Mn{constructor(e){xa(e),super(e.codec),this._encoder=new Ia(this,e)}add(e){if(!(e instanceof De))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Fa extends lr{constructor(e){if(super(),this._connectedTrack=null,!Ct.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${Ct.join(", ")}.`);this._codec=e}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ba=["video","audio","subtitle"],Ht=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!nr(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.")};class Aa{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new We,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof _n))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof ir))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,r={}){if(!(e instanceof On))throw new TypeError("source must be a VideoSource.");if(Ht(r),r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError(`Invalid video rotation: ${r.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&r.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(r.frameRate!==void 0&&(!Number.isFinite(r.frameRate)||r.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${r.frameRate}. Must be a positive number.`);this._addTrack("video",e,r)}addAudioTrack(e,r={}){if(!(e instanceof Mn))throw new TypeError("source must be an AudioSource.");Ht(r),this._addTrack("audio",e,r)}addSubtitleTrack(e,r={}){if(!(e instanceof Fa))throw new TypeError("source must be a SubtitleSource.");Ht(r),this._addTrack("subtitle",e,r)}_addTrack(e,r,n){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(r._connectedTrack)throw new Error("Source is already used for a track.");const s=this.format.getSupportedTrackCounts(),i=this._tracks.reduce((d,u)=>d+(u.type===e?1:0),0),a=s[e].max;if(i===a)throw new Error(a===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track${a===1?"":"s"}.`);const o=s.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const l={id:this._tracks.length+1,output:this,type:e,source:r,metadata:n};if(l.type==="video"){const d=this.format.getSupportedVideoCodecs();if(d.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!d.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${d.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="audio"){const d=this.format.getSupportedAudioCodecs();if(d.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!d.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${d.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="subtitle"){const d=this.format.getSupportedSubtitleCodecs();if(d.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!d.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${d.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}this._tracks.push(l),r._connectedTrack=l}async start(){const e=this.format.getSupportedTrackCounts();for(const n of Ba){const s=this._tracks.reduce((a,o)=>a+(o.type===n?1:0),0),i=e[n].min;if(s<i)throw new Error(i===e[n].max?`${this.format._name} requires exactly ${i} ${n} track${i===1?"":"s"}.`:`${this.format._name} requires at least ${i} ${n} track${i===1?"":"s"}.`)}const r=e.total.min;if(this._tracks.length<r)throw new Error(r===e.total.max?`${this.format._name} requires exactly ${r} track${r===1?"":"s"}.`:`${this.format._name} requires at least ${r} track${r===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const n=await this._mutex.acquire();await this._muxer.start();const s=this._tracks.map(i=>i.source._start());await Promise.all(s),n()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!0));await Promise.all(r),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),r=this._tracks.map(n=>n.source._flushOrWaitForOngoingClose(!1));await Promise.all(r),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Rn{constructor(){this._sizePromise=null,this.onread=null}async getSizeOrNull(){return this._sizePromise??(this._sizePromise=Promise.resolve(this._retrieveSize()))}async getSize(){const e=await this.getSizeOrNull();if(e===null)throw new Error("Cannot determine the size of an unsized source.");return e}}class za extends Rn{constructor(e,r={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.maxCacheSize!==void 0&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new Ma({maxCacheSize:r.maxCacheSize??8*2**20,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:Oa.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){var n;let r=this._readers.get(e);for(r||(r=this._blob.slice(e.currentPos).stream().getReader(),this._readers.set(e,r));e.currentPos<e.targetPos&&!e.aborted;){const{done:s,value:i}=await r.read();if(s){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Blob reader stopped unexpectedly before all requested data was read.");break}(n=this.onread)==null||n.call(this,e.currentPos,e.currentPos+i.length),this._orchestrator.supplyWorkerData(e,i)}e.running=!1}}const Oa={fileSystem:(t,e)=>(t=Math.floor((t-65536)/65536)*65536,e=Math.ceil((e+65536)/65536)*65536,{start:t,end:e})};class Ma{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0}read(e,r){m(this.fileSize!==null);const n=this.options.prefetchProfile(e,r,this.workers),s=Math.max(n.start,0),i=Math.min(n.end,this.fileSize);m(s<=e&&r<=i);let a=null;const o=W(this.cache,e,g=>g.start),l=o!==-1?this.cache[o]:null;l&&l.start<=e&&r<=l.end&&(l.age=this.nextAge++,a={bytes:l.bytes,view:l.view,offset:l.start});const d=W(this.cache,s,g=>g.start),u=a?null:new Uint8Array(r-e);let f=0,h=s;const w=[];if(d!==-1){for(let g=d;g<this.cache.length;g++){const y=this.cache[g];if(y.start>=i)break;if(y.end<=s)continue;const T=Math.max(s,y.start),S=Math.min(i,y.end);if(m(T<=S),h<T&&w.push({start:h,end:T}),h=S,u){const x=Math.max(e,y.start),C=Math.min(r,y.end);if(x<C){const _=x-e;u.set(y.bytes.subarray(x-y.start,C-y.start),_),_===f&&(f=C-e)}}y.age=this.nextAge++}h<i&&w.push({start:h,end:i})}else w.push({start:s,end:i});if(u&&f>=u.length&&(a={bytes:u,view:ae(u),offset:e}),w.length===0)return m(a),a;const{promise:c,resolve:p,reject:b}=Ge(),k=[];for(const g of w){const y=Math.max(e,g.start),T=Math.min(r,g.end);y===g.start&&T===g.end?k.push(g):y<T&&k.push({start:y,end:T})}for(const g of w){const y=u&&{start:e,bytes:u,holes:k,resolve:p,reject:b};let T=!1;for(const S of this.workers)if(br(g.start-131072,g.start,S.currentPos,S.targetPos)){S.targetPos=Math.max(S.targetPos,g.end),T=!0,y&&!S.pendingSlices.includes(y)&&S.pendingSlices.push(y),S.running||this.runWorker(S);break}if(!T){const S=this.createWorker(g.start,g.end);y&&(S.pendingSlices=[y]),this.runWorker(S)}}return a||(m(u),a=c.then(g=>({bytes:g,view:ae(g),offset:e}))),a}createWorker(e,r){const n={startPos:e,currentPos:e,targetPos:r,running:!1,aborted:!1,pendingSlices:[],age:this.nextAge++};for(this.workers.push(n);this.workers.length>this.options.maxWorkerCount;){let s=0,i=this.workers[0];for(let a=1;a<this.workers.length;a++){const o=this.workers[a];o.age<i.age&&(s=a,i=o)}if(i.running&&i.pendingSlices.length>0)break;i.aborted=!0,this.workers.splice(s,1)}return n}runWorker(e){m(!e.running),m(e.currentPos<e.targetPos),e.running=!0,e.age=this.nextAge++,this.options.runWorker(e).catch(r=>{if(e.running=!1,e.pendingSlices.length>0)e.pendingSlices.forEach(n=>n.reject(r)),e.pendingSlices.length=0;else throw r})}supplyWorkerData(e,r){const n=e.currentPos,s=n+r.length;this.insertIntoCache({start:n,end:s,bytes:r,view:ae(r),age:this.nextAge++}),e.currentPos+=r.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let i=0;i<e.pendingSlices.length;i++){const a=e.pendingSlices[i],o=Math.max(n,a.start),l=Math.min(s,a.start+a.bytes.length);o<l&&a.bytes.set(r.subarray(o-n,l-n),o-a.start);for(let d=0;d<a.holes.length;d++){const u=a.holes[d];n<=u.start&&s>u.start&&(u.start=s),u.end<=u.start&&(a.holes.splice(d,1),d--)}a.holes.length===0&&(a.resolve(a.bytes),e.pendingSlices.splice(i,1),i--)}for(let i=0;i<this.workers.length;i++){const a=this.workers[i];e===a||a.running||br(n,s,a.currentPos,a.targetPos)&&(this.workers.splice(i,1),i--)}}forgetWorker(e){const r=this.workers.indexOf(e);m(r!==-1),this.workers.splice(r,1)}insertIntoCache(e){if(this.options.maxCacheSize===0)return;let r=W(this.cache,e.start,n=>n.start)+1;if(r>0){const n=this.cache[r-1];if(n.end>=e.end)return;if(n.end>e.start){const s=new Uint8Array(e.end-n.start);s.set(n.bytes,0),s.set(e.bytes,e.start-n.start),this.currentCacheSize+=e.end-n.end,n.bytes=s,n.view=ae(s),n.end=e.end,r--,e=n}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length;for(let n=r+1;n<this.cache.length;n++){const s=this.cache[n];if(e.end<=s.start)break;if(e.end>=s.end){this.cache.splice(n,1),this.currentCacheSize-=s.bytes.length,n--;continue}const i=new Uint8Array(s.end-e.start);i.set(e.bytes,0),i.set(s.bytes,s.start-e.start),this.currentCacheSize-=e.end-s.start,e.bytes=i,e.view=ae(i),e.end=s.end,this.cache.splice(n,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;){let n=0,s=this.cache[0];for(let i=1;i<this.cache.length;i++){const a=this.cache[i];a.age<s.age&&(n=i,s=a)}if(this.currentCacheSize-s.bytes.length<=this.options.maxCacheSize)break;this.cache.splice(n,1),this.currentCacheSize-=s.bytes.length}}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ra extends nt{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.fragments=[],this.currentFragment=null,this.fragmentLookupMutex=new We,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.inputTrack.getCodecParameterString()));return yn({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(r=>{var n;return((n=r.info)==null?void 0:n.type)==="video"}),hasAudio:this.tracks.some(r=>{var n;return((n=r.info)==null?void 0:n.type)==="audio"}),codecStrings:e.filter(Boolean)})}readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,fe,Se);if(r instanceof Promise&&(r=await r),!r)break;const n=e,s=Be(r);if(!s)break;if(s.name==="ftyp"){const i=re(r,4);this.isQuickTime=i==="qt  "}else if(s.name==="moov"){let i=this.reader.requestSlice(r.filePos,s.contentSize);if(i instanceof Promise&&(i=await i),!i)break;this.moovSlice=i,this.readContiguousBoxes(this.moovSlice);for(const a of this.tracks){const o=a.editListPreviousSegmentDurations/this.movieTimescale;a.editListOffset-=Math.round(o*a.timescale)}break}e=n+s.totalSize}if(this.isFragmented&&this.reader.fileSize!==null){let r=this.reader.requestSlice(this.reader.fileSize-4,4);r instanceof Promise&&(r=await r),m(r);const n=F(r),s=this.reader.fileSize-n;if(s>=0&&s<=this.reader.fileSize-Se){let i=this.reader.requestSliceRange(s,fe,Se);if(i instanceof Promise&&(i=await i),i){const a=Be(i);if(a&&a.name==="mfra"){let o=this.reader.requestSlice(i.filePos,a.contentSize);o instanceof Promise&&(o=await o),o&&this.readContiguousBoxes(o)}}}}})())}getSampleTableForTrack(e){var i,a;if(e.sampleTable)return e.sampleTable;const r={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};e.sampleTable=r,m(this.moovSlice);const n=this.moovSlice.slice(e.sampleTableByteOffset);if(this.currentTrack=e,this.traverseBox(n),this.currentTrack=null,((i=e.info)==null?void 0:i.type)==="audio"&&e.info.codec&&ne.includes(e.info.codec)&&r.sampleCompositionTimeOffsets.length===0){m(((a=e.info)==null?void 0:a.type)==="audio");const o=He(e.info.codec),l=[],d=[];for(let u=0;u<r.sampleToChunk.length;u++){const f=r.sampleToChunk[u],h=r.sampleToChunk[u+1],w=(h?h.startChunkIndex:r.chunkOffsets.length)-f.startChunkIndex;for(let c=0;c<w;c++){const p=f.startSampleIndex+c*f.samplesPerChunk,b=p+f.samplesPerChunk,k=W(r.sampleTimingEntries,p,P=>P.startIndex),g=r.sampleTimingEntries[k],y=W(r.sampleTimingEntries,b,P=>P.startIndex),T=r.sampleTimingEntries[y],S=g.startDecodeTimestamp+(p-g.startIndex)*g.delta,C=T.startDecodeTimestamp+(b-T.startIndex)*T.delta-S,_=K(l);_&&_.delta===C?_.count++:l.push({startIndex:f.startChunkIndex+c,startDecodeTimestamp:S,count:1,delta:C});const E=f.samplesPerChunk*o.sampleSize*e.info.numberOfChannels;d.push(E)}f.startSampleIndex=f.startChunkIndex,f.samplesPerChunk=1}r.sampleTimingEntries=l,r.sampleSizes=d}if(r.sampleCompositionTimeOffsets.length>0){r.presentationTimestamps=[];for(const o of r.sampleTimingEntries)for(let l=0;l<o.count;l++)r.presentationTimestamps.push({presentationTimestamp:o.startDecodeTimestamp+l*o.delta,sampleIndex:o.startIndex+l});for(const o of r.sampleCompositionTimeOffsets)for(let l=0;l<o.count;l++){const d=o.startIndex+l,u=r.presentationTimestamps[d];u&&(u.presentationTimestamp+=o.offset)}r.presentationTimestamps.sort((o,l)=>o.presentationTimestamp-l.presentationTimestamp),r.presentationTimestampIndexMap=Array(r.presentationTimestamps.length).fill(-1);for(let o=0;o<r.presentationTimestamps.length;o++)r.presentationTimestampIndexMap[r.presentationTimestamps[o].sampleIndex]=o}return r}async readFragment(e){let r=this.reader.requestSliceRange(e,fe,Se);r instanceof Promise&&(r=await r),m(r);const n=Be(r);m((n==null?void 0:n.name)==="moof");let s=this.reader.requestSlice(e,n.totalSize);s instanceof Promise&&(s=await s),m(s),this.traverseBox(s);const i=j(this.fragments,e,o=>o.moofOffset);m(i!==-1);const a=this.fragments[i];m(a.moofOffset===e);for(const[o,l]of a.trackData){if(l.startTimestampIsFinal)continue;const d=this.tracks.find(p=>p.id===o);let u=0,f=null,h=null;const w=W(d.fragments,e-1,p=>p.moofOffset);w!==-1&&(f=d.fragments[w],h=f,u=f.moofOffset+f.moofSize);let c=u===0;for(;u<=e-fe;){if(f!=null&&f.nextFragment)f=f.nextFragment,u=f.moofOffset+f.moofSize;else{let p=this.reader.requestSliceRange(u,fe,Se);if(p instanceof Promise&&(p=await p),!p)break;const b=u,k=Be(p);if(!k)break;if(k.name==="moof"){const g=j(this.fragments,b,T=>T.moofOffset);let y;g===-1?y=await this.readFragment(b):y=this.fragments[g],f&&(f.nextFragment=y),f=y,c&&(y.isKnownToBeFirstFragment=!0,c=!1)}u=b+k.totalSize}f&&f.trackData.has(o)&&(h=f)}if(h){const p=h.trackData.get(o);m(p.startTimestampIsFinal),Nr(l,p.endTimestamp)}l.startTimestampIsFinal=!0}return a}readContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-fe&&this.traverseBox(e););}traverseBox(e){var a,o,l,d,u,f,h,w;const r=e.filePos,n=Be(e);if(!n)return!1;const s=e.filePos,i=r+n.totalSize;switch(n.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":case"udta":this.readContiguousBoxes(e.slice(s,n.contentSize));break;case"mvhd":{const c=O(e);e.skip(3),c===1?(e.skip(16),this.movieTimescale=F(e),this.movieDurationInTimescale=ie(e)):(e.skip(8),this.movieTimescale=F(e),this.movieDurationInTimescale=F(e))}break;case"trak":{const c={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:ce,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[],fragmentsWithKeyFrame:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=c,this.readContiguousBoxes(e.slice(s,n.contentSize)),c.id!==-1&&c.timescale!==-1&&c.info!==null){if(c.info.type==="video"&&c.info.width!==-1){const p=c;c.inputTrack=new cr(new Da(p)),this.tracks.push(c)}else if(c.info.type==="audio"&&c.info.numberOfChannels!==-1){const p=c;c.inputTrack=new Le(new Na(p)),this.tracks.push(c)}}this.currentTrack=null}break;case"tkhd":{const c=this.currentTrack;m(c);const p=O(e);if(!((it(e)&1)!==0))break;if(p===0)e.skip(8),c.id=F(e),e.skip(4),c.durationInMovieTimescale=F(e);else if(p===1)e.skip(16),c.id=F(e),e.skip(4),c.durationInMovieTimescale=ie(e);else throw new Error(`Incorrect track header version ${p}.`);e.skip(2*4+2+2+2+2);const g=[_e(e),_e(e),Dt(e),_e(e),_e(e),Dt(e),_e(e),_e(e),Dt(e)],y=Hr(Xn(Ha(g),90));m(y===0||y===90||y===180||y===270),c.rotation=y}break;case"elst":{const c=this.currentTrack;m(c);const p=O(e);e.skip(3);let b=!1,k=0;const g=F(e);for(let y=0;y<g;y++){const T=p===1?ie(e):F(e),S=p===1?Ui(e):Oe(e),x=_e(e);if(T!==0){if(b){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(S===-1){k+=T;continue}if(x!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}c.editListPreviousSegmentDurations=k,c.editListOffset=S,b=!0}}}break;case"mdhd":{const c=this.currentTrack;m(c);const p=O(e);e.skip(3),p===0?(e.skip(8),c.timescale=F(e),c.durationInMediaTimescale=F(e)):p===1&&(e.skip(16),c.timescale=F(e),c.durationInMediaTimescale=ie(e));let b=te(e);if(b>0){c.languageCode="";for(let k=0;k<3;k++)c.languageCode=String.fromCharCode(96+(b&31))+c.languageCode,b>>=5;nr(c.languageCode)||(c.languageCode=ce)}}break;case"hdlr":{const c=this.currentTrack;m(c),e.skip(8);const p=re(e,4);p==="vide"?c.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:p==="soun"&&(c.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const c=this.currentTrack;m(c),c.sampleTableByteOffset=r,this.readContiguousBoxes(e.slice(s,n.contentSize))}break;case"stsd":{const c=this.currentTrack;if(m(c),c.info===null||c.sampleTable)break;const p=O(e);e.skip(3);const b=F(e);for(let k=0;k<b;k++){const g=e.filePos,y=Be(e);if(!y)break;c.internalCodecId=y.name;const T=y.name.toLowerCase();if(c.info.type==="video")T==="avc1"?c.info.codec="avc":T==="hvc1"||T==="hev1"?c.info.codec="hevc":T==="vp08"?c.info.codec="vp8":T==="vp09"?c.info.codec="vp9":T==="av01"?c.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${y.name}').`),e.skip(6*1+2+2+2+3*4),c.info.width=te(e),c.info.height=te(e),e.skip(50),this.readContiguousBoxes(e.slice(e.filePos,g+y.totalSize-e.filePos));else{T==="mp4a"||(T==="opus"?c.info.codec="opus":T==="flac"?c.info.codec="flac":T==="twos"||T==="sowt"||T==="raw "||T==="in24"||T==="in32"||T==="fl32"||T==="fl64"||T==="lpcm"||T==="ipcm"||T==="fpcm"||(T==="ulaw"?c.info.codec="ulaw":T==="alaw"?c.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${y.name}').`))),e.skip(6*1+2);const S=te(e);e.skip(3*2);let x=te(e),C=te(e);e.skip(2*2);let _=F(e)/65536;if(p===0&&S>0){if(S===1)e.skip(4),C=8*F(e),e.skip(2*4);else if(S===2){e.skip(4),_=Sn(e),x=F(e),e.skip(4),C=F(e);const E=F(e);if(e.skip(2*4),T==="lpcm"){const P=C+7>>3,A=!!(E&1),M=!!(E&2),X=E&4?-1:0;C>0&&C<=64&&(A?C===32&&(c.info.codec=M?"pcm-f32be":"pcm-f32"):X&1<<P-1?P===1?c.info.codec="pcm-s8":P===2?c.info.codec=M?"pcm-s16be":"pcm-s16":P===3?c.info.codec=M?"pcm-s24be":"pcm-s24":P===4&&(c.info.codec=M?"pcm-s32be":"pcm-s32"):P===1&&(c.info.codec="pcm-u8")),c.info.codec===null&&console.warn("Unsupported PCM format.")}}}c.info.numberOfChannels=x,c.info.sampleRate=_,T==="twos"?C===8?c.info.codec="pcm-s8":C===16?c.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${C} for codec 'twos'.`),c.info.codec=null):T==="sowt"?C===8?c.info.codec="pcm-s8":C===16?c.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${C} for codec 'sowt'.`),c.info.codec=null):T==="raw "?c.info.codec="pcm-u8":T==="in24"?c.info.codec="pcm-s24be":T==="in32"?c.info.codec="pcm-s32be":T==="fl32"?c.info.codec="pcm-f32be":T==="fl64"?c.info.codec="pcm-f64be":T==="ipcm"?c.info.codec="pcm-s16be":T==="fpcm"&&(c.info.codec="pcm-f32be"),this.readContiguousBoxes(e.slice(e.filePos,g+y.totalSize-e.filePos))}}}break;case"avcC":{const c=this.currentTrack;m(c&&c.info),c.info.codecDescription=q(e,n.contentSize)}break;case"hvcC":{const c=this.currentTrack;m(c&&c.info),c.info.codecDescription=q(e,n.contentSize)}break;case"vpcC":{const c=this.currentTrack;m(c&&((a=c.info)==null?void 0:a.type)==="video"),e.skip(4);const p=O(e),b=O(e),k=O(e),g=k>>4,y=k>>1&7,T=k&1,S=O(e),x=O(e),C=O(e);c.info.vp9CodecInfo={profile:p,level:b,bitDepth:g,chromaSubsampling:y,videoFullRangeFlag:T,colourPrimaries:S,transferCharacteristics:x,matrixCoefficients:C}}break;case"av1C":{const c=this.currentTrack;m(c&&((o=c.info)==null?void 0:o.type)==="video"),e.skip(1);const p=O(e),b=p>>5,k=p&31,g=O(e),y=g>>7,T=g>>6&1,S=g>>5&1,x=g>>4&1,C=g>>3&1,_=g>>2&1,E=g&3,P=b===2&&T?S?12:10:T?10:8;c.info.av1CodecInfo={profile:b,level:k,tier:y,bitDepth:P,monochrome:x,chromaSubsamplingX:C,chromaSubsamplingY:_,chromaSamplePosition:E}}break;case"colr":{const c=this.currentTrack;if(m(c&&((l=c.info)==null?void 0:l.type)==="video"),re(e,4)!=="nclx")break;const b=te(e),k=te(e),g=te(e),y=!!(O(e)&128);c.info.colorSpace={primaries:qr[b],transfer:$r[k],matrix:jr[g],fullRange:y}}break;case"wave":this.readContiguousBoxes(e.slice(s,n.contentSize));break;case"esds":{const c=this.currentTrack;m(c&&((d=c.info)==null?void 0:d.type)==="audio"),e.skip(4);const p=O(e);m(p===3),Nt(e),e.skip(2);const b=O(e),k=(b&128)!==0,g=(b&64)!==0,y=(b&32)!==0;if(k&&e.skip(2),g){const _=O(e);e.skip(_)}y&&e.skip(2);const T=O(e);m(T===4);const S=Nt(e),x=e.filePos,C=O(e);if(C===64||C===103?(c.info.codec="aac",c.info.aacCodecInfo={isMpeg2:C===103}):C===105||C===107?c.info.codec="mp3":C===221?c.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${C}) - discarding track.`),e.skip(12),S>e.filePos-x){const _=O(e);m(_===5);const E=Nt(e);if(c.info.codecDescription=q(e,E),c.info.codec==="aac"){const P=tn(c.info.codecDescription);P.numberOfChannels!==null&&(c.info.numberOfChannels=P.numberOfChannels),P.sampleRate!==null&&(c.info.sampleRate=P.sampleRate)}}}break;case"enda":{const c=this.currentTrack;m(c&&((u=c.info)==null?void 0:u.type)==="audio"),te(e)&255&&(c.info.codec==="pcm-s16be"?c.info.codec="pcm-s16":c.info.codec==="pcm-s24be"?c.info.codec="pcm-s24":c.info.codec==="pcm-s32be"?c.info.codec="pcm-s32":c.info.codec==="pcm-f32be"?c.info.codec="pcm-f32":c.info.codec==="pcm-f64be"&&(c.info.codec="pcm-f64"))}break;case"pcmC":{const c=this.currentTrack;m(c&&((f=c.info)==null?void 0:f.type)==="audio"),e.skip(4);const b=!!(O(e)&1),k=O(e);c.info.codec==="pcm-s16be"?b?k===16?c.info.codec="pcm-s16":k===24?c.info.codec="pcm-s24":k===32?c.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${k}.`),c.info.codec=null):k===16?c.info.codec="pcm-s16be":k===24?c.info.codec="pcm-s24be":k===32?c.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${k}.`),c.info.codec=null):c.info.codec==="pcm-f32be"&&(b?k===32?c.info.codec="pcm-f32":k===64?c.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${k}.`),c.info.codec=null):k===32?c.info.codec="pcm-f32be":k===64?c.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${k}.`),c.info.codec=null));break}case"dOps":{const c=this.currentTrack;m(c&&((h=c.info)==null?void 0:h.type)==="audio"),e.skip(1);const p=O(e),b=te(e),k=F(e),g=$t(e),y=O(e);let T;y!==0?T=q(e,2+p):T=new Uint8Array(0);const S=new Uint8Array(19+T.byteLength),x=new DataView(S.buffer);x.setUint32(0,1332770163,!1),x.setUint32(4,1214603620,!1),x.setUint8(8,1),x.setUint8(9,p),x.setUint16(10,b,!0),x.setUint32(12,k,!0),x.setInt16(16,g,!0),x.setUint8(18,y),S.set(T,19),c.info.codecDescription=S,c.info.numberOfChannels=p,c.info.sampleRate=k}break;case"dfLa":{const c=this.currentTrack;m(c&&((w=c.info)==null?void 0:w.type)==="audio"),e.skip(4);const p=127,b=128,k=e.filePos;for(;e.filePos<i;){const x=O(e),C=it(e);if((x&p)===0){e.skip(10);const E=F(e),P=E>>>12,A=(E>>9&7)+1;c.info.sampleRate=P,c.info.numberOfChannels=A,e.skip(20)}else e.skip(C);if(x&b)break}const g=e.filePos;e.filePos=k;const y=q(e,g-k),T=new Uint8Array(4+y.byteLength);new DataView(T.buffer).setUint32(0,1716281667,!1),T.set(y,4),c.info.codecDescription=T}break;case"stts":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e);let b=0,k=0;for(let g=0;g<p;g++){const y=F(e),T=F(e);c.sampleTable.sampleTimingEntries.push({startIndex:b,startDecodeTimestamp:k,count:y,delta:T}),b+=y,k+=y*T}}break;case"ctts":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e);let b=0;for(let k=0;k<p;k++){const g=F(e),y=Oe(e);c.sampleTable.sampleCompositionTimeOffsets.push({startIndex:b,count:g,offset:y}),b+=g}}break;case"stsz":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e),b=F(e);if(p===0)for(let k=0;k<b;k++){const g=F(e);c.sampleTable.sampleSizes.push(g)}else c.sampleTable.sampleSizes.push(p)}break;case"stz2":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4),e.skip(3);const p=O(e),b=F(e),k=q(e,Math.ceil(b*p/8)),g=new Z(k);for(let y=0;y<b;y++){const T=g.readBits(p);c.sampleTable.sampleSizes.push(T)}}break;case"stss":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4),c.sampleTable.keySampleIndices=[];const p=F(e);for(let b=0;b<p;b++){const k=F(e)-1;c.sampleTable.keySampleIndices.push(k)}c.sampleTable.keySampleIndices[0]!==0&&c.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e);for(let k=0;k<p;k++){const g=F(e)-1,y=F(e),T=F(e);c.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:g,samplesPerChunk:y,sampleDescriptionIndex:T})}let b=0;for(let k=0;k<c.sampleTable.sampleToChunk.length;k++)if(c.sampleTable.sampleToChunk[k].startSampleIndex=b,k<c.sampleTable.sampleToChunk.length-1){const y=c.sampleTable.sampleToChunk[k+1].startChunkIndex-c.sampleTable.sampleToChunk[k].startChunkIndex;b+=y*c.sampleTable.sampleToChunk[k].samplesPerChunk}}break;case"stco":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e);for(let b=0;b<p;b++){const k=F(e);c.sampleTable.chunkOffsets.push(k)}}break;case"co64":{const c=this.currentTrack;if(m(c),!c.sampleTable)break;e.skip(4);const p=F(e);for(let b=0;b<p;b++){const k=ie(e);c.sampleTable.chunkOffsets.push(k)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(e.slice(s,n.contentSize));break;case"mehd":{const c=O(e);e.skip(3);const p=c===1?ie(e):F(e);this.movieDurationInTimescale=p}break;case"trex":{e.skip(4);const c=F(e),p=F(e),b=F(e),k=F(e),g=F(e);this.fragmentTrackDefaults.push({trackId:c,defaultSampleDescriptionIndex:p,defaultSampleDuration:b,defaultSampleSize:k,defaultSampleFlags:g})}break;case"tfra":{const c=O(e);e.skip(3);const p=F(e),b=this.tracks.find(P=>P.id===p);if(!b)break;b.fragmentLookupTable=[];const k=F(e),g=(k&48)>>4,y=(k&12)>>2,T=k&3,S=[O,te,it,F],x=S[g],C=S[y],_=S[T],E=F(e);for(let P=0;P<E;P++){const A=c===1?ie(e):F(e),M=c===1?ie(e):F(e);x(e),C(e),_(e),b.fragmentLookupTable.push({timestamp:A,moofOffset:M})}}break;case"moof":{this.currentFragment={moofOffset:r,moofSize:n.totalSize,implicitBaseDataOffset:r,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null,isKnownToBeFirstFragment:!1},this.readContiguousBoxes(e.slice(s,n.contentSize)),Ze(this.fragments,this.currentFragment,c=>c.moofOffset);for(const[,c]of this.currentFragment.trackData){const p=c.samples[0],b=K(c.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,p.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,b.byteOffset+b.byteSize)}this.currentFragment=null}break;case"traf":if(m(this.currentFragment),this.readContiguousBoxes(e.slice(s,n.contentSize)),this.currentTrack){const c=this.currentFragment.trackData.get(this.currentTrack.id);if(c){Ze(this.currentTrack.fragments,this.currentFragment,k=>k.moofOffset),c.firstKeyFrameTimestamp!==null&&Ze(this.currentTrack.fragmentsWithKeyFrame,this.currentFragment,k=>k.moofOffset);const{currentFragmentState:b}=this.currentTrack;m(b),b.startTimestamp!==null&&(Nr(c,b.startTimestamp),c.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{m(this.currentFragment),e.skip(1);const c=it(e),p=!!(c&1),b=!!(c&2),k=!!(c&8),g=!!(c&16),y=!!(c&32),T=!!(c&65536),S=!!(c&131072),x=F(e),C=this.tracks.find(E=>E.id===x);if(!C)break;const _=this.fragmentTrackDefaults.find(E=>E.trackId===x);this.currentTrack=C,C.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:(_==null?void 0:_.defaultSampleDescriptionIndex)??null,defaultSampleDuration:(_==null?void 0:_.defaultSampleDuration)??null,defaultSampleSize:(_==null?void 0:_.defaultSampleSize)??null,defaultSampleFlags:(_==null?void 0:_.defaultSampleFlags)??null,startTimestamp:null},p?C.currentFragmentState.baseDataOffset=ie(e):S&&(C.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),b&&(C.currentFragmentState.sampleDescriptionIndex=F(e)),k&&(C.currentFragmentState.defaultSampleDuration=F(e)),g&&(C.currentFragmentState.defaultSampleSize=F(e)),y&&(C.currentFragmentState.defaultSampleFlags=F(e)),T&&(C.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const c=this.currentTrack;if(!c)break;m(c.currentFragmentState);const p=O(e);e.skip(3);const b=p===0?F(e):ie(e);c.currentFragmentState.startTimestamp=b}break;case"trun":{const c=this.currentTrack;if(!c)break;if(m(this.currentFragment),m(c.currentFragmentState),this.currentFragment.trackData.has(c.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const p=O(e),b=it(e),k=!!(b&1),g=!!(b&4),y=!!(b&256),T=!!(b&512),S=!!(b&1024),x=!!(b&2048),C=F(e);let _=c.currentFragmentState.baseDataOffset;k&&(_+=Oe(e));let E=null;g&&(E=F(e));let P=_;if(C===0){this.currentFragment.implicitBaseDataOffset=P;break}let A=0;const M={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(c.id,M);for(let G=0;G<C;G++){let ee;y?ee=F(e):(m(c.currentFragmentState.defaultSampleDuration!==null),ee=c.currentFragmentState.defaultSampleDuration);let se;T?se=F(e):(m(c.currentFragmentState.defaultSampleSize!==null),se=c.currentFragmentState.defaultSampleSize);let ge;S?ge=F(e):(m(c.currentFragmentState.defaultSampleFlags!==null),ge=c.currentFragmentState.defaultSampleFlags),G===0&&E!==null&&(ge=E);let $e=0;x&&(p===0?$e=F(e):$e=Oe(e));const bt=!(ge&65536);M.samples.push({presentationTimestamp:A+$e,duration:ee,byteOffset:P,byteSize:se,isKeyFrame:bt}),P+=se,A+=ee}M.presentationTimestamps=M.samples.map((G,ee)=>({presentationTimestamp:G.presentationTimestamp,sampleIndex:ee})).sort((G,ee)=>G.presentationTimestamp-ee.presentationTimestamp);for(let G=0;G<M.presentationTimestamps.length;G++){const ee=M.presentationTimestamps[G],se=M.samples[ee.sampleIndex];if(M.firstKeyFrameTimestamp===null&&se.isKeyFrame&&(M.firstKeyFrameTimestamp=se.presentationTimestamp),G<M.presentationTimestamps.length-1){const ge=M.presentationTimestamps[G+1];se.duration=ge.presentationTimestamp-ee.presentationTimestamp}}const X=M.samples[M.presentationTimestamps[0].sampleIndex],le=M.samples[K(M.presentationTimestamps).sampleIndex];M.startTimestamp=X.presentationTimestamp,M.endTimestamp=le.presentationTimestamp+le.duration,this.currentFragment.implicitBaseDataOffset=P}break;case"Â©nam":case"name":{if(!this.currentTrack)break;this.currentTrack.name=Lr.decode(q(e,n.contentSize))}break}return e.filePos=i,!0}}class Dn{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}async getFirstPacket(e){const r=await this.fetchPacketForSampleIndex(0,e);return r||!this.internalTrack.demuxer.isFragmented?r:this.performFragmentedLookup(()=>{const n=this.internalTrack.demuxer.fragments[0]??null;if(n!=null&&n.isKnownToBeFirstFragment){let s=n;for(;s;){if(s.trackData.get(this.internalTrack.id))return{fragmentIndex:j(this.internalTrack.fragments,s.moofOffset,a=>a.moofOffset),sampleIndex:0,correctSampleFound:!0};s=s.nextFragment}}return{fragmentIndex:-1,sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return xt(e*this.internalTrack.timescale,14)+this.internalTrack.editListOffset}async getPacket(e,r){const n=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=Dr(s,n),a=await this.fetchPacketForSampleIndex(i,r);return!Vr(s)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0)return this.fetchPacketForSampleIndex(n+1,r);const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");const i=s.fragment.trackData.get(this.internalTrack.id),a=j(this.internalTrack.fragments,s.fragment.moofOffset,o=>o.moofOffset);return m(a!==-1),this.performFragmentedLookup(()=>{if(s.sampleIndex+1<i.samples.length)return{fragmentIndex:a,sampleIndex:s.sampleIndex+1,correctSampleFound:!0};{let o=s.fragment;for(;o.nextFragment;)if(o=o.nextFragment,o.trackData.get(this.internalTrack.id)){const d=j(this.internalTrack.fragments,o.moofOffset,u=>u.moofOffset);return m(d!==-1),{fragmentIndex:d,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=Dr(s,n),a=i===-1?-1:Ua(s,i),o=await this.fetchPacketForSampleIndex(a,r);return!Vr(s)||!this.internalTrack.demuxer.isFragmented?o:this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToSampleIndex.get(e);if(n!==void 0){const o=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),l=Wa(o,n);return this.fetchPacketForSampleIndex(l,r)}const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");const i=s.fragment.trackData.get(this.internalTrack.id),a=j(this.internalTrack.fragments,s.fragment.moofOffset,o=>o.moofOffset);return m(a!==-1),this.performFragmentedLookup(()=>{const o=i.samples.findIndex((l,d)=>l.isKeyFrame&&d>s.sampleIndex);if(o!==-1)return{fragmentIndex:a,sampleIndex:o,correctSampleFound:!0};{let l=s.fragment;for(;l.nextFragment;){l=l.nextFragment;const d=l.trackData.get(this.internalTrack.id);if(d&&d.firstKeyFrameTimestamp!==null){const u=j(this.internalTrack.fragments,l.moofOffset,h=>h.moofOffset);m(u!==-1);const f=d.samples.findIndex(h=>h.isKeyFrame);return m(f!==-1),{fragmentIndex:u,sampleIndex:f,correctSampleFound:!0}}}return{fragmentIndex:a,sampleIndex:-1,correctSampleFound:!1}}},-1/0,1/0,r)}async fetchPacketForSampleIndex(e,r){if(e===-1)return null;const n=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=Va(n,e);if(!s)return null;let i;if(r.metadataOnly)i=pe;else{let d=this.internalTrack.demuxer.reader.requestSlice(s.sampleOffset,s.sampleSize);d instanceof Promise&&(d=await d),m(d),i=q(d,s.sampleSize)}const a=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=s.duration/this.internalTrack.timescale,l=new $(i,s.isKeyFrame?"key":"delta",a,o,e,s.sampleSize);return this.packetToSampleIndex.set(l,e),l}async fetchPacketInFragment(e,r,n){if(r===-1)return null;const i=e.trackData.get(this.internalTrack.id).samples[r];m(i);let a;if(n.metadataOnly)a=pe;else{let u=this.internalTrack.demuxer.reader.requestSlice(i.byteOffset,i.byteSize);u instanceof Promise&&(u=await u),m(u),a=q(u,i.byteSize)}const o=(i.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,l=i.duration/this.internalTrack.timescale,d=new $(a,i.isKeyFrame?"key":"delta",o,l,e.moofOffset+r,i.byteSize);return this.packetToFragmentLocation.set(d,{fragment:e,sampleIndex:r}),d}findSampleInFragmentsForTimestamp(e){const r=W(this.internalTrack.fragments,e,i=>i.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,s=!1;if(r!==-1){const a=this.internalTrack.fragments[r].trackData.get(this.internalTrack.id),o=W(a.presentationTimestamps,e,l=>l.presentationTimestamp);m(o!==-1),n=a.presentationTimestamps[o].sampleIndex,s=e<a.endTimestamp}return{fragmentIndex:r,sampleIndex:n,correctSampleFound:s}}findKeySampleInFragmentsForTimestamp(e){const r=W(this.internalTrack.fragmentsWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,s=-1,i=!1;if(r!==-1){const a=this.internalTrack.fragmentsWithKeyFrame[r];n=j(this.internalTrack.fragments,a.moofOffset,u=>u.moofOffset),m(n!==-1);const o=a.trackData.get(this.internalTrack.id),l=Qr(o.presentationTimestamps,u=>o.samples[u.sampleIndex].isKeyFrame&&u.presentationTimestamp<=e);m(l!==-1),s=o.presentationTimestamps[l].sampleIndex,i=e<o.endTimestamp}return{fragmentIndex:n,sampleIndex:s,correctSampleFound:i}}async performFragmentedLookup(e,r,n,s){const i=this.internalTrack.demuxer,a=await i.fragmentLookupMutex.acquire();try{const{fragmentIndex:o,sampleIndex:l,correctSampleFound:d}=e();if(d){const g=this.internalTrack.fragments[o];return this.fetchPacketInFragment(g,l,s)}let u=null,f=o,h=l;const w=this.internalTrack.fragmentLookupTable?W(this.internalTrack.fragmentLookupTable,r,g=>g.timestamp):-1,c=w!==-1?this.internalTrack.fragmentLookupTable[w]:null;let p,b=!1;if(o===-1)p=(c==null?void 0:c.moofOffset)??0,b=p===0;else{const g=this.internalTrack.fragments[o];!c||g.moofOffset>=c.moofOffset?(p=g.moofOffset+g.moofSize,u=g):p=c.moofOffset}for(;;){if(u){const S=u.trackData.get(this.internalTrack.id);if(S&&S.startTimestamp>n)break;if(u.nextFragment){p=u.nextFragment.moofOffset+u.nextFragment.moofSize,u=u.nextFragment;continue}}let g=i.reader.requestSliceRange(p,fe,Se);if(g instanceof Promise&&(g=await g),!g)break;const y=p,T=Be(g);if(!T)break;if(T.name==="moof"){const S=j(i.fragments,y,P=>P.moofOffset);let x;S===-1?x=await i.readFragment(y):x=i.fragments[S],u&&(u.nextFragment=x),u=x,b&&(x.isKnownToBeFirstFragment=!0,b=!1);const{fragmentIndex:C,sampleIndex:_,correctSampleFound:E}=e();if(E){const P=this.internalTrack.fragments[C];return this.fetchPacketInFragment(P,_,s)}C!==-1&&(f=C,h=_)}p=y+T.totalSize}const k=f!==-1?this.internalTrack.fragments[f]:null;if(c&&(!k||k.moofOffset<c.moofOffset)){const g=this.internalTrack.fragmentLookupTable[w-1],y=(g==null?void 0:g.timestamp)??-1/0;return this.performFragmentedLookup(e,y,n,s)}return k?this.fetchPacketInFragment(k,h,s):null}finally{a()}}}class Da extends Dn{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){var e,r,n,s;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(r=this.internalTrack.info.colorSpace)==null?void 0:r.transfer,matrix:(n=this.internalTrack.info.colorSpace)==null?void 0:n.matrix,fullRange:(s=this.internalTrack.info.colorSpace)==null?void 0:s.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&on(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&ln(e.data)}return{codec:Zr(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class Na extends Dn{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:Jr(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const Dr=(t,e)=>{if(t.presentationTimestamps){const r=W(t.presentationTimestamps,e,n=>n.presentationTimestamp);return r===-1?-1:t.presentationTimestamps[r].sampleIndex}else{const r=W(t.sampleTimingEntries,e,s=>s.startDecodeTimestamp);if(r===-1)return-1;const n=t.sampleTimingEntries[r];return n.startIndex+Math.min(Math.floor((e-n.startDecodeTimestamp)/n.delta),n.count-1)}},Va=(t,e)=>{const r=W(t.sampleTimingEntries,e,k=>k.startIndex),n=t.sampleTimingEntries[r];if(!n||n.startIndex+n.count<=e)return null;let i=n.startDecodeTimestamp+(e-n.startIndex)*n.delta;const a=W(t.sampleCompositionTimeOffsets,e,k=>k.startIndex),o=t.sampleCompositionTimeOffsets[a];o&&e-o.startIndex<o.count&&(i+=o.offset);const l=t.sampleSizes[Math.min(e,t.sampleSizes.length-1)],d=W(t.sampleToChunk,e,k=>k.startSampleIndex),u=t.sampleToChunk[d];m(u);const f=u.startChunkIndex+Math.floor((e-u.startSampleIndex)/u.samplesPerChunk),h=t.chunkOffsets[f],w=u.startSampleIndex+(f-u.startChunkIndex)*u.samplesPerChunk;let c=0,p=h;if(t.sampleSizes.length===1)p+=l*(e-w),c+=l*u.samplesPerChunk;else for(let k=w;k<w+u.samplesPerChunk;k++){const g=t.sampleSizes[k];k<e&&(p+=g),c+=g}let b=n.delta;if(t.presentationTimestamps){const k=t.presentationTimestampIndexMap[e];m(k!==void 0),k<t.presentationTimestamps.length-1&&(b=t.presentationTimestamps[k+1].presentationTimestamp-i)}return{presentationTimestamp:i,duration:b,sampleOffset:p,sampleSize:l,chunkOffset:h,chunkSize:c,isKeyFrame:t.keySampleIndices?j(t.keySampleIndices,e,k=>k)!==-1:!0}},Ua=(t,e)=>{if(!t.keySampleIndices)return e;const r=W(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r]??-1},Wa=(t,e)=>{if(!t.keySampleIndices)return e+1;const r=W(t.keySampleIndices,e,n=>n);return t.keySampleIndices[r+1]??-1},Nr=(t,e)=>{t.startTimestamp+=e,t.endTimestamp+=e;for(const r of t.samples)r.presentationTimestamp+=e;for(const r of t.presentationTimestamps)r.presentationTimestamp+=e},Ha=t=>{const[e,,,r]=t,n=Math.hypot(e,r),s=e/n,i=r/n,a=-Math.atan2(i,s)*(180/Math.PI);return Number.isFinite(a)?a:0},Vr=t=>t.sampleSizes.length===0;/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var we;(function(t){t[t.None=0]="None",t[t.Xiph=1]="Xiph",t[t.FixedSize=2]="FixedSize",t[t.Ebml=3]="Ebml"})(we||(we={}));const Lt=[{id:v.SeekHead,flag:"seekHeadSeen"},{id:v.Info,flag:"infoSeen"},{id:v.Tracks,flag:"tracksSeen"},{id:v.Cues,flag:"cuesSeen"}],Nn=10*2**20;class La extends nt{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentCueTime=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(r=>r.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.getCodecParameterString()));return Xi({isWebM:this.isWebM,hasVideo:this.segments.some(n=>n.tracks.some(s=>{var i;return((i=s.info)==null?void 0:i.type)==="video"})),hasAudio:this.segments.some(n=>n.tracks.some(s=>{var i;return((i=s.info)==null?void 0:i.type)==="audio"})),codecStrings:r.filter(Boolean)})}readMetadata(){return this.readMetadataPromise??(this.readMetadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,oe,ve);if(r instanceof Promise&&(r=await r),!r)break;const n=xe(r);if(!n)break;const s=n.id;let i=n.size;const a=r.filePos;if(s===v.EBML){Qe(i);let o=this.reader.requestSlice(a,i);if(o instanceof Promise&&(o=await o),!o)break;this.readContiguousElements(o)}else if(s===v.Segment){if(await this.readSegment(a,i),i===null||this.reader.fileSize===null)break}else if(s===v.Cluster){if(this.reader.fileSize===null)break;i===null&&(i=(await Xt(this.reader,a,Kt,this.reader.fileSize)).pos-a);const o=K(this.segments);o&&(o.elementEndPos=a+i)}Qe(i),e=a+i}})())}async readSegment(e,r){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:e,elementEndPos:r===null?null:e+r,clusterSeekStartPos:e,clusters:[],clusterLookupMutex:new We},this.segments.push(this.currentSegment);let n=e;for(;this.currentSegment.elementEndPos===null||n<this.currentSegment.elementEndPos;){let l=this.reader.requestSliceRange(n,oe,ve);if(l instanceof Promise&&(l=await l),!l)break;const d=n,u=xe(l);if(!u||!ht.includes(u.id)&&u.id!==v.Void){const p=await Pn(this.reader,d,ht,Math.min(this.currentSegment.elementEndPos??1/0,d+Nn));if(p){n=p;continue}else break}const{id:f,size:h}=u,w=l.filePos,c=Lt.findIndex(p=>p.id===f);if(c!==-1){const p=Lt[c].flag;this.currentSegment[p]=!0,Qe(h);let b=this.reader.requestSlice(w,h);b instanceof Promise&&(b=await b),b&&this.readContiguousElements(b)}else if(f===v.Cluster){this.currentSegment.clusterSeekStartPos=d;break}if(h===null)break;n=w+h}if(this.reader.fileSize!==null){this.currentSegment.seekEntries.sort((l,d)=>l.segmentPosition-d.segmentPosition);for(const l of this.currentSegment.seekEntries){const d=Lt.find(p=>p.id===l.id);if(!d||this.currentSegment[d.flag])continue;let u=this.reader.requestSliceRange(e+l.segmentPosition,oe,ve);if(u instanceof Promise&&(u=await u),!u)continue;const f=xe(u);if(!f)continue;const{id:h,size:w}=f;if(h!==d.id)continue;Qe(w),this.currentSegment[d.flag]=!0;let c=this.reader.requestSlice(u.filePos,w);c instanceof Promise&&(c=await c),c&&this.readContiguousElements(c)}}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6),this.currentSegment.tracks.sort((l,d)=>Number(d.isDefault)-Number(l.isDefault)),this.currentSegment.cuePoints.sort((l,d)=>l.clusterPosition-d.clusterPosition);const s=this.currentSegment.tracks.map(l=>l.id),i=new Set;let a=null,o=null;for(const l of this.currentSegment.cuePoints){if(l.clusterPosition!==a){for(const u of i)m(o),this.currentSegment.tracks.find(h=>h.id===u).cuePoints.push(o);for(const u of s)i.add(u)}if(o=l,!i.has(l.trackId))continue;this.currentSegment.tracks.find(u=>u.id===l.trackId).cuePoints.push(l),i.delete(l.trackId),a=l.clusterPosition}for(const l of i)m(o),this.currentSegment.tracks.find(u=>u.id===l).cuePoints.push(o);for(const l of this.currentSegment.tracks)l.cuePoints.sort((d,u)=>d.time-u.time);this.currentSegment=null}async readCluster(e,r){let n=this.reader.requestSliceRange(e,oe,ve);n instanceof Promise&&(n=await n),m(n);const s=e,i=xe(n);m(i);const a=i.id;let o=i.size;const l=n.filePos;o===null&&(o=(await Xt(this.reader,l,Kt,r.elementEndPos)).pos-l),m(a===v.Cluster);let d=this.reader.requestSlice(l,o);d instanceof Promise&&(d=await d);const u={elementStartPos:s,elementEndPos:l+o,dataStartPos:l,timestamp:-1,trackData:new Map,nextCluster:null,isKnownToBeFirstCluster:!1};this.currentCluster=u,d&&this.readContiguousElements(d);for(const[f,h]of u.trackData){const w=r.tracks.find(g=>g.id===f)??null;m(h.blocks.length>0);let c=!1,p=!1;for(let g=0;g<h.blocks.length;g++){const y=h.blocks[g];y.timestamp+=u.timestamp,c||(c=y.referencedTimestamps.length>0),p||(p=y.lacing!==we.None)}c&&(h.blocks=ja(h.blocks)),h.presentationTimestamps=h.blocks.map((g,y)=>({timestamp:g.timestamp,blockIndex:y})).sort((g,y)=>g.timestamp-y.timestamp);for(let g=0;g<h.presentationTimestamps.length;g++){const y=h.presentationTimestamps[g],T=h.blocks[y.blockIndex];if(h.firstKeyFrameTimestamp===null&&T.isKeyFrame&&(h.firstKeyFrameTimestamp=T.timestamp),g<h.presentationTimestamps.length-1){const S=h.presentationTimestamps[g+1];T.duration=S.timestamp-T.timestamp}else T.duration===0&&(w==null?void 0:w.defaultDuration)!=null&&T.lacing===we.None&&(T.duration=w.defaultDuration)}p&&(this.expandLacedBlocks(h.blocks,w),h.presentationTimestamps=h.blocks.map((g,y)=>({timestamp:g.timestamp,blockIndex:y})).sort((g,y)=>g.timestamp-y.timestamp));const b=h.blocks[h.presentationTimestamps[0].blockIndex],k=h.blocks[K(h.presentationTimestamps).blockIndex];h.startTimestamp=b.timestamp,h.endTimestamp=k.timestamp+k.duration,w&&(Ze(w.clusters,u,y=>y.elementStartPos),h.firstKeyFrameTimestamp!==null&&Ze(w.clustersWithKeyFrame,u,y=>y.elementStartPos))}return Ze(r.clusters,u,f=>f.elementStartPos),this.currentCluster=null,u}getTrackDataInCluster(e,r){let n=e.trackData.get(r);return n||(n={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(r,n)),n}expandLacedBlocks(e,r){for(let n=0;n<e.length;n++){const s=e[n];if(s.lacing===we.None)continue;const i=tt.tempFromBytes(s.data),a=[],o=O(i)+1;switch(s.lacing){case we.Xiph:{let l=0;for(let d=0;d<o-1;d++){let u=0;for(;i.bufferPos<i.length;){const f=O(i);if(u+=f,f<255){a.push(u),l+=u;break}}}a.push(i.length-(i.bufferPos+l))}break;case we.FixedSize:{const l=i.length-1,d=Math.floor(l/o);for(let u=0;u<o;u++)a.push(d)}break;case we.Ebml:{const l=lt(i);m(l!==null);let d=l;a.push(d);let u=d;for(let f=1;f<o-1;f++){const h=i.bufferPos,w=lt(i);m(w!==null);const c=w,b=(1<<(i.bufferPos-h)*7-1)-1,k=c-b;d+=k,a.push(d),u+=d}a.push(i.length-(i.bufferPos+u))}break;default:m(!1)}m(a.length===o),e.splice(n,1);for(let l=0;l<o;l++){const d=a[l],u=q(i,d),f=s.duration||o*((r==null?void 0:r.defaultDuration)??0),h=s.timestamp+f*l/o,w=f/o;e.splice(n+l,0,{timestamp:h,duration:w,isKeyFrame:s.isKeyFrame,referencedTimestamps:s.referencedTimestamps,data:u,lacing:we.None})}n+=o,n--}}readContiguousElements(e){const r=e.filePos;for(;e.filePos-r<=e.length-oe&&this.traverseElement(e););}traverseElement(e){var a,o,l,d,u,f,h,w,c,p,b,k,g,y,T,S,x,C,_,E,P,A,M,X,le,G,ee,se,ge,$e,bt,ur;const r=xe(e);if(!r)return!1;const{id:n,size:s}=r,i=e.filePos;switch(Qe(s),n){case v.DocType:this.isWebM=ut(e,s)==="webm";break;case v.Seek:{if(!this.currentSegment)break;const z={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(z),this.readContiguousElements(e.slice(i,s)),(z.id===-1||z.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case v.SeekID:{const z=(a=this.currentSegment)==null?void 0:a.seekEntries[this.currentSegment.seekEntries.length-1];if(!z)break;z.id=U(e,s)}break;case v.SeekPosition:{const z=(o=this.currentSegment)==null?void 0:o.seekEntries[this.currentSegment.seekEntries.length-1];if(!z)break;z.segmentPosition=U(e,s)}break;case v.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=U(e,s),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case v.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=Vt(e,s)}break;case v.TrackEntry:{if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusters:[],clustersWithKeyFrame:[],cuePoints:[],isDefault:!1,inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,name:null,languageCode:ce,info:null},this.readContiguousElements(e.slice(i,s)),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const z=this.currentTrack.codecId.indexOf("/"),H=z===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,z);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===de.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===de.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===de.vp8?this.currentTrack.info.codec="vp8":H===de.vp9?this.currentTrack.info.codec="vp9":H===de.av1&&(this.currentTrack.info.codec="av1");const Ee=this.currentTrack,Ie=new cr(new qa(Ee));this.currentTrack.inputTrack=Ie,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){H===de.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===de.mp3?this.currentTrack.info.codec="mp3":H===de.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===de.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):H===de.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const Ee=this.currentTrack,Ie=new Le(new $a(Ee));this.currentTrack.inputTrack=Ie,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case v.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=U(e,s)}break;case v.TrackType:{if(!this.currentTrack)break;const z=U(e,s);z===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null}:z===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case v.FlagEnabled:{if(!this.currentTrack)break;U(e,s)||(this.currentSegment.tracks.pop(),this.currentTrack=null)}break;case v.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.isDefault=!!U(e,s)}break;case v.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=ut(e,s)}break;case v.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=q(e,s)}break;case v.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*U(e,s)/1e9}break;case v.Name:{if(!this.currentTrack)break;this.currentTrack.name=Qi(e,s)}break;case v.Language:{if(!this.currentTrack||this.currentTrack.languageCode!==ce)break;this.currentTrack.languageCode=ut(e,s),nr(this.currentTrack.languageCode)||(this.currentTrack.languageCode=ce)}break;case v.LanguageBCP47:{if(!this.currentTrack)break;const H=ut(e,s).split("-")[0];H?this.currentTrack.languageCode=H:this.currentTrack.languageCode=ce}break;case v.Video:{if(((d=(l=this.currentTrack)==null?void 0:l.info)==null?void 0:d.type)!=="video")break;this.readContiguousElements(e.slice(i,s))}break;case v.PixelWidth:{if(((f=(u=this.currentTrack)==null?void 0:u.info)==null?void 0:f.type)!=="video")break;this.currentTrack.info.width=U(e,s)}break;case v.PixelHeight:{if(((w=(h=this.currentTrack)==null?void 0:h.info)==null?void 0:w.type)!=="video")break;this.currentTrack.info.height=U(e,s)}break;case v.Colour:{if(((p=(c=this.currentTrack)==null?void 0:c.info)==null?void 0:p.type)!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e.slice(i,s))}break;case v.MatrixCoefficients:{if(((k=(b=this.currentTrack)==null?void 0:b.info)==null?void 0:k.type)!=="video"||!this.currentTrack.info.colorSpace)break;const z=U(e,s),H=jr[z]??null;this.currentTrack.info.colorSpace.matrix=H}break;case v.Range:{if(((y=(g=this.currentTrack)==null?void 0:g.info)==null?void 0:y.type)!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=U(e,s)===2}break;case v.TransferCharacteristics:{if(((S=(T=this.currentTrack)==null?void 0:T.info)==null?void 0:S.type)!=="video"||!this.currentTrack.info.colorSpace)break;const z=U(e,s),H=$r[z]??null;this.currentTrack.info.colorSpace.transfer=H}break;case v.Primaries:{if(((C=(x=this.currentTrack)==null?void 0:x.info)==null?void 0:C.type)!=="video"||!this.currentTrack.info.colorSpace)break;const z=U(e,s),H=qr[z]??null;this.currentTrack.info.colorSpace.primaries=H}break;case v.Projection:{if(((E=(_=this.currentTrack)==null?void 0:_.info)==null?void 0:E.type)!=="video")break;this.readContiguousElements(e.slice(i,s))}break;case v.ProjectionPoseRoll:{if(((A=(P=this.currentTrack)==null?void 0:P.info)==null?void 0:A.type)!=="video")break;const H=-Vt(e,s);try{this.currentTrack.info.rotation=Hr(H)}catch{}}break;case v.Audio:{if(((X=(M=this.currentTrack)==null?void 0:M.info)==null?void 0:X.type)!=="audio")break;this.readContiguousElements(e.slice(i,s))}break;case v.SamplingFrequency:{if(((G=(le=this.currentTrack)==null?void 0:le.info)==null?void 0:G.type)!=="audio")break;this.currentTrack.info.sampleRate=Vt(e,s)}break;case v.Channels:{if(((se=(ee=this.currentTrack)==null?void 0:ee.info)==null?void 0:se.type)!=="audio")break;this.currentTrack.info.numberOfChannels=U(e,s)}break;case v.BitDepth:{if((($e=(ge=this.currentTrack)==null?void 0:ge.info)==null?void 0:$e.type)!=="audio")break;this.currentTrack.info.bitDepth=U(e,s)}break;case v.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e.slice(i,s)),this.currentCueTime=null}break;case v.CueTime:this.currentCueTime=U(e,s);break;case v.CueTrackPositions:{if(this.currentCueTime===null)break;m(this.currentSegment);const z={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(z),this.readContiguousElements(e.slice(i,s)),(z.trackId===-1||z.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case v.CueTrack:{const z=(bt=this.currentSegment)==null?void 0:bt.cuePoints[this.currentSegment.cuePoints.length-1];if(!z)break;z.trackId=U(e,s)}break;case v.CueClusterPosition:{const z=(ur=this.currentSegment)==null?void 0:ur.cuePoints[this.currentSegment.cuePoints.length-1];if(!z)break;m(this.currentSegment),z.clusterPosition=this.currentSegment.dataStartPos+U(e,s)}break;case v.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=U(e,s)}break;case v.SimpleBlock:{if(!this.currentCluster)break;const z=lt(e);if(z===null)break;const H=$t(e),Ee=O(e),Ie=!!(Ee&128),_t=Ee>>1&3;this.getTrackDataInCluster(this.currentCluster,z).blocks.push({timestamp:H,duration:0,isKeyFrame:Ie,referencedTimestamps:[],data:q(e,s-(e.filePos-i)),lacing:_t})}break;case v.BlockGroup:{if(!this.currentCluster)break;if(this.readContiguousElements(e.slice(i,s)),this.currentBlock){for(let z=0;z<this.currentBlock.referencedTimestamps.length;z++)this.currentBlock.referencedTimestamps[z]+=this.currentBlock.timestamp;this.currentBlock=null}}break;case v.Block:{if(!this.currentCluster)break;const z=lt(e);if(z===null)break;const H=$t(e),Ie=O(e)>>1&3,_t=this.getTrackDataInCluster(this.currentCluster,z);this.currentBlock={timestamp:H,duration:0,isKeyFrame:!0,referencedTimestamps:[],data:q(e,s-(e.filePos-i)),lacing:Ie},_t.blocks.push(this.currentBlock)}break;case v.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=U(e,s)}break;case v.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1;const z=Ki(e,s);this.currentBlock.referencedTimestamps.push(z)}break}return e.filePos=i+s,!0}}class Vn{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return(e==null?void 0:e.timestamp)??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}async getFirstPacket(e){return this.performClusterLookup(()=>{const r=this.internalTrack.segment.clusters[0]??null;if(r!=null&&r.isKnownToBeFirstCluster){let n=r;for(;n;){if(n.trackData.get(this.internalTrack.id))return{clusterIndex:j(this.internalTrack.clusters,n.elementStartPos,i=>i.elementStartPos),blockIndex:0,correctBlockFound:!0};n=n.nextCluster}}return{clusterIndex:-1,blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,e)}intoTimescale(e){return xt(e*this.internalTrack.segment.timestampFactor,14)}async getPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findBlockInClustersForTimestamp(n),n,n,r)}async getNextPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const s=n.cluster.trackData.get(this.internalTrack.id),i=j(this.internalTrack.clusters,n.cluster.elementStartPos,a=>a.elementStartPos);return m(i!==-1),this.performClusterLookup(()=>{if(n.blockIndex+1<s.blocks.length)return{clusterIndex:i,blockIndex:n.blockIndex+1,correctBlockFound:!0};{let a=n.cluster;for(;a.nextCluster;)if(a=a.nextCluster,a.trackData.get(this.internalTrack.id)){const l=j(this.internalTrack.clusters,a.elementStartPos,d=>d.elementStartPos);return m(l!==-1),{clusterIndex:l,blockIndex:0,correctBlockFound:!0}}return{clusterIndex:i,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async getKeyPacket(e,r){const n=this.intoTimescale(e);return this.performClusterLookup(()=>this.findKeyBlockInClustersForTimestamp(n),n,n,r)}async getNextKeyPacket(e,r){const n=this.packetToClusterLocation.get(e);if(n===void 0)throw new Error("Packet was not created from this track.");const s=n.cluster.trackData.get(this.internalTrack.id),i=j(this.internalTrack.clusters,n.cluster.elementStartPos,a=>a.elementStartPos);return m(i!==-1),this.performClusterLookup(()=>{const a=s.blocks.findIndex((o,l)=>o.isKeyFrame&&l>n.blockIndex);if(a!==-1)return{clusterIndex:i,blockIndex:a,correctBlockFound:!0};{let o=n.cluster;for(;o.nextCluster;){o=o.nextCluster;const l=o.trackData.get(this.internalTrack.id);if(l&&l.firstKeyFrameTimestamp!==null){const d=j(this.internalTrack.clusters,o.elementStartPos,f=>f.elementStartPos);m(d!==-1);const u=l.blocks.findIndex(f=>f.isKeyFrame);return m(u!==-1),{clusterIndex:d,blockIndex:u,correctBlockFound:!0}}}return{clusterIndex:i,blockIndex:-1,correctBlockFound:!1}}},-1/0,1/0,r)}async fetchPacketInCluster(e,r,n){if(r===-1)return null;const i=e.trackData.get(this.internalTrack.id).blocks[r];m(i);const a=n.metadataOnly?pe:i.data,o=i.timestamp/this.internalTrack.segment.timestampFactor,l=i.duration/this.internalTrack.segment.timestampFactor,d=new $(a,i.isKeyFrame?"key":"delta",o,l,e.dataStartPos+r,i.data.byteLength);return this.packetToClusterLocation.set(d,{cluster:e,blockIndex:r}),d}findBlockInClustersForTimestamp(e){const r=W(this.internalTrack.clusters,e,i=>i.trackData.get(this.internalTrack.id).startTimestamp);let n=-1,s=!1;if(r!==-1){const a=this.internalTrack.clusters[r].trackData.get(this.internalTrack.id),o=W(a.presentationTimestamps,e,l=>l.timestamp);m(o!==-1),n=a.presentationTimestamps[o].blockIndex,s=e<a.endTimestamp}return{clusterIndex:r,blockIndex:n,correctBlockFound:s}}findKeyBlockInClustersForTimestamp(e){const r=W(this.internalTrack.clustersWithKeyFrame,e,a=>a.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp);let n=-1,s=-1,i=!1;if(r!==-1){const a=this.internalTrack.clustersWithKeyFrame[r];n=j(this.internalTrack.clusters,a.elementStartPos,u=>u.elementStartPos),m(n!==-1);const o=a.trackData.get(this.internalTrack.id),l=Qr(o.presentationTimestamps,u=>o.blocks[u.blockIndex].isKeyFrame&&u.timestamp<=e);m(l!==-1),s=o.presentationTimestamps[l].blockIndex,i=e<o.endTimestamp}return{clusterIndex:n,blockIndex:s,correctBlockFound:i}}async performClusterLookup(e,r,n,s){const{demuxer:i,segment:a}=this.internalTrack,o=await a.clusterLookupMutex.acquire();try{const{clusterIndex:l,blockIndex:d,correctBlockFound:u}=e();if(u){const y=this.internalTrack.clusters[l];return this.fetchPacketInCluster(y,d,s)}let f=null,h=l,w=d;const c=W(this.internalTrack.cuePoints,r,y=>y.time),p=c!==-1?this.internalTrack.cuePoints[c]:null;let b,k=!1;if(l===-1)b=(p==null?void 0:p.clusterPosition)??a.clusterSeekStartPos,k=b===a.clusterSeekStartPos;else{const y=this.internalTrack.clusters[l];!p||y.elementStartPos>=p.clusterPosition?(b=y.elementEndPos,f=y):b=p.clusterPosition}for(;a.elementEndPos===null||b<=a.elementEndPos-oe;){if(f){const E=f.trackData.get(this.internalTrack.id);if(E&&E.startTimestamp>n)break;if(f.nextCluster){b=f.nextCluster.elementEndPos,f=f.nextCluster;continue}}let y=i.reader.requestSliceRange(b,oe,ve);if(y instanceof Promise&&(y=await y),!y)break;const T=b,S=xe(y);if(!S||!ht.includes(S.id)&&S.id!==v.Void){const E=await Pn(i.reader,T,ht,Math.min(a.elementEndPos??1/0,T+Nn));if(E){b=E;continue}else break}const x=S.id;let C=S.size;const _=y.filePos;if(x===v.Cluster){const E=j(a.clusters,T,le=>le.elementStartPos);let P;E===-1?P=await i.readCluster(T,a):P=a.clusters[E],f&&(f.nextCluster=P),f=P,k&&(P.isKnownToBeFirstCluster=!0,k=!1);const{clusterIndex:A,blockIndex:M,correctBlockFound:X}=e();if(X){const le=this.internalTrack.clusters[A];return this.fetchPacketInCluster(le,M,s)}A!==-1&&(h=A,w=M)}if(C===null){x===v.Cluster?(m(f),C=f.elementEndPos-_):C=(await Xt(i.reader,_,Kt,a.elementEndPos)).pos-_;const E=_+C;if(a.elementEndPos!==null&&E>a.elementEndPos-oe)break;{let P=i.reader.requestSliceRange(E,oe,ve);if(P instanceof Promise&&(P=await P),!P)break;if(ar(P)===v.Segment){a.elementEndPos=E;break}}}b=_+C}const g=h!==-1?this.internalTrack.clusters[h]:null;if(p&&(!g||g.elementStartPos<p.clusterPosition)){const y=this.internalTrack.cuePoints[c-1],T=(y==null?void 0:y.time)??-1/0;return this.performClusterLookup(e,T,n,s)}return g?this.fetchPacketInCluster(g,w,s):null}finally{o()}}}class qa extends Vn{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){var e,r,n,s;return{primaries:(e=this.internalTrack.info.colorSpace)==null?void 0:e.primaries,transfer:(r=this.internalTrack.info.colorSpace)==null?void 0:r.transfer,matrix:(n=this.internalTrack.info.colorSpace)==null?void 0:n.matrix,fullRange:(s=this.internalTrack.info.colorSpace)==null?void 0:s.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??(this.decoderConfigPromise=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:Zr({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?sn(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?an(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?on(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?ln(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})()):null}}class $a extends Vn{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??(this.decoderConfig={codec:Jr({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}):null}}const ja=t=>{const e=new Map;for(let i=0;i<t.length;i++){const a=t[i];e.set(a.timestamp,a)}const r=new Set,n=[],s=i=>{if(!r.has(i)){r.add(i);for(let a=0;a<i.referencedTimestamps.length;a++){const o=i.referencedTimestamps[a],l=e.get(o);l&&s(l)}n.push(i)}};for(let i=0;i<t.length;i++)s(t[i]);return n};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Un=t=>re(t,3)!=="ID3"?(t.skip(-3),null):(t.skip(3),{size:Ka(F(t))}),Zt=async(t,e,r)=>{let n=e;for(;r===null||n<r;){let s=t.requestSlice(n,vn);if(s instanceof Promise&&(s=await s),!s)break;const i=F(s),a=na(i,t.fileSize!==null?t.fileSize-n:null);if(a.header)return{header:a.header,startPos:n};n+=a.bytesAdvanced}return null},Ka=t=>{let e=2130706432,r=0;for(;e!==0;)r>>=1,r|=t&e,e>>=8;return r};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Qa extends nt{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new We,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();m(this.firstFrameHeader),this.tracks=[new Le(new Xa(this))]})())}async advanceReader(){if(this.lastLoadedPos===0){let u=this.reader.requestSlice(0,10);if(u instanceof Promise&&(u=await u),!u){this.lastSampleLoaded=!0;return}const f=Un(u);f&&(this.lastLoadedPos+=10+f.size)}const e=this.lastLoadedPos,r=await Zt(this.reader,e,this.reader.fileSize);if(!r){this.lastSampleLoaded=!0;return}const n=r.header;this.lastLoadedPos=r.startPos+n.totalSize-1;const s=ra(n.mpegVersionId,n.channel);let i=this.reader.requestSlice(e+s,4);i instanceof Promise&&(i=await i),m(i);const a=F(i);if(a===Ji||a===ea)return;this.firstFrameHeader||(this.firstFrameHeader=n);const l=n.audioSamplesInFrame/n.sampleRate,d={timestamp:this.nextTimestampInSamples/n.sampleRate,duration:l,dataStart:e,dataSize:n.totalSize};this.loadedSamples.push(d),this.nextTimestampInSamples+=n.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}}class Xa{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return null}getLanguageCode(){return ce}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}async getDecoderConfig(){return m(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let s;if(r.metadataOnly)s=pe;else{let i=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(i instanceof Promise&&(i=await i),!i)return null;s=q(i,n.dataSize)}return new $(s,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const s=j(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const i=s+1;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const s=W(this.demuxer.loadedSamples,e,i=>i.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,r);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ga extends nt{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,Me,Je);if(r instanceof Promise&&(r=await r),!r)break;const n=ft(r);if(!n||!!!(n.headerType&2))break;this.bitstreams.push({serialNumber:n.serialNumber,bosPage:n,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=n.headerStartPos+n.totalSize}for(const r of this.bitstreams){const n=await this.readPacket(r.bosPage,0);n&&(n.data.byteLength>=7&&n.data[0]===1&&n.data[1]===118&&n.data[2]===111&&n.data[3]===114&&n.data[4]===98&&n.data[5]===105&&n.data[6]===115?await this.readVorbisMetadata(n,r):n.data.byteLength>=8&&n.data[0]===79&&n.data[1]===112&&n.data[2]===117&&n.data[3]===115&&n.data[4]===72&&n.data[5]===101&&n.data[6]===97&&n.data[7]===100&&await this.readOpusMetadata(n,r),r.codecInfo.codec!==null&&this.tracks.push(new Le(new Ya(r,this))))}})())}async readVorbisMetadata(e,r){let n=await this.findNextPacketStart(e);if(!n)return;const s=await this.readPacket(n.startPage,n.startSegmentIndex);if(!s||(n=await this.findNextPacketStart(s),!n))return;const i=await this.readPacket(n.startPage,n.startSegmentIndex);if(!i||s.data[0]!==3||i.data[0]!==5)return;const a=[],o=f=>{for(;a.push(Math.min(255,f)),!(f<255);)f-=255};o(e.data.length),o(s.data.length);const l=new Uint8Array(1+a.length+e.data.length+s.data.length+i.data.length);l[0]=a.length,l.set(a,1),l.set(e.data,1+a.length),l.set(s.data,1+a.length+e.data.length),l.set(i.data,1+a.length+e.data.length+s.data.length),r.codecInfo.codec="vorbis",r.description=l,r.lastMetadataPacket=i;const d=ae(e.data);r.numberOfChannels=d.getUint8(11),r.sampleRate=d.getUint32(12,!0);const u=d.getUint8(28);r.codecInfo.vorbisInfo={blocksizes:[1<<(u&15),1<<(u>>4)],modeBlockflags:_s(i.data).modeBlockflags}}async readOpusMetadata(e,r){const n=await this.findNextPacketStart(e);if(!n)return;const s=await this.readPacket(n.startPage,n.startSegmentIndex);if(!s)return;r.codecInfo.codec="opus",r.description=e.data,r.lastMetadataPacket=s;const i=un(e.data);r.numberOfChannels=i.outputChannelCount,r.sampleRate=i.inputSampleRate,r.codecInfo.opusInfo={preSkip:i.preSkip}}async readPacket(e,r){m(r<e.lacingValues.length);let n=0;for(let f=0;f<r;f++)n+=e.lacingValues[f];let s=e,i=n,a=r;const o=[];e:for(;;){let f=this.reader.requestSlice(s.dataStartPos,s.dataSize);f instanceof Promise&&(f=await f),m(f);const h=q(f,s.dataSize);for(;;){if(a===s.lacingValues.length){o.push(h.subarray(n,i));break}const c=s.lacingValues[a];if(i+=c,c<255){o.push(h.subarray(n,i));break e}a++}let w=s.headerStartPos+s.totalSize;for(;;){let c=this.reader.requestSliceRange(w,Me,Je);if(c instanceof Promise&&(c=await c),!c)return null;const p=ft(c);if(!p)return null;if(s=p,s.serialNumber===e.serialNumber)break;w=s.headerStartPos+s.totalSize}n=0,i=0,a=0}const l=o.reduce((f,h)=>f+h.length,0),d=new Uint8Array(l);let u=0;for(let f=0;f<o.length;f++){const h=o[f];d.set(h,u),u+=h.length}return{data:d,endPage:s,endSegmentIndex:a}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(e.endPage.headerType&4))return null;let n=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){let s=this.reader.requestSliceRange(n,Me,Je);if(s instanceof Promise&&(s=await s),!s)return null;const i=ft(s);if(!i)return null;if(i.serialNumber===e.endPage.serialNumber)return{startPage:i,startSegmentIndex:0};n=i.headerStartPos+i.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.getCodecParameterString()));return oa({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(n=>n.computeDuration()));return Math.max(0,...r)}}class Ya{constructor(e,r){this.bitstream=e,this.demuxer=r,this.encodedPacketToMetadata=new WeakMap,this.sequentialScanCache=[],this.sequentialScanMutex=new We,this.internalSampleRate=e.codecInfo.codec==="opus"?rs:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return m(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return ce}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(m(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,r,n){if(!e)return null;const{durationInSamples:s,vorbisBlockSize:i}=aa(e.data,this.bitstream.codecInfo,r.vorbisLastBlocksize),a=new $(n.metadataOnly?pe:e.data,"key",Math.max(0,r.timestampInSamples)/this.internalSampleRate,s/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:r.timestampInSamples,durationInSamples:s,vorbisLastBlockSize:r.vorbisLastBlocksize,vorbisBlockSize:i}),a}async getFirstPacket(e){m(this.bitstream.lastMetadataPacket);const r=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!r)return null;let n=0;this.bitstream.codecInfo.codec==="opus"&&(m(this.bitstream.codecInfo.opusInfo),n-=this.bitstream.codecInfo.opusInfo.preSkip);const s=await this.demuxer.readPacket(r.startPage,r.startSegmentIndex);return this.createEncodedPacketFromOggPacket(s,{timestampInSamples:n,vorbisLastBlocksize:null},e)}async getNextPacket(e,r){const n=this.encodedPacketToMetadata.get(e);if(!n)throw new Error("Packet was not created from this track.");const s=await this.demuxer.findNextPacketStart(n.packet);if(!s)return null;const i=n.timestampInSamples+n.durationInSamples,a=await this.demuxer.readPacket(s.startPage,s.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:i,vorbisLastBlocksize:n.vorbisBlockSize},r)}async getPacket(e,r){if(this.demuxer.reader.fileSize===null)return this.getPacketSequential(e,r);const n=xt(e*this.internalSampleRate,14);if(n===0)return this.getFirstPacket(r);if(n<0)return null;m(this.bitstream.lastMetadataPacket);const s=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!s)return null;let i=s.startPage,a=this.demuxer.reader.fileSize;const o=[i];e:for(;i.headerStartPos+i.totalSize<a;){const g=i.headerStartPos,y=Math.floor((g+a)/2);let T=y;for(;;){const S=Math.min(T+ca,a-Me);let x=this.demuxer.reader.requestSlice(T,S-T);if(x instanceof Promise&&(x=await x),m(x),!la(x,S)){a=y+Me;continue e}let _=this.demuxer.reader.requestSliceRange(x.filePos,Me,Je);_ instanceof Promise&&(_=await _),m(_);const E=ft(_);m(E);let P=!1;if(E.serialNumber===this.bitstream.serialNumber)P=!0;else{let M=this.demuxer.reader.requestSlice(E.headerStartPos,E.totalSize);M instanceof Promise&&(M=await M),m(M);const X=q(M,E.totalSize);P=ia(X)===E.checksum}if(!P){T=E.headerStartPos+4;continue}if(P&&E.serialNumber!==this.bitstream.serialNumber){T=E.headerStartPos+E.totalSize;continue}if(E.granulePosition===-1){T=E.headerStartPos+E.totalSize;continue}this.granulePositionToTimestampInSamples(E.granulePosition)>n?a=E.headerStartPos:(i=E,o.push(E));continue e}}let l=s.startPage;for(const g of o){if(g.granulePosition===i.granulePosition)break;(!l||g.headerStartPos>l.headerStartPos)&&(l=g)}let d=l;const u=[d];for(;!(d.serialNumber===this.bitstream.serialNumber&&d.granulePosition===i.granulePosition);){const g=d.headerStartPos+d.totalSize;let y=this.demuxer.reader.requestSliceRange(g,Me,Je);y instanceof Promise&&(y=await y),m(y);const T=ft(y);m(T),d=T,d.serialNumber===this.bitstream.serialNumber&&u.push(d)}m(d.granulePosition!==-1);let f=null,h,w,c=d,p=0;if(d.headerStartPos===s.startPage.headerStartPos)h=this.granulePositionToTimestampInSamples(0),w=!0,f=0;else{h=0,w=!1;for(let T=d.lacingValues.length-1;T>=0;T--)if(d.lacingValues[T]<255){f=T+1;break}if(f===null)throw new Error("Invalid page with granule position: no packets end on this page.");p=f-1;const g={data:pe,endPage:c,endSegmentIndex:p};if(await this.demuxer.findNextPacketStart(g)){const T=Wr(u,d,f);m(T);const S=Ur(u,T.page,T.segmentIndex);S&&(d=S.page,f=S.segmentIndex)}else for(;;){const T=Wr(u,d,f);if(!T)break;const S=Ur(u,T.page,T.segmentIndex);if(!S)break;if(d=S.page,f=S.segmentIndex,T.page.headerStartPos!==c.headerStartPos){c=T.page,p=T.segmentIndex;break}}}let b=null,k=null;for(;d!==null;){m(f!==null);const g=await this.demuxer.readPacket(d,f);if(!g)break;if(!(d.headerStartPos===s.startPage.headerStartPos&&f<s.startSegmentIndex)){let S=this.createEncodedPacketFromOggPacket(g,{timestampInSamples:h,vorbisLastBlocksize:(k==null?void 0:k.vorbisBlockSize)??null},r);m(S);let x=this.encodedPacketToMetadata.get(S);if(m(x),!w&&g.endPage.headerStartPos===c.headerStartPos&&g.endSegmentIndex===p?(h=this.granulePositionToTimestampInSamples(d.granulePosition),w=!0,S=this.createEncodedPacketFromOggPacket(g,{timestampInSamples:h-x.durationInSamples,vorbisLastBlocksize:(k==null?void 0:k.vorbisBlockSize)??null},r),m(S),x=this.encodedPacketToMetadata.get(S),m(x)):h+=x.durationInSamples,b=S,k=x,w&&(Math.max(h,0)>n||Math.max(x.timestampInSamples,0)===n))break}const T=await this.demuxer.findNextPacketStart(g);if(!T)break;d=T.startPage,f=T.startSegmentIndex}return b}async getPacketSequential(e,r){const n=await this.sequentialScanMutex.acquire();try{const s=xt(e*this.internalSampleRate,14);e=s/this.internalSampleRate;const i=W(this.sequentialScanCache,s,l=>l.timestampInSamples);let a;if(i!==-1){const l=this.sequentialScanCache[i];a=this.createEncodedPacketFromOggPacket(l.packet,{timestampInSamples:l.timestampInSamples,vorbisLastBlocksize:l.vorbisLastBlockSize},r)}else a=await this.getFirstPacket(r);let o=0;for(;a&&a.timestamp<e;){const l=await this.getNextPacket(a,r);if(!l||l.timestamp>e)break;if(a=l,o++,o===100){o=0;const d=this.encodedPacketToMetadata.get(a);m(d),this.sequentialScanCache.length>0&&m(K(this.sequentialScanCache).timestampInSamples<=d.timestampInSamples),this.sequentialScanCache.push(d)}}return a}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const Ur=(t,e,r)=>{let n=e,s=r;e:for(;;){for(s--,s;s>=0;s--)if(n.lacingValues[s]<255){s++;break e}if(m(s===-1),!(n.headerType&1)){s=0;break}const a=Kr(t,o=>o.headerStartPos<n.headerStartPos);if(!a)return null;n=a,s=n.lacingValues.length}if(m(s!==-1),s===n.lacingValues.length){const i=t[t.indexOf(n)+1];m(i),n=i,s=0}return{page:n,segmentIndex:s}},Wr=(t,e,r)=>{if(r>0)return{page:e,segmentIndex:r-1};const n=Kr(t,s=>s.headerStartPos<e.headerStartPos);return n?{page:n,segmentIndex:n.lacingValues.length-1}:null};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const vt=7,Et=9,Jt=t=>{const e=t.filePos,r=q(t,9),n=new Z(r);if(n.readBits(12)!==4095||(n.skipBits(1),n.readBits(2)!==0))return null;const a=n.readBits(1),o=n.readBits(2)+1,l=n.readBits(4);if(l===15)return null;n.skipBits(1);const d=n.readBits(3);if(d===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");n.skipBits(1),n.skipBits(1),n.skipBits(1),n.skipBits(1);const u=n.readBits(13);n.skipBits(11);const f=n.readBits(2)+1;if(f!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let h=null;return a===1?t.filePos-=2:h=n.readBits(16),{objectType:o,samplingFrequencyIndex:l,channelConfiguration:d,frameLength:u,numberOfAacFrames:f,crcCheck:h,startPos:e}};/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const er=1024;class Za extends nt{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new We,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??(this.metadataPromise=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();m(this.firstFrameHeader),this.tracks=[new Le(new Ja(this))]})())}async advanceReader(){let e=this.reader.requestSliceRange(this.lastLoadedPos,vt,Et);if(e instanceof Promise&&(e=await e),!e){this.lastSampleLoaded=!0;return}const r=Jt(e);if(!r){this.lastSampleLoaded=!0;return}if(this.reader.fileSize!==null&&r.startPos+r.frameLength>this.reader.fileSize){this.lastSampleLoaded=!0;return}this.firstFrameHeader||(this.firstFrameHeader=r);const n=Pt[r.samplingFrequencyIndex];m(n!==void 0);const s=er/n,i=r.crcCheck?Et:vt,a={timestamp:this.nextTimestampInSamples/n,duration:s,dataStart:r.startPos+i,dataSize:r.frameLength-i};this.loadedSamples.push(a),this.nextTimestampInSamples+=er,this.lastLoadedPos=r.startPos+r.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}}class Ja{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/er}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return((e==null?void 0:e.timestamp)??0)+((e==null?void 0:e.duration)??0)}getName(){return null}getLanguageCode(){return ce}getCodec(){return"aac"}getInternalCodecId(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){m(this.demuxer.firstFrameHeader);const e=en[this.demuxer.firstFrameHeader.channelConfiguration];return m(e!==void 0),e}getSampleRate(){m(this.demuxer.firstFrameHeader);const e=Pt[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return m(e!==void 0),e}async getDecoderConfig(){m(this.demuxer.firstFrameHeader);const e=new Uint8Array(3),r=new Z(e),{objectType:n,samplingFrequencyIndex:s,channelConfiguration:i}=this.demuxer.firstFrameHeader;return n>31?(r.writeBits(5,31),r.writeBits(6,n-32)):r.writeBits(5,n),r.writeBits(4,s),r.writeBits(4,i),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate(),description:e.subarray(0,Math.ceil((r.pos-1)/8))}}async getPacketAtIndex(e,r){if(e===-1)return null;const n=this.demuxer.loadedSamples[e];if(!n)return null;let s;if(r.metadataOnly)s=pe;else{let i=this.demuxer.reader.requestSlice(n.dataStart,n.dataSize);if(i instanceof Promise&&(i=await i),!i)return null;s=q(i,n.dataSize)}return new $(s,"key",n.timestamp,n.duration,e,n.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{const s=j(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const i=s+1;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,r)}finally{n()}}async getPacket(e,r){const n=await this.demuxer.readingMutex.acquire();try{for(;;){const s=W(this.demuxer.loadedSamples,e,i=>i.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,r);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,r);await this.demuxer.advanceReader()}}finally{n()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class qe{}class Wn extends qe{async _getMajorBrand(e){let r=e._reader.requestSlice(0,12);return r instanceof Promise&&(r=await r),!r||(r.skip(4),re(r,4)!=="ftyp")?null:re(r,4)}_createDemuxer(e){return new Ra(e)}}class eo extends Wn{async _canReadInput(e){const r=await this._getMajorBrand(e);return!!r&&r!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class to extends Wn{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class Hn extends qe{async isSupportedEBMLOfDocType(e,r){let n=e._reader.requestSlice(0,ve);if(n instanceof Promise&&(n=await n),!n)return!1;const s=xn(n);if(s===null||s<1||s>8||U(n,s)!==v.EBML)return!1;const a=Cn(n);if(a===null)return!1;let o=e._reader.requestSlice(n.filePos,a);if(o instanceof Promise&&(o=await o),!o)return!1;const l=n.filePos;for(;o.filePos<=l+a-oe;){const d=xe(o);if(!d)break;const{id:u,size:f}=d,h=o.filePos;if(f===null)return!1;switch(u){case v.EBMLVersion:if(U(o,f)!==1)return!1;break;case v.EBMLReadVersion:if(U(o,f)!==1)return!1;break;case v.DocType:if(ut(o,f)!==r)return!1;break;case v.DocTypeVersion:if(U(o,f)>4)return!1;break}o.filePos=h+f}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new La(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class ro extends Hn{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class no extends qe{async _canReadInput(e){let r=e._reader.requestSlice(0,10);if(r instanceof Promise&&(r=await r),!r)return!1;let n=0;const s=Un(r);s&&(n=r.filePos+s.size);const i=await Zt(e._reader,n,n+4096);if(!i)return!1;if(s)return!0;n=i.startPos+=i.header.totalSize;const a=await Zt(e._reader,n,n+vn);if(!a)return!1;const o=i.header,l=a.header;return!(o.channel!==l.channel||o.sampleRate!==l.sampleRate)}_createDemuxer(e){return new Qa(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class so extends qe{async _canReadInput(e){let r=e._reader.requestSlice(0,12);if(r instanceof Promise&&(r=await r),!r)return!1;const n=re(r,4);return n!=="RIFF"&&n!=="RIFX"&&n!=="RF64"?!1:(r.skip(4),re(r,4)==="WAVE")}_createDemuxer(e){return new wa(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class io extends qe{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?re(r,4)==="OggS":!1}_createDemuxer(e){return new Ga(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}class ao extends qe{async _canReadInput(e){let r=e._reader.requestSliceRange(0,vt,Et);if(r instanceof Promise&&(r=await r),!r)return!1;const n=Jt(r);if(!n||(r=e._reader.requestSliceRange(n.frameLength,vt,Et),r instanceof Promise&&(r=await r),!r))return!1;const s=Jt(r);return s?n.objectType===s.objectType&&n.samplingFrequencyIndex===s.samplingFrequencyIndex&&n.channelConfiguration===s.channelConfiguration:!1}_createDemuxer(e){return new Za(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}const oo=new eo,co=new to,lo=new Hn,uo=new ro,fo=new no,mo=new so,ho=new io,po=new ao,go=[oo,co,lo,uo,mo,ho,fo,po];/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ko{constructor(e){if(this._demuxerPromise=null,this._format=null,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(r=>!(r instanceof qe)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof Rn))throw new TypeError("options.source must be a Source.");this._formats=e.formats,this._source=e.source,this._reader=new Ni(e.source)}_getDemuxer(){return this._demuxerPromise??(this._demuxerPromise=(async()=>{this._reader.fileSize=await this._source.getSizeOrNull();for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})())}get source(){return this._source}async getFormat(){return await this._getDemuxer(),m(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(r=>r.isVideoTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(r=>r.isVideoTrack())??null}async getAudioTracks(){return(await this.getTracks()).filter(r=>r.isAudioTrack())}async getPrimaryAudioTrack(){return(await this.getTracks()).find(r=>r.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}}var pt;class wo extends $n{constructor(){super();Ft(this,"description");Ft(this,"title");hr(this,pt);const r=document.createElement("div"),n=document.createElement("h1");n.setAttribute("id","title"),n.textContent="Exporting";const s=document.createElement("span");s.classList.add("ellipsis"),n.appendChild(s),r.appendChild(n);const i=new Image;i.src="./nyancat_big.gif",r.appendChild(i);const a=document.createElement("h4");a.setAttribute("id","desc"),r.appendChild(a),a.textContent="initializing sequence...",pr(this,pt,r),this.title=n,this.description=a}open(){super.open(mr(this,pt))}}pt=new WeakMap;const Xe=new wo,bo=t=>t*(Math.PI/180),To=(t,e,r)=>new Promise(n=>{t.addEventListener("seeked",()=>{const s=new VideoFrame(t,{timestamp:r});n(s)},{once:!0}),t.currentTime=e}),yo=async(t,e,r)=>{const n=t.getContext("2d");n.clearRect(0,0,t.width,t.height),n.fillStyle="white",n.fillRect(0,0,t.width,t.height);for(const{srcElement:s,isHidden:i,tlContent:a,node:o}of e)if(s&&s instanceof HTMLVideoElement&&a&&o){const{tlStart:l,trimStart:d,tlEnd:u}=a.getAllDataset();if(i||r<+l||r>+u)continue;const f=window.editor.myProject.canvasPixelRatio;n.save();const{x:h,y:w}=o.position();n.translate(h*f,w*f);const c=bo(o.rotation());c&&n.rotate(c);const p=+d+(r-+l),b=await To(s,p,r);n.drawImage(b,0,0,o.width()*o.scaleX()*f,o.height()*o.scaleY()*f),b.close(),n.restore()}},So=async()=>{const t=Xe.description,e=window.editor.myProject.getProjectDuration(),r=new AudioContext,n=r.createBuffer(2,r.sampleRate*e,r.sampleRate),s=window.editor.myProject.nodes.filter(i=>i.hasAudio());for(let i=0;i<s.length;i++){t.textContent=`compiling audio... [${i+1}/${s.length}]`;const a=s[i],o=await jn(a.src);await new ko({formats:go,source:new za(o)}).getPrimaryAudioTrack(),console.log({cancodec:!1,nodeId:a.id});const u=await a.getTrimmedAudioBuffer(t);for(let f=0;f<u.numberOfChannels;f++){const h=n.getChannelData(f),w=u.getChannelData(f);for(let c=0;c<u.getChannelData(f).length;c++)h[c]+=w[c];n.getChannelData(f).set(h)}}return De.fromAudioBuffer(n,0)},vo=async(t=30)=>{const e=t*1e3/1001;if(console.time("export"),window.editor.myProject.save(),window.editor.myProject.getProjectDuration()<=0)return alert("No project to export");window.editor.myProject.transformer.hide(),Xe.open();const r=Xe.title,n=Xe.description;try{const s=new WritableStream({write({data:T}){return gr.saveChunk(T)}}),i=new Bn({fastStart:"fragmented"}),a=new Aa({target:new Di(s,{chunked:!0,chunkSize:2**20}),format:i});n.textContent="compiling audio...";const o=i.getSupportedAudioCodecs(),l=await Pa(o),d=new _a({codec:l,bitrate:Pr});a.addAudioTrack(d);const{width:u,height:f}=window.editor.myProject.presetSize(),h=new OffscreenCanvas(u,f),w=i.getSupportedVideoCodecs(),c=new Ea(h,{codec:w[1],bitrate:Pr});a.addVideoTrack(c),await a.start();const p=await So();for(const T of p)await d.add(T);d.close(),n.textContent="audio compiled!",n.textContent="compiling video...";const b=window.editor.myProject.getProjectDuration(),k=Math.round(e*b),y=window.editor.myProject.nodes.filter(T=>T.type==="video"&&T.node).sort((T,S)=>T.node.zIndex()-S.node.zIndex());for(let T=0;T<k;T++){const S=T/e;if(await yo(h,y,S),await c.add(S,1/e),n.textContent=`compiling video...${Math.round(T/k*100)}%`,T===k-1){c.close(),await a.finalize(),r.textContent="ðð DONE!!! ðð",n.textContent="file was saved in your browser download folder";const x=`ratreel-hensemdev${a.format.fileExtension}`,C=await gr.getFile(),_=URL.createObjectURL(C),E=document.createElement("a");E.href=_,E.download=x,E.click(),URL.revokeObjectURL(_);const P=setTimeout(()=>{console.timeEnd("export"),Xe.close(),clearTimeout(P)},1e3*5)}}}catch(s){r.textContent="[ERROR] Owh no!!! ð­",n.textContent="Unexpected error occured";const i=setTimeout(()=>{console.timeEnd("export"),Xe.close(),clearTimeout(i)},1e3*5);console.error(s)}};export{vo as default};
